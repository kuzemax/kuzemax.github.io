
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.29.1" theme-name="Stellar" theme-version="1.29.1">
  
  <meta name="generator" content="Hexo 7.3.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  
  <title>编写基于arkime的工控插件的学习过程 - kuzemax's blog</title>

  
    <meta name="description" content="在虚拟机上安装samba服务器 sudo service smbd start 然后在主机上连接虚拟机 写代码会方便点插件要求：如何基于流量引擎Arkime开发OPC、Modbus、SiemensS7、Ethernet&#x2F;IP、IEC104⼯控协议解析插件.1.能够解析⼯控协议（OPC、Modbus、SiemensS7、Ethernet&#x2F;IP、IEC104）2.以插件so⽅式集成">
<meta property="og:type" content="article">
<meta property="og:title" content="编写基于arkime的工控插件的学习过程">
<meta property="og:url" content="https://kuzemax.github.io/2025/02/05/%E7%BC%96%E5%86%99%E5%9F%BA%E4%BA%8Earkime%E7%9A%84%E5%B7%A5%E6%8E%A7%E6%8F%92%E4%BB%B6%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/index.html">
<meta property="og:site_name" content="kuzemax&#39;s blog">
<meta property="og:description" content="在虚拟机上安装samba服务器 sudo service smbd start 然后在主机上连接虚拟机 写代码会方便点插件要求：如何基于流量引擎Arkime开发OPC、Modbus、SiemensS7、Ethernet&#x2F;IP、IEC104⼯控协议解析插件.1.能够解析⼯控协议（OPC、Modbus、SiemensS7、Ethernet&#x2F;IP、IEC104）2.以插件so⽅式集成">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-02-05T03:08:07.092Z">
<meta property="article:modified_time" content="2025-03-13T12:47:49.448Z">
<meta property="article:author" content="kuzemax">
<meta property="article:tag" content="kuze">
<meta name="twitter:card" content="summary">
  
  
  
  <meta name="keywords" content="kuze">

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.29.1">

  
    <link rel="shortcut icon" href="/image/favicon.ico">
  

  

  
</head>
<body>

<div class="l_body s:aa content tech" id="start" layout="post" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/image/OIP.jpg"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="https://i0.hdslb.com/bfs/article/43773207a13fc7094a7bd29e6d646aea401886361.jpg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">kuzemax's blog</div><div class="sub normal cap">水是眼波横，山是眉峰聚</div><div class="sub hover cap" style="opacity:0"> 聪明的我</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"></nav>
</div>
<div class="widgets">


<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/2025/02/05/%E7%BC%96%E5%86%99%E5%9F%BA%E4%BA%8Earkime%E7%9A%84%E5%B7%A5%E6%8E%A7%E6%8F%92%E4%BB%B6%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/"><span class="title">编写基于arkime的工控插件的学习过程</span></a><a class="item title" href="/2024/12/08/%E8%8B%B1%E8%AF%AD%E5%86%99%E4%BD%9C%E5%92%8C%E7%BF%BB%E8%AF%91/"><span class="title">英语写作和翻译</span></a><a class="item title" href="/2024/11/25/2024%E5%B9%B46%E6%9C%88%E8%8B%B1%E8%AF%AD%E5%85%AD%E7%BA%A7%E7%9C%9F%E9%A2%98(%E7%AC%AC3%E5%A5%97)%E7%94%9F%E8%AF%8D/"><span class="title">2024年6月英语六级真题(第3套)生词</span></a><a class="item title" href="/2024/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8D%81%E4%B8%89%E5%91%A8%E4%BD%9C%E4%B8%9A/"><span class="title">数据库十三周作业</span></a><a class="item title" href="/2024/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93b/"><span class="title">数据库b</span></a><a class="item title" href="/2024/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93A-2/"><span class="title">数据库A 2</span></a><a class="item title" href="/2024/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93A/"><span class="title">数据库A</span></a><a class="item title" href="/2024/11/15/%E6%B5%AE%E7%82%B9%E6%95%B0%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"><span class="title">浮点数二分算法模板</span></a><a class="item title" href="/2024/11/15/%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"><span class="title">整数二分算法</span></a><a class="item title" href="/2024/11/12/%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E7%94%9F%E8%AF%8D%E6%9C%AC1/"><span class="title">英语单词生词</span></a></div></widget>
</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2025-02-05T03:08:07.092Z">2025-02-05</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2025-03-13T12:47:49.448Z">2025-03-13</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>编写基于arkime的工控插件的学习过程</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><p>在虚拟机上安装samba服务器</p>
<p>sudo service smbd start</p>
<p>然后在主机上连接虚拟机</p>
<p>写代码会方便点<br>插件要求：<br>如何基于流量引擎Arkime开发OPC、Modbus、SiemensS7、Ethernet&#x2F;IP、IEC104⼯控协议解析插件.1.能够解析⼯控协议（OPC、Modbus、<br>SiemensS7、Ethernet&#x2F;IP、IEC104）<br>2.以插件so⽅式集成到 Arkime 流量解析引擎<br>3.将解析数据存储到 Elasticsearch,⽀持在<br>Arkime Viewer 界⾯中搜索和查看。<br>技 术 要 求<br>1.兼容多种架构。<br>2.C语⾔开发、涉及第三⽅库或插件的依赖需采<br>⽤静态编译⽅式。<br>3.保证插件与Arkime流量解析引擎⽆缝协作，提<br>升解析和搜索性能</p>
<p>这里先做Modbus插件测试</p>
<p>建立文件夹顺序</p>
<p>modbus-plugin</p>
<p>CMakeList.txt</p>
<p>build</p>
<p>include</p>
<p>src</p>
<p>modbus_plugin.c</p>
<p>modbus_plugin.c的内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glib.h&gt;</span>  <span class="comment">// 包含 glib.h 头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span> <span class="comment">// 包含 dlfcn.h 头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;arkime.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> ArkimeConfig_t config;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARKIME_API_VERSION 542</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARKIME_SESSIONID_LEN 40</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Modbus 功能码定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODBUS_READ_COILS          0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODBUS_READ_DISCRETE_INPUTS 0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODBUS_READ_HOLDING_REGISTERS 0x03</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODBUS_READ_INPUT_REGISTERS 0x04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODBUS_WRITE_SINGLE_COIL    0x05</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODBUS_WRITE_SINGLE_REGISTER 0x06</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODBUS_WRITE_MULTIPLE_COILS  0x0F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODBUS_WRITE_MULTIPLE_REGISTERS 0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Modbus 异常码定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODBUS_EXC_ILLEGAL_FUNCTION      0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODBUS_EXC_ILLEGAL_DATA_ADDRESS  0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODBUS_EXC_ILLEGAL_DATA_VALUE     0x03</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODBUS_EXC_SLAVE_DEVICE_FAILURE  0x04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODBUS_EXC_ACKNOWLEDGE           0x05</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODBUS_EXC_SLAVE_DEVICE_BUSY     0x06</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODBUS_EXC_NEGATIVE_ACKNOWLEDGE  0x07</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODBUS_EXC_MEMORY_PARITY_ERROR   0x08</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Modbus 数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> transactionId;</span><br><span class="line">    <span class="type">uint16_t</span> protocolId;</span><br><span class="line">    <span class="type">uint16_t</span> length;</span><br><span class="line">    <span class="type">uint8_t</span>  unitId;</span><br><span class="line">    <span class="type">uint8_t</span>  functionCode;</span><br><span class="line">    <span class="type">uint16_t</span> address;       <span class="comment">// 数据地址</span></span><br><span class="line">    <span class="type">uint16_t</span> quantity;      <span class="comment">// 读取或者写入的数量</span></span><br><span class="line">    <span class="type">uint16_t</span> value;         <span class="comment">// 单个寄存器或线圈的值</span></span><br><span class="line">    <span class="type">uint8_t</span> *data;          <span class="comment">// 写入或读取的数据</span></span><br><span class="line">    <span class="type">uint16_t</span> dataLength;    <span class="comment">// 数据长度</span></span><br><span class="line">    <span class="type">uint8_t</span>  exceptionCode; <span class="comment">// 异常码</span></span><br><span class="line">    <span class="type">char</span>   *description;    <span class="comment">// 描述信息</span></span><br><span class="line">&#125; ModbusData;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量，存储字段位置</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> modbus_transaction_id_field;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> modbus_function_code_field;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> modbus_description_field;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> modbus_unit_id_field;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> modbus_address_field;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> modbus_quantity_field;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> modbus_data_field;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> modbus_src_port_field;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> modbus_dest_port_field;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> modbus_exc_code_field;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明 (保持不变)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">modbus_free_data</span><span class="params">(ModbusData *data)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">modbus_process_tcp_payload</span><span class="params">(ArkimeSession_t *session, <span class="type">const</span> <span class="type">uint8_t</span> *payload, <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">modbus_parse_pdu</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *payload, <span class="type">int</span> len, ModbusData *modbusData)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义错误打印函数，带时间戳</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">modbus_log</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span> &#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, format);</span><br><span class="line"></span><br><span class="line">    <span class="type">time_t</span> timer;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">26</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">tm_info</span>;</span> <span class="comment">// 声明 struct tm 变量</span></span><br><span class="line">    time(&amp;timer);</span><br><span class="line"></span><br><span class="line">    localtime_r(&amp;timer, &amp;tm_info); <span class="comment">// 使用 localtime_r 函数</span></span><br><span class="line"></span><br><span class="line">    strftime(buffer, <span class="number">26</span>, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, &amp;tm_info); <span class="comment">// 传递指针</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s [modbus_plugin] &quot;</span>, buffer);</span><br><span class="line">    <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, format, args);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    va_end(args);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"><span class="comment">// 插件初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">arkime_plugin_init</span><span class="params">()</span> &#123;</span><br><span class="line">    modbus_log(<span class="string">&quot;arkime_plugin_init() called&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册插件</span></span><br><span class="line">    <span class="type">int</span> rc = arkime_plugins_register_internal(<span class="string">&quot;modbus&quot;</span>, TRUE, <span class="keyword">sizeof</span>(ArkimeSession_t), ARKIME_API_VERSION);</span><br><span class="line">    <span class="keyword">if</span> (rc == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ERROR: Couldn&#x27;t register plugin\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 Arkime 字段</span></span><br><span class="line">    modbus_transaction_id_field = arkime_field_define(<span class="string">&quot;modbus&quot;</span>, <span class="string">&quot;integer&quot;</span>,</span><br><span class="line">                                                     <span class="string">&quot;modbus.transactionId&quot;</span>, <span class="string">&quot;Modbus Transaction ID&quot;</span>, <span class="string">&quot;modbus.transactionId&quot;</span>,</span><br><span class="line">                                                     <span class="string">&quot;Modbus Transaction ID&quot;</span>,</span><br><span class="line">                                                     ARKIME_FIELD_TYPE_INT_HASH, <span class="number">0</span>,</span><br><span class="line">                                                     <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    modbus_function_code_field = arkime_field_define(<span class="string">&quot;modbus&quot;</span>, <span class="string">&quot;integer&quot;</span>,</span><br><span class="line">                                                   <span class="string">&quot;modbus.functionCode&quot;</span>, <span class="string">&quot;Modbus Function Code&quot;</span>, <span class="string">&quot;modbus.functionCode&quot;</span>,</span><br><span class="line">                                                   <span class="string">&quot;Modbus Function Code&quot;</span>,</span><br><span class="line">                                                   ARKIME_FIELD_TYPE_INT_HASH, <span class="number">0</span>,</span><br><span class="line">                                                   <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    modbus_description_field = arkime_field_define(<span class="string">&quot;modbus&quot;</span>, <span class="string">&quot;string&quot;</span>,</span><br><span class="line">                                                  <span class="string">&quot;modbus.description&quot;</span>, <span class="string">&quot;Modbus Description&quot;</span>, <span class="string">&quot;modbus.description&quot;</span>,</span><br><span class="line">                                                  <span class="string">&quot;Modbus Description&quot;</span>,</span><br><span class="line">                                                  ARKIME_FIELD_TYPE_STR_HASH, <span class="number">0</span>,</span><br><span class="line">                                                  <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        modbus_unit_id_field = arkime_field_define(<span class="string">&quot;modbus&quot;</span>, <span class="string">&quot;integer&quot;</span>,</span><br><span class="line">                                                      <span class="string">&quot;modbus.unitId&quot;</span>, <span class="string">&quot;Modbus Unit ID&quot;</span>, <span class="string">&quot;modbus.unitId&quot;</span>,</span><br><span class="line">                                                      <span class="string">&quot;Modbus Unit ID&quot;</span>,</span><br><span class="line">                                                      ARKIME_FIELD_TYPE_INT_HASH, <span class="number">0</span>,</span><br><span class="line">                                                      <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        modbus_address_field = arkime_field_define(<span class="string">&quot;modbus&quot;</span>, <span class="string">&quot;integer&quot;</span>,</span><br><span class="line">                                                       <span class="string">&quot;modbus.address&quot;</span>, <span class="string">&quot;Modbus Address&quot;</span>, <span class="string">&quot;modbus.address&quot;</span>,</span><br><span class="line">                                                       <span class="string">&quot;Modbus Address&quot;</span>,</span><br><span class="line">                                                       ARKIME_FIELD_TYPE_INT_HASH, <span class="number">0</span>,</span><br><span class="line">                                                       <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        modbus_quantity_field = arkime_field_define(<span class="string">&quot;modbus&quot;</span>, <span class="string">&quot;integer&quot;</span>,</span><br><span class="line">                                                        <span class="string">&quot;modbus.quantity&quot;</span>, <span class="string">&quot;Modbus Quantity&quot;</span>, <span class="string">&quot;modbus.quantity&quot;</span>,</span><br><span class="line">                                                        <span class="string">&quot;Modbus Quantity&quot;</span>,</span><br><span class="line">                                                        ARKIME_FIELD_TYPE_INT_HASH, <span class="number">0</span>,</span><br><span class="line">                                                        <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        modbus_data_field = arkime_field_define(<span class="string">&quot;modbus&quot;</span>, <span class="string">&quot;string&quot;</span>,</span><br><span class="line">                                                    <span class="string">&quot;modbus.data&quot;</span>, <span class="string">&quot;Modbus Data&quot;</span>, <span class="string">&quot;modbus.data&quot;</span>,</span><br><span class="line">                                                    <span class="string">&quot;Modbus Data&quot;</span>,</span><br><span class="line">                                                    ARKIME_FIELD_TYPE_STR_HASH, <span class="number">0</span>,</span><br><span class="line">                                                    <span class="literal">NULL</span>);</span><br><span class="line">        modbus_src_port_field = arkime_field_define(<span class="string">&quot;modbus&quot;</span>, <span class="string">&quot;integer&quot;</span>,</span><br><span class="line">                                                        <span class="string">&quot;modbus.srcPort&quot;</span>, <span class="string">&quot;Modbus Source Port&quot;</span>, <span class="string">&quot;modbus.srcPort&quot;</span>,</span><br><span class="line">                                                        <span class="string">&quot;Modbus Source Port&quot;</span>,</span><br><span class="line">                                                        ARKIME_FIELD_TYPE_INT_HASH, <span class="number">0</span>,</span><br><span class="line">                                                        <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        modbus_dest_port_field = arkime_field_define(<span class="string">&quot;modbus&quot;</span>, <span class="string">&quot;integer&quot;</span>,</span><br><span class="line">                                                     <span class="string">&quot;modbus.destPort&quot;</span>, <span class="string">&quot;Modbus Destination Port&quot;</span>, <span class="string">&quot;modbus.destPort&quot;</span>,</span><br><span class="line">                                                     <span class="string">&quot;Modbus Destination Port&quot;</span>,</span><br><span class="line">                                                     ARKIME_FIELD_TYPE_INT_HASH, <span class="number">0</span>,</span><br><span class="line">                                                     <span class="literal">NULL</span>);</span><br><span class="line">        modbus_exc_code_field = arkime_field_define(<span class="string">&quot;modbus&quot;</span>, <span class="string">&quot;integer&quot;</span>,</span><br><span class="line">                                                     <span class="string">&quot;modbus.exceptionCode&quot;</span>, <span class="string">&quot;Modbus Exception Code&quot;</span>, <span class="string">&quot;modbus.exceptionCode&quot;</span>,</span><br><span class="line">                                                     <span class="string">&quot;Modbus Exception Code&quot;</span>,</span><br><span class="line">                                                     ARKIME_FIELD_TYPE_INT_HASH, <span class="number">0</span>,</span><br><span class="line">                                                     <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 TCP 端口 502 的流量处理回调函数</span></span><br><span class="line">    arkime_parsers_classifier_register_port(<span class="string">&quot;modbus&quot;</span>, <span class="literal">NULL</span>, <span class="number">502</span>, ARKIME_PARSERS_PORT_TCP, (ArkimeClassifyFunc)modbus_process_tcp_payload);</span><br><span class="line"></span><br><span class="line">    modbus_log(<span class="string">&quot;modbus plugin initialized!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"><span class="comment">// 判断是否是 Modbus 数据 (更严格的检查) (保持不变)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">modbus_is_modbus</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *payload, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        modbus_log(<span class="string">&quot;modbus_is_modbus: len &lt; 7, returning FALSE&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查协议标识符, Modbus TCP 固定为 0</span></span><br><span class="line">    <span class="type">uint16_t</span> protocolId = ntohs(*(<span class="type">uint16_t</span>*)(payload + <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">if</span> (protocolId != <span class="number">0</span>) &#123;</span><br><span class="line">        modbus_log(<span class="string">&quot;modbus_is_modbus: protocolId != 0, returning FALSE&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查长度字段，确保其值与实际长度匹配 (减去前 6 个字节)</span></span><br><span class="line">    <span class="type">uint16_t</span> expectedLength = ntohs(*(<span class="type">uint16_t</span>*)(payload + <span class="number">4</span>));</span><br><span class="line">    <span class="keyword">if</span> (expectedLength != len - <span class="number">6</span>) &#123;</span><br><span class="line">        modbus_log(<span class="string">&quot;modbus_is_modbus: expectedLength != len - 6, returning FALSE&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modbus_log(<span class="string">&quot;modbus_is_modbus: is Modbus TCP&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"><span class="comment">// 处理 TCP 数据包</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">modbus_process_tcp_payload</span><span class="params">(ArkimeSession_t *session, <span class="type">const</span> <span class="type">uint8_t</span> *payload, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">char</span> sessionString[ARKIME_SESSIONID_LEN];</span><br><span class="line">    arkime_session_id_string(session-&gt;sessionId, sessionString);</span><br><span class="line">    modbus_log(<span class="string">&quot;modbus_process_tcp_payload called, len = %d, session id = %s&quot;</span>, len, sessionString);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        modbus_log(<span class="string">&quot;modbus_process_tcp_payload: len &lt;= 0, returning&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否是 Modbus 数据</span></span><br><span class="line">    <span class="keyword">if</span> (!modbus_is_modbus(payload, len)) &#123;</span><br><span class="line">        modbus_log(<span class="string">&quot;modbus_process_tcp_payload: not Modbus traffic, returning&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ModbusData *modbusData = ARKIME_TYPE_ALLOC0(ModbusData); <span class="comment">// 使用 Arkime 的内存分配函数</span></span><br><span class="line">    <span class="keyword">if</span> (!modbusData) &#123;</span><br><span class="line">        modbus_log(<span class="string">&quot;ERROR - 内存分配失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modbus_log(<span class="string">&quot;modbus_process_tcp_payload: Modbus data detected, parsing PDU&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 Modbus PDU</span></span><br><span class="line">    <span class="keyword">if</span> (modbus_parse_pdu(payload, len, modbusData) == <span class="number">0</span>) &#123;</span><br><span class="line">        modbus_log(<span class="string">&quot;modbus_process_tcp_payload: modbus_parse_pdu success, adding fields&quot;</span>);</span><br><span class="line">        <span class="comment">// 添加 Modbus 数据到 Arkime 字段</span></span><br><span class="line">        arkime_field_int_add(modbus_transaction_id_field, session, modbusData-&gt;transactionId);</span><br><span class="line">        modbus_log(<span class="string">&quot;modbus_process_tcp_payload: added transactionId = %u&quot;</span>, modbusData-&gt;transactionId);</span><br><span class="line"></span><br><span class="line">        arkime_field_int_add(modbus_function_code_field, session, modbusData-&gt;functionCode);</span><br><span class="line">        modbus_log(<span class="string">&quot;modbus_process_tcp_payload: added functionCode = %u&quot;</span>, modbusData-&gt;functionCode);</span><br><span class="line"></span><br><span class="line">        arkime_field_int_add(modbus_unit_id_field, session, modbusData-&gt;unitId);</span><br><span class="line">        modbus_log(<span class="string">&quot;modbus_process_tcp_payload: added unitId = %u&quot;</span>, modbusData-&gt;unitId);</span><br><span class="line"></span><br><span class="line">        arkime_field_int_add(modbus_address_field, session, modbusData-&gt;address);</span><br><span class="line">        modbus_log(<span class="string">&quot;modbus_process_tcp_payload: added address = %u&quot;</span>, modbusData-&gt;address);</span><br><span class="line"></span><br><span class="line">        arkime_field_int_add(modbus_quantity_field, session, modbusData-&gt;quantity);</span><br><span class="line">        modbus_log(<span class="string">&quot;modbus_process_tcp_payload: added quantity = %u&quot;</span>, modbusData-&gt;quantity);</span><br><span class="line"></span><br><span class="line">        arkime_field_int_add(modbus_src_port_field, session, session-&gt;port1);</span><br><span class="line">        modbus_log(<span class="string">&quot;modbus_process_tcp_payload: added srcPort = %u&quot;</span>, session-&gt;port1);</span><br><span class="line"></span><br><span class="line">        arkime_field_int_add(modbus_dest_port_field, session, session-&gt;port2);</span><br><span class="line">        modbus_log(<span class="string">&quot;modbus_process_tcp_payload: added destPort = %u&quot;</span>, session-&gt;port2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (modbusData-&gt;exceptionCode != <span class="number">0</span>)&#123;</span><br><span class="line">            arkime_field_int_add(modbus_exc_code_field, session,  modbusData-&gt;exceptionCode);</span><br><span class="line">            modbus_log(<span class="string">&quot;modbus_process_tcp_payload: added exceptionCode = %u&quot;</span>, modbusData-&gt;exceptionCode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 避免 NULL 指针解引用</span></span><br><span class="line">        <span class="keyword">if</span> (modbusData-&gt;description != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            arkime_field_string_add(modbus_description_field, session, modbusData-&gt;description, <span class="number">-1</span>, TRUE);</span><br><span class="line">            modbus_log(<span class="string">&quot;modbus_process_tcp_payload: added description = %s&quot;</span>,modbusData-&gt;description);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            modbus_log(<span class="string">&quot;modbus_process_tcp_payload: description is NULL&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modbus_free_data(modbusData);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        modbus_log(<span class="string">&quot;modbus_process_tcp_payload: modbus_parse_pdu failed&quot;</span>);</span><br><span class="line">        modbus_free_data(modbusData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"><span class="comment">// 解析 Modbus PDU (保持不变)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">modbus_parse_pdu</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *payload, <span class="type">int</span> len, ModbusData *modbusData)</span> &#123;</span><br><span class="line">    modbus_log(<span class="string">&quot;modbus_parse_pdu called, len = %d&quot;</span>, len);</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">8</span>) &#123;</span><br><span class="line">        modbus_log(<span class="string">&quot;modbus_parse_pdu: len &lt; 8, returning -1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 至少需要 8 个字节</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modbusData-&gt;transactionId = ntohs(*(<span class="type">uint16_t</span>*)(payload + <span class="number">0</span>));</span><br><span class="line">    modbus_log(<span class="string">&quot;modbus_parse_pdu: transactionId = %u&quot;</span>,modbusData-&gt;transactionId);</span><br><span class="line">    modbusData-&gt;protocolId    = ntohs(*(<span class="type">uint16_t</span>*)(payload + <span class="number">2</span>));</span><br><span class="line">    modbus_log(<span class="string">&quot;modbus_parse_pdu: protocolId = %u&quot;</span>,modbusData-&gt;protocolId);</span><br><span class="line">    modbusData-&gt;length        = ntohs(*(<span class="type">uint16_t</span>*)(payload + <span class="number">4</span>));</span><br><span class="line">    modbus_log(<span class="string">&quot;modbus_parse_pdu: length = %u&quot;</span>,modbusData-&gt;length);</span><br><span class="line">    modbusData-&gt;unitId        = payload[<span class="number">6</span>];</span><br><span class="line">    modbus_log(<span class="string">&quot;modbus_parse_pdu: unitId = %u&quot;</span>,modbusData-&gt;unitId);</span><br><span class="line">    modbusData-&gt;functionCode  = payload[<span class="number">7</span>];</span><br><span class="line">    modbus_log(<span class="string">&quot;modbus_parse_pdu: functionCode = %u&quot;</span>,modbusData-&gt;functionCode);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> *pdu = payload + <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> pdu_len = len - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    modbusData-&gt;description = <span class="string">&quot;Unknown&quot;</span>; <span class="comment">// 设置默认值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (modbusData-&gt;functionCode) &#123;</span><br><span class="line">        <span class="keyword">case</span> MODBUS_READ_COILS:         <span class="comment">// 0x01</span></span><br><span class="line">        <span class="keyword">case</span> MODBUS_READ_DISCRETE_INPUTS:  <span class="comment">// 0x02</span></span><br><span class="line">        <span class="keyword">case</span> MODBUS_READ_HOLDING_REGISTERS: <span class="comment">// 0x03</span></span><br><span class="line">        <span class="keyword">case</span> MODBUS_READ_INPUT_REGISTERS:   <span class="comment">// 0x04</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pdu_len &lt; <span class="number">4</span>) &#123;</span><br><span class="line">                modbus_log(<span class="string">&quot;modbus_parse_pdu: read function, pdu_len &lt; 4, returning -1&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            modbusData-&gt;address  = ntohs(*(<span class="type">uint16_t</span>*)(pdu + <span class="number">0</span>));</span><br><span class="line">            modbus_log(<span class="string">&quot;modbus_parse_pdu: address = %u&quot;</span>, modbusData-&gt;address);</span><br><span class="line">            modbusData-&gt;quantity = ntohs(*(<span class="type">uint16_t</span>*)(pdu + <span class="number">2</span>));</span><br><span class="line">            modbus_log(<span class="string">&quot;modbus_parse_pdu: quantity = %u&quot;</span>,modbusData-&gt;quantity);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (modbusData-&gt;functionCode) &#123;</span><br><span class="line">                <span class="keyword">case</span> MODBUS_READ_COILS:</span><br><span class="line">                    modbusData-&gt;description = <span class="string">&quot;Read Coils&quot;</span>;</span><br><span class="line">                    modbus_log(<span class="string">&quot;modbus_parse_pdu: description = Read Coils&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MODBUS_READ_DISCRETE_INPUTS:</span><br><span class="line">                    modbusData-&gt;description = <span class="string">&quot;Read Discrete Inputs&quot;</span>;</span><br><span class="line">                    modbus_log(<span class="string">&quot;modbus_parse_pdu: description = Read Discrete Inputs&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MODBUS_READ_HOLDING_REGISTERS:</span><br><span class="line">                    modbusData-&gt;description = <span class="string">&quot;Read Holding Registers&quot;</span>;</span><br><span class="line">                    modbus_log(<span class="string">&quot;modbus_parse_pdu: description = Read Holding Registers&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MODBUS_READ_INPUT_REGISTERS:</span><br><span class="line">                    modbusData-&gt;description = <span class="string">&quot;Read Input Registers&quot;</span>;</span><br><span class="line">                    modbus_log(<span class="string">&quot;modbus_parse_pdu: description = Read Input Registers&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> MODBUS_WRITE_SINGLE_COIL:    <span class="comment">// 0x05</span></span><br><span class="line">        <span class="keyword">case</span> MODBUS_WRITE_SINGLE_REGISTER: <span class="comment">// 0x06</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pdu_len &lt; <span class="number">4</span>) &#123;</span><br><span class="line">                modbus_log(<span class="string">&quot;modbus_parse_pdu: write single function, pdu_len &lt; 4, returning -1&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            modbusData-&gt;address = ntohs(*(<span class="type">uint16_t</span>*)(pdu + <span class="number">0</span>));</span><br><span class="line">            modbus_log(<span class="string">&quot;modbus_parse_pdu: address = %u&quot;</span>, modbusData-&gt;address);</span><br><span class="line">            modbusData-&gt;value   = ntohs(*(<span class="type">uint16_t</span>*)(pdu + <span class="number">2</span>));</span><br><span class="line">            modbus_log(<span class="string">&quot;modbus_parse_pdu: value = %u&quot;</span>,modbusData-&gt;value);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (modbusData-&gt;functionCode) &#123;</span><br><span class="line">                <span class="keyword">case</span> MODBUS_WRITE_SINGLE_COIL:</span><br><span class="line">                    modbusData-&gt;description = <span class="string">&quot;Write Single Coil&quot;</span>;</span><br><span class="line">                    modbus_log(<span class="string">&quot;modbus_parse_pdu: description = Write Single Coil&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MODBUS_WRITE_SINGLE_REGISTER:</span><br><span class="line">                    modbusData-&gt;description = <span class="string">&quot;Write Single Register&quot;</span>;</span><br><span class="line">                    modbus_log(<span class="string">&quot;modbus_parse_pdu: description = Write Single Register&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> MODBUS_WRITE_MULTIPLE_COILS:    <span class="comment">// 0x0F</span></span><br><span class="line">        <span class="keyword">case</span> MODBUS_WRITE_MULTIPLE_REGISTERS: <span class="comment">// 0x10</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pdu_len &lt; <span class="number">5</span>) &#123;</span><br><span class="line">                modbus_log(<span class="string">&quot;modbus_parse_pdu: write multiple function, pdu_len &lt; 5, returning -1&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            modbusData-&gt;address  = ntohs(*(<span class="type">uint16_t</span>*)(pdu + <span class="number">0</span>));</span><br><span class="line">            modbus_log(<span class="string">&quot;modbus_parse_pdu: address = %u&quot;</span>,modbusData-&gt;address);</span><br><span class="line">            modbusData-&gt;quantity = ntohs(*(<span class="type">uint16_t</span>*)(pdu + <span class="number">2</span>));</span><br><span class="line">            modbus_log(<span class="string">&quot;modbus_parse_pdu: quantity = %u&quot;</span>,modbusData-&gt;quantity);</span><br><span class="line">            modbusData-&gt;dataLength = pdu[<span class="number">4</span>];</span><br><span class="line">            modbus_log(<span class="string">&quot;modbus_parse_pdu: dataLength = %u&quot;</span>,modbusData-&gt;dataLength);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pdu_len &lt; <span class="number">5</span> + modbusData-&gt;dataLength) &#123;</span><br><span class="line">                modbus_log(<span class="string">&quot;modbus_parse_pdu: write multiple function, pdu_len &lt; 5 + dataLength, returning -1&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            modbusData-&gt;data = ARKIME_SIZE_ALLOC0(modbus_data, modbusData-&gt;dataLength); <span class="comment">// 使用 Arkime 的内存分配函数</span></span><br><span class="line">            <span class="keyword">if</span> (!modbusData-&gt;data) &#123;</span><br><span class="line">                modbus_log(<span class="string">&quot;ERROR - 内存分配失败&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memcpy</span>(modbusData-&gt;data, pdu + <span class="number">5</span>, modbusData-&gt;dataLength);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (modbusData-&gt;functionCode) &#123;</span><br><span class="line">                <span class="keyword">case</span> MODBUS_WRITE_MULTIPLE_COILS:</span><br><span class="line">                    modbusData-&gt;description = <span class="string">&quot;Write Multiple Coils&quot;</span>;</span><br><span class="line">                    modbus_log(<span class="string">&quot;modbus_parse_pdu: description = Write Multiple Coils&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MODBUS_WRITE_MULTIPLE_REGISTERS:</span><br><span class="line">                    modbusData-&gt;description = <span class="string">&quot;Write Multiple Registers&quot;</span>;</span><br><span class="line">                    modbus_log(<span class="string">&quot;modbus_parse_pdu: description = Write Multiple Registers&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x80</span> ... <span class="number">0xFF</span>: <span class="comment">// Exception Response</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pdu_len &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                modbus_log(<span class="string">&quot;modbus_parse_pdu: exception response, pdu_len &lt; 1, returning -1&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            modbusData-&gt;exceptionCode = pdu[<span class="number">0</span>];</span><br><span class="line">            modbus_log(<span class="string">&quot;modbus_parse_pdu: exceptionCode = %u&quot;</span>,modbusData-&gt;exceptionCode);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (modbusData-&gt;exceptionCode) &#123;</span><br><span class="line">                <span class="keyword">case</span> MODBUS_EXC_ILLEGAL_FUNCTION:</span><br><span class="line">                    modbusData-&gt;description = <span class="string">&quot;Exception: Illegal Function&quot;</span>;</span><br><span class="line">                    modbus_log(<span class="string">&quot;modbus_parse_pdu: description = Exception: Illegal Function&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MODBUS_EXC_ILLEGAL_DATA_ADDRESS:</span><br><span class="line">                    modbusData-&gt;description = <span class="string">&quot;Exception: Illegal Data Address&quot;</span>;</span><br><span class="line">                    modbus_log(<span class="string">&quot;modbus_parse_pdu: description = Exception: Illegal Data Address&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MODBUS_EXC_ILLEGAL_DATA_VALUE:</span><br><span class="line">                    modbusData-&gt;description = <span class="string">&quot;Exception: Illegal Data Value&quot;</span>;</span><br><span class="line">                    modbus_log(<span class="string">&quot;modbus_parse_pdu: description = Exception: Illegal Data Value&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MODBUS_EXC_SLAVE_DEVICE_FAILURE:</span><br><span class="line">                    modbusData-&gt;description = <span class="string">&quot;Exception: Slave Device Failure&quot;</span>;</span><br><span class="line">                    modbus_log(<span class="string">&quot;modbus_parse_pdu: description = Exception: Slave Device Failure&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MODBUS_EXC_ACKNOWLEDGE:</span><br><span class="line">                    modbusData-&gt;description = <span class="string">&quot;Exception: Acknowledge&quot;</span>;</span><br><span class="line">                    modbus_log(<span class="string">&quot;modbus_parse_pdu: description = Exception: Acknowledge&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MODBUS_EXC_SLAVE_DEVICE_BUSY:</span><br><span class="line">                    modbusData-&gt;description = <span class="string">&quot;Exception: Slave Device Busy&quot;</span>;</span><br><span class="line">                    modbus_log(<span class="string">&quot;modbus_parse_pdu: description = Exception: Slave Device Busy&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MODBUS_EXC_NEGATIVE_ACKNOWLEDGE:</span><br><span class="line">                    modbusData-&gt;description = <span class="string">&quot;Exception: Negative Acknowledge&quot;</span>;</span><br><span class="line">                    modbus_log(<span class="string">&quot;modbus_parse_pdu: description = Exception: Negative Acknowledge&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MODBUS_EXC_MEMORY_PARITY_ERROR:</span><br><span class="line">                    modbusData-&gt;description = <span class="string">&quot;Exception: Memory Parity Error&quot;</span>;</span><br><span class="line">                    modbus_log(<span class="string">&quot;modbus_parse_pdu: description = Exception: Memory Parity Error&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    modbusData-&gt;description = <span class="string">&quot;Exception: Unknown Error&quot;</span>;</span><br><span class="line">                    modbus_log(<span class="string">&quot;modbus_parse_pdu: description = Exception: Unknown Error&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            modbus_log(<span class="string">&quot;modbus_parse_pdu: unknown function code, returning -1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"><span class="comment">// 释放 ModbusData 结构体内存 (保持不变)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">modbus_free_data</span><span class="params">(ModbusData *data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data-&gt;data) &#123;</span><br><span class="line">            ARKIME_SIZE_FREE(modbus_data, data-&gt;data); <span class="comment">// 使用 Arkime 的内存释放函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        ARKIME_TYPE_FREE(ModbusData, data); <span class="comment">// 使用 Arkime 的内存释放函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"><span class="comment">// 供 Arkime 加载插件的函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UNIT_TEST</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">arkime_plugin_load</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="meta">#<span class="keyword">ifdef</span> __linux__</span></span><br><span class="line">       <span class="comment">// LOG(&quot;arkime_plugin_load() called, plugin path: %s&quot;, plugin_path);</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    modbus_log(<span class="string">&quot;arkime_plugin_load() called&quot;</span>);</span><br><span class="line">    arkime_plugin_init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>CMakeLists.txt</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(modbus_plugin)</span><br><span class="line"></span><br><span class="line"># 设置编译选项</span><br><span class="line">set(CMAKE_C_STANDARD 99)</span><br><span class="line">set(CMAKE_C_FLAGS &quot;-Wall -fPIC&quot;)</span><br><span class="line"></span><br><span class="line"># Arkime 安装目录（根据你的实际情况修改）</span><br><span class="line">set(ARKIME_PREFIX /opt/arkime)</span><br><span class="line"></span><br><span class="line"># libmodbus 安装目录（指向你手动编译安装的 Libmodbus 目录）</span><br><span class="line">set(LIBMODBUS_PREFIX /opt/libmodbus)</span><br><span class="line"></span><br><span class="line"># GLib 安装目录</span><br><span class="line"># 方法1： 直接指定glibconfig.h所在的目录的上一级</span><br><span class="line">#set(GLIB_INCLUDE_DIR /usr/lib/glib-2.0/include) # 假设 glibconfig.h 在 /usr/lib/glib-2.0/include 目录下</span><br><span class="line"></span><br><span class="line"># 方法2： 更精确地指定所有需要的GLib头文件目录，确保万无一失</span><br><span class="line">include_directories(</span><br><span class="line">    /usr/include/glib-2.0</span><br><span class="line">    /usr/lib/x86_64-linux-gnu/glib-2.0/include</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># Jansson 安装目录 (根据你的实际情况修改, 如果需要)</span><br><span class="line"># 可以在 /usr/include 或 /usr/local/include 中尝试</span><br><span class="line"># 如果找不到 jansson.h , 先安装 libjansson-dev</span><br><span class="line"># sudo apt-get install libjansson-dev</span><br><span class="line">set(JANSSON_INCLUDE_DIR /usr/include)</span><br><span class="line"></span><br><span class="line"># 包含头文件</span><br><span class="line">include_directories(</span><br><span class="line">    $&#123;ARKIME_PREFIX&#125;/include</span><br><span class="line">    $&#123;LIBMODBUS_PREFIX&#125;/include</span><br><span class="line">    #$&#123;GLIB_INCLUDE_DIR&#125;   # 注释掉，使用更精确的include目录</span><br><span class="line">    $&#123;JANSSON_INCLUDE_DIR&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 源文件</span><br><span class="line">set(SOURCE_FILES</span><br><span class="line">    src/modbus_plugin.c</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 创建共享库</span><br><span class="line">add_library(modbus_plugin SHARED $&#123;SOURCE_FILES&#125;)</span><br><span class="line"></span><br><span class="line"># 设置链接选项，强制静态链接 libmodbus</span><br><span class="line">target_link_libraries(modbus_plugin</span><br><span class="line">    -L$&#123;LIBMODBUS_PREFIX&#125;/lib -lmodbus -lm -lglib-2.0 -ljansson</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 设置安装目录和目标</span><br><span class="line">install(TARGETS modbus_plugin DESTINATION /opt/arkime/plugins)</span><br></pre></td></tr></table></figure>





<p>这段代码是一个 Arkime（Moloch）的插件，用于解析和提取 Modbus TCP 协议的数据。下面是对代码的详细中文解析：</p>
<p><strong>1. 包含头文件和定义:</strong></p>
<p>- </p>
<ul>
<li>#include &lt;stdio.h&gt;：标准输入输出库。</li>
<li>#include &lt;string.h&gt;：字符串操作库。</li>
<li>#include &lt;stdlib.h&gt;：标准库，提供内存分配等函数。</li>
<li>#include &lt;stdint.h&gt;：提供固定大小整数类型。</li>
<li>#include &lt;arpa&#x2F;inet.h&gt;：提供网络字节序转换函数（如 ntohs）。</li>
<li>#include &lt;time.h&gt;：时间相关函数。</li>
<li>#include &lt;glib.h&gt;：GLib 库，提供了一些实用工具（虽然代码中没有直接使用）。</li>
<li>#include &lt;dlfcn.h&gt;：动态链接库函数（代码中没有直接使用）。</li>
<li>#include “arkime.h”：Arkime 的头文件，包含了插件开发所需的 API。</li>
<li>#define ARKIME_API_VERSION 542：定义 Arkime API 版本。 如果你的 Arkime 版本与此不匹配，需要更改。</li>
<li>#define ARKIME_SESSIONID_LEN 40：定义会话 ID 的长度。</li>
<li>#define MODBUS_…：定义 Modbus 功能码和异常码的常量。 这些是 Modbus 协议规范中定义的。</li>
</ul>
<p><strong>2. 数据结构:</strong></p>
<h2 id="ModbusData：定义了一个结构体来存储解析后的-Modbus-数据。"><a href="#ModbusData：定义了一个结构体来存储解析后的-Modbus-数据。" class="headerlink" title="-- ModbusData：定义了一个结构体来存储解析后的 Modbus 数据。"></a>-<br>- ModbusData：定义了一个结构体来存储解析后的 Modbus 数据。</h2><ul>
<li>transactionId：事务标识符。</li>
<li>protocolId：协议标识符（Modbus TCP 通常为 0）。</li>
<li>length：PDU 长度。</li>
<li>unitId：单元标识符。</li>
<li>functionCode：功能码。</li>
<li>address：数据地址。</li>
<li>quantity：数量（例如读取的寄存器数量）。</li>
<li>value：单个寄存器或线圈的值。</li>
<li>data：指向数据的指针（用于写入或读取多个寄存器&#x2F;线圈）。</li>
<li>dataLength：数据的长度。</li>
<li>exceptionCode：异常码。</li>
<li>description：功能的文本描述。</li>
</ul>
<p><strong>3. 全局变量:</strong></p>
<p>- </p>
<ul>
<li>modbus_…_field：一系列整数变量，用于存储 Arkime 字段的 ID。 这些 ID 是在插件初始化时通过 arkime_field_define 函数获取的。 这些变量用于将解析出的 Modbus 数据添加到 Arkime 的会话记录中。</li>
</ul>
<p><strong>4. 函数声明:</strong></p>
<p>- </p>
<ul>
<li>modbus_free_data(ModbusData *data)：释放 ModbusData 结构体占用的内存。</li>
<li>modbus_process_tcp_payload(ArkimeSession_t *session, const uint8_t *payload, int len)：处理 TCP 数据包的主要函数。</li>
<li>modbus_parse_pdu(const uint8_t *payload, int len, ModbusData *modbusData, ArkimeSession_t *session)：解析 Modbus PDU（协议数据单元）。</li>
</ul>
<p><strong>5. 自定义日志函数 modbus_log:</strong></p>
<p>- </p>
<ul>
<li>这个函数类似于 printf，但它会在输出的消息前加上时间戳和 [modbus_plugin] 标签，并将输出写入到标准错误流 (stderr)。 这对于调试非常有用。使用了线程安全的 localtime_r 函数。</li>
</ul>
<p><strong>6. arkime_plugin_init() - 插件初始化:</strong></p>
<h2 id="这是插件的入口点，当-Arkime-加载插件时会被调用。-arkime-plugins-register-internal-…-向-Arkime-注册插件。-TRUE-表示此插件会修改数据。-arkime-field-define-…-：定义-Arkime-字段。-每个-arkime-field-define-调用都为-Modbus-协议的一个属性创建一个新的字段。-这些字段将在-Arkime-的-Web-界面中可见。"><a href="#这是插件的入口点，当-Arkime-加载插件时会被调用。-arkime-plugins-register-internal-…-向-Arkime-注册插件。-TRUE-表示此插件会修改数据。-arkime-field-define-…-：定义-Arkime-字段。-每个-arkime-field-define-调用都为-Modbus-协议的一个属性创建一个新的字段。-这些字段将在-Arkime-的-Web-界面中可见。" class="headerlink" title="-- 这是插件的入口点，当 Arkime 加载插件时会被调用。- arkime_plugins_register_internal(…): 向 Arkime 注册插件。 TRUE 表示此插件会修改数据。- arkime_field_define(…)：定义 Arkime 字段。 每个 arkime_field_define 调用都为 Modbus 协议的一个属性创建一个新的字段。 这些字段将在 Arkime 的 Web 界面中可见。"></a>-<br>- 这是插件的入口点，当 Arkime 加载插件时会被调用。<br>- arkime_plugins_register_internal(…): 向 Arkime 注册插件。 TRUE 表示此插件会修改数据。<br>- arkime_field_define(…)：定义 Arkime 字段。 每个 arkime_field_define 调用都为 Modbus 协议的一个属性创建一个新的字段。 这些字段将在 Arkime 的 Web 界面中可见。</h2><ul>
<li>第一个参数是插件名称 (“modbus”)。</li>
<li>第二个参数是字段类型 (“integer” 或 “string”)。</li>
<li>第三个参数是字段的内部名称 (例如 “modbus.transactionId”)。</li>
<li>第四个参数是字段的简短描述（在 Web 界面中显示）。</li>
<li>第五个参数是字段的长名称。</li>
<li>第六个参数是字段的描述。</li>
<li>第七个参数指定了字段的存储类型和选项.</li>
<li>arkime_parsers_classifier_register_port(…)：注册一个分类器函数。 这告诉 Arkime，当它看到目标端口为 502（Modbus 的标准端口）的 TCP 流量时，应该调用 modbus_process_tcp_payload 函数来处理数据。</li>
</ul>
<p><strong>7. modbus_is_modbus() - 检查是否为 Modbus TCP 数据:</strong></p>
<h2 id="检查数据包是否符合-Modbus-TCP-格式的基本要求："><a href="#检查数据包是否符合-Modbus-TCP-格式的基本要求：" class="headerlink" title="-- 检查数据包是否符合 Modbus TCP 格式的基本要求："></a>-<br>- 检查数据包是否符合 Modbus TCP 格式的基本要求：</h2><ul>
<li>长度至少为 7 字节。</li>
<li>协议标识符 (protocolId) 必须为 0。</li>
<li>长度字段必须与实际数据长度匹配。</li>
</ul>
<p><strong>8. modbus_process_tcp_payload() - 处理 TCP 数据包:</strong></p>
<h2 id="这是处理-Modbus-流量的核心函数。-首先，它检查数据包长度和是否为-Modbus-流量。-然后，它分配一个-ModbusData-结构体来存储解析后的数据。-调用-modbus-parse-pdu-函数来解析-Modbus-应用数据单元-PDU-。-如果解析成功，它使用-arkime-field-int-add-和-arkime-field-string-add-函数将解析出的-Modbus-数据添加到-Arkime-会话的相应字段中。"><a href="#这是处理-Modbus-流量的核心函数。-首先，它检查数据包长度和是否为-Modbus-流量。-然后，它分配一个-ModbusData-结构体来存储解析后的数据。-调用-modbus-parse-pdu-函数来解析-Modbus-应用数据单元-PDU-。-如果解析成功，它使用-arkime-field-int-add-和-arkime-field-string-add-函数将解析出的-Modbus-数据添加到-Arkime-会话的相应字段中。" class="headerlink" title="-- 这是处理 Modbus 流量的核心函数。- 首先，它检查数据包长度和是否为 Modbus 流量。- 然后，它分配一个 ModbusData 结构体来存储解析后的数据。- 调用 modbus_parse_pdu() 函数来解析 Modbus 应用数据单元 (PDU)。- 如果解析成功，它使用 arkime_field_int_add() 和 arkime_field_string_add() 函数将解析出的 Modbus 数据添加到 Arkime 会话的相应字段中。"></a>-<br>- 这是处理 Modbus 流量的核心函数。<br>- 首先，它检查数据包长度和是否为 Modbus 流量。<br>- 然后，它分配一个 ModbusData 结构体来存储解析后的数据。<br>- 调用 modbus_parse_pdu() 函数来解析 Modbus 应用数据单元 (PDU)。<br>- 如果解析成功，它使用 arkime_field_int_add() 和 arkime_field_string_add() 函数将解析出的 Modbus 数据添加到 Arkime 会话的相应字段中。</h2><ul>
<li>会话ID, 源&#x2F;目的端口也都被添加到会话记录中。</li>
<li>使用 arkime_sprint_hex_string 函数将二进制数据转换为十六进制字符串, 方便显示。</li>
<li>最后，它调用 modbus_free_data() 函数来释放 ModbusData 结构体占用的内存。</li>
</ul>
<p><strong>9. modbus_parse_pdu() - 解析 Modbus PDU:</strong></p>
<h2 id="这个函数负责解析-Modbus-应用数据单元-PDU-。-它首先提取-Modbus-消息头中的字段（事务-ID、协议-ID、长度、单元-ID、功能码）。-然后，它根据功能码来解析-PDU-的其余部分："><a href="#这个函数负责解析-Modbus-应用数据单元-PDU-。-它首先提取-Modbus-消息头中的字段（事务-ID、协议-ID、长度、单元-ID、功能码）。-然后，它根据功能码来解析-PDU-的其余部分：" class="headerlink" title="-- 这个函数负责解析 Modbus 应用数据单元 (PDU)。- 它首先提取 Modbus 消息头中的字段（事务 ID、协议 ID、长度、单元 ID、功能码）。- 然后，它根据功能码来解析 PDU 的其余部分："></a>-<br>- 这个函数负责解析 Modbus 应用数据单元 (PDU)。<br>- 它首先提取 Modbus 消息头中的字段（事务 ID、协议 ID、长度、单元 ID、功能码）。<br>- 然后，它根据功能码来解析 PDU 的其余部分：</h2><ul>
<li>对于读取类功能（0x01-0x04），它提取地址和数量。</li>
<li>对于单次写入类功能（0x05-0x06），它提取地址和值。</li>
<li>对于多次写入类功能（0x0F-0x10），它提取地址、数量、数据长度和数据。</li>
<li>对于异常响应（0x80-0xFF），它提取异常码。</li>
<li>为每种功能码和异常代码设置了描述性的字符串。</li>
<li>如果解析过程中出现任何错误（例如数据包长度不足），它会返回 -1。</li>
<li>它使用 ARKIME_SIZE_ALLOC0 和ARKIME_SIZE_FREE 确保正确地分配和释放数据缓冲区。</li>
</ul>
<p><strong>10. modbus_free_data() - 释放内存:</strong></p>
<p>- </p>
<ul>
<li>释放 ModbusData 结构体占用的内存，包括动态分配的 data 缓冲区。</li>
</ul>
<p><strong>11. arkime_plugin_load() - 加载插件 (仅在非单元测试时):</strong></p>
<p>- </p>
<ul>
<li>这个函数在插件被 Arkime 动态加载时调用。</li>
<li>它通常只是简单地调用 arkime_plugin_init()。</li>
<li>#ifndef UNIT_TEST 预处理指令确保这段代码只在非单元测试环境下编译。</li>
</ul>
<p><strong>关键改进和更正:</strong></p>
<p>- </p>
<ul>
<li><strong>Arkime API 使用:</strong> 使用了 Arkime 的内存分配函数 (ARKIME_TYPE_ALLOC0, ARKIME_SIZE_ALLOC0, ARKIME_TYPE_FREE, ARKIME_SIZE_FREE)，以及其他 Arkime API 函数，确保与 Arkime 框架的兼容性。</li>
<li><strong>内存管理:</strong> 正确地分配和释放了 ModbusData 结构体以及其中的 data 成员。</li>
<li><strong>错误处理:</strong> 在 modbus_parse_pdu 函数中添加了更详细的错误检查，并在内存分配失败时进行了处理。在 modbus_process_tcp_payload 函数中增加了内存分配失败的判断。</li>
<li><strong>日志记录:</strong> 添加了 modbus_log 函数，用于记录调试信息和错误信息，并包含时间戳。</li>
<li><strong>字段添加:</strong> 在 modbus_process_tcp_payload 函数中，将解析出的 Modbus 数据正确地添加到了 Arkime 会话的字段中，包括源端口和目的端口。 对于字符串类型的字段，使用了 arkime_field_string_add 的安全版本，处理了可能为 NULL 的字符串, 使用-1 让Arkime自动计算字符串的长度。</li>
<li><strong>PDU 解析:</strong> 更完整地解析了 Modbus PDU，包括对所有标准功能码和异常码的处理，并根据功能码设置了相应的描述。</li>
<li><strong>Modbus 数据检查:</strong> modbus_is_modbus 函数现在进行了更严格的检查，确保数据包符合 Modbus TCP 格式。</li>
<li><strong>会话ID打印:</strong> 在 modbus_process_tcp_payload函数的开头打印了会话ID， 方便调试。</li>
<li><strong>异常处理:</strong> 对所有异常响应进行了处理，并设置了相应的描述。</li>
<li><strong>默认值:</strong> 在modbus_parse_pdu函数的开头部分，对address、quantity 和exceptionCode 设置了默认值(0xFFFF, 0xFFFF, 0x00)。这可以避免在某些情况下，由于这些字段未被赋值而导致的显示问题。</li>
<li><strong>线程安全的时间函数:</strong> 使用线程安全的 localtime_r 函数代替 localtime 函数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arkime.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dave.h&quot;</span>  <span class="comment">// libnodave 的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Elasticsearch 索引名称</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ES_INDEX <span class="string">&quot;s7-data&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插件配置结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *es_host;</span><br><span class="line">    <span class="type">int</span>   es_port;</span><br><span class="line">&#125; S7Config_t;</span><br><span class="line"></span><br><span class="line">S7Config_t s7Config;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Elasticsearch 写入函数 (简化版本，实际需要处理错误)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_to_elasticsearch</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *json_data)</span> &#123;</span><br><span class="line">    <span class="type">char</span> url[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(url, <span class="keyword">sizeof</span>(url), <span class="string">&quot;http://%s:%d/%s/_doc&quot;</span>, s7Config.es_host, s7Config.es_port, ES_INDEX);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 libcurl 或其他 HTTP 库发送 POST 请求到 Elasticsearch</span></span><br><span class="line">    <span class="comment">// 这里只是一个占位符，你需要实现实际的 HTTP 请求</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sending to ES: %s\n&quot;</span>, json_data);  <span class="comment">// 替换为实际的 HTTP 发送代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// S7 数据解析函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">parse_s7_data</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *data, <span class="type">int</span> len, ArkimeSession_t *session)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 libnodave 解析 S7 数据包</span></span><br><span class="line">    <span class="comment">//  注意：这里只是一个框架，你需要根据 S7 协议规范，编写实际的解析代码。</span></span><br><span class="line">    <span class="comment">//       S7 协议解析比较复杂，需要深入理解 S7 的 PDU 结构。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例：假设我们提取了变量地址和值</span></span><br><span class="line">    <span class="type">char</span> variable_address[<span class="number">32</span>] = <span class="string">&quot;DB1.DBW0&quot;</span>;</span><br><span class="line">    <span class="type">int</span>  variable_value = <span class="number">12345</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建 JSON 数据</span></span><br><span class="line">    <span class="type">char</span> json_data[<span class="number">512</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(json_data, <span class="keyword">sizeof</span>(json_data),</span><br><span class="line">             <span class="string">&quot;&#123;&quot;</span></span><br><span class="line">             <span class="string">&quot;\&quot;timestamp\&quot;: \&quot;%lld\&quot;,&quot;</span></span><br><span class="line">             <span class="string">&quot;\&quot;srcIp\&quot;: \&quot;%s\&quot;,&quot;</span></span><br><span class="line">             <span class="string">&quot;\&quot;dstIp\&quot;: \&quot;%s\&quot;,&quot;</span></span><br><span class="line">             <span class="string">&quot;\&quot;variableAddress\&quot;: \&quot;%s\&quot;,&quot;</span></span><br><span class="line">             <span class="string">&quot;\&quot;variableValue\&quot;: %d&quot;</span></span><br><span class="line">             <span class="string">&quot;&#125;&quot;</span>,</span><br><span class="line">             (<span class="type">long</span> <span class="type">long</span>)session-&gt;firstPacket,</span><br><span class="line">             arkime_session_string(session, <span class="string">&quot;srcIp&quot;</span>),</span><br><span class="line">             arkime_session_string(session, <span class="string">&quot;dstIp&quot;</span>),</span><br><span class="line">             variable_address,</span><br><span class="line">             variable_value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据写入 Elasticsearch</span></span><br><span class="line">    write_to_elasticsearch(json_data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加到 Arkime 会话信息 (可选)</span></span><br><span class="line">    <span class="comment">// arkime_session_add_tag(session, &quot;s7&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据包处理函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">s7_plugin_process</span><span class="params">(ArkimeSession_t *session, ArkimePacket_t *packet)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否为 S7 流量 (例如，基于端口号或协议特征)</span></span><br><span class="line">    <span class="keyword">if</span> (packet-&gt;dstPort == <span class="number">102</span>) &#123; <span class="comment">// 假设 S7 流量使用 102 端口</span></span><br><span class="line">        <span class="comment">// 调用 S7 数据解析函数</span></span><br><span class="line">        parse_s7_data(packet-&gt;payload, packet-&gt;payloadLen, session);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 表示已处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 表示未处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插件初始化函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">s7_plugin_init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 读取配置文件 (例如，elasticsearch 地址)</span></span><br><span class="line">    g_arkime_config_bool(<span class="literal">NULL</span>, <span class="string">&quot;s7:enabled&quot;</span>, TRUE);</span><br><span class="line">    s7Config.es_host = g_arkime_config_string(<span class="literal">NULL</span>, <span class="string">&quot;s7:esHost&quot;</span>, <span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">    s7Config.es_port = g_arkime_config_int(<span class="literal">NULL</span>, <span class="string">&quot;s7:esPort&quot;</span>, <span class="number">9200</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册数据包处理函数</span></span><br><span class="line">    arkime_plugins_register(<span class="string">&quot;s7&quot;</span>, TRUE, s7_plugin_process, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    LOG(<span class="string">&quot;S7 Plugin initialized!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>主要思路</strong></p>
<p>1.<br>2. <strong>协议理解：</strong> Ethernet&#x2F;IP 是基于 CIP 协议的，它在 TCP&#x2F;UDP 之上封装了 CIP 协议。你需要理解 CIP 的连接建立、对象模型、服务等概念。<br>3. <strong>端口识别：</strong> Ethernet&#x2F;IP 通常使用 44818 端口。<br>4. <strong>数据结构：</strong> 定义一个合适的数据结构来存储解析出的 CIP 数据。<br>5. <strong>解析流程：</strong> 实现 CIP 协议的解析流程，包括连接建立、请求&#x2F;响应处理等。<br>6. <strong>Arkime 集成：</strong> 将解析出的数据添加到 Arkime 字段中。</p>
<p><strong>ethernetip_plugin.c</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &lt;glib.h&gt;</span><br><span class="line">#include &lt;dlfcn.h&gt;</span><br><span class="line">#include &quot;arkime.h&quot;</span><br><span class="line"></span><br><span class="line">extern ArkimeConfig_t config;</span><br><span class="line"></span><br><span class="line">#define ARKIME_API_VERSION 542</span><br><span class="line">#define ARKIME_SESSIONID_LEN 40</span><br><span class="line"></span><br><span class="line">// Ethernet/IP 端口</span><br><span class="line">#define ETHERNETIP_PORT 44818</span><br><span class="line"></span><br><span class="line">// CIP Service Codes (部分示例)</span><br><span class="line">#define CIP_SVC_GET_ATTRIB_SINGLE  0x0E</span><br><span class="line">#define CIP_SVC_SET_ATTRIB_SINGLE  0x10</span><br><span class="line">#define CIP_SVC_UNCONNECTED_SEND   0x52</span><br><span class="line">#define CIP_SVC_FORWARD_OPEN       0x54</span><br><span class="line">#define CIP_SVC_FORWARD_CLOSE      0x4E</span><br><span class="line"></span><br><span class="line">// 定义 Ethernet/IP 数据结构 (简化)</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    uint32_t  encap_command;    // Encap Command</span><br><span class="line">    uint32_t  encap_length;     // Encap Length</span><br><span class="line">    uint32_t  encap_session;    // Encap Session Handle</span><br><span class="line">    uint32_t  encap_status;     // Encap Status</span><br><span class="line">    uint64_t  encap_sender_context; // Encap Sender Context (8 bytes)</span><br><span class="line">    uint32_t  encap_options;    // Encap Options</span><br><span class="line">    uint8_t   *cip_data;          // CIP Data</span><br><span class="line">    uint32_t  cip_length;       // CIP Data Length</span><br><span class="line">    uint8_t   cip_service;      // CIP Service Code (来自 CIP 数据)</span><br><span class="line">    char    *description;      // 描述信息</span><br><span class="line">&#125; EthernetIPData;</span><br><span class="line"></span><br><span class="line">// 全局变量，存储字段位置</span><br><span class="line">static int ethernetip_command_field;</span><br><span class="line">static int ethernetip_session_field;</span><br><span class="line">static int ethernetip_status_field;</span><br><span class="line">static int ethernetip_service_field;</span><br><span class="line">static int ethernetip_description_field;</span><br><span class="line">static int ethernetip_src_port_field;</span><br><span class="line">static int ethernetip_dest_port_field;</span><br><span class="line">static int ethernetip_data_field;</span><br><span class="line"></span><br><span class="line">// 函数声明</span><br><span class="line">void ethernetip_free_data(EthernetIPData *data);</span><br><span class="line">void ethernetip_process_tcp_payload(ArkimeSession_t *session, const uint8_t *payload, int len);</span><br><span class="line">int ethernetip_parse_encap_header(const uint8_t *payload, int len, EthernetIPData *eipData);</span><br><span class="line">int ethernetip_parse_cip_data(const uint8_t *cip_data, int cip_len, EthernetIPData *eipData);</span><br><span class="line"></span><br><span class="line">// 自定义错误打印函数，带时间戳</span><br><span class="line">void ethernetip_log(const char *format, ...) &#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, format);</span><br><span class="line"></span><br><span class="line">    time_t timer;</span><br><span class="line">    char buffer[26];</span><br><span class="line">    struct tm tm_info; // 声明 struct tm 变量</span><br><span class="line">    time(&amp;timer);</span><br><span class="line"></span><br><span class="line">    localtime_r(&amp;timer, &amp;tm_info); // 使用 localtime_r 函数</span><br><span class="line"></span><br><span class="line">    strftime(buffer, 26, &quot;%Y-%m-%d %H:%M:%S&quot;, &amp;tm_info); // 传递指针</span><br><span class="line"></span><br><span class="line">    fprintf(stderr, &quot;%s [ethernetip_plugin] &quot;, buffer);</span><br><span class="line">    vfprintf(stderr, format, args);</span><br><span class="line">    fprintf(stderr, &quot;\n&quot;);</span><br><span class="line">    va_end(args);</span><br><span class="line">    fflush(stderr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/******************************************************************************/</span><br><span class="line">// 插件初始化函数</span><br><span class="line">void arkime_plugin_init() &#123;</span><br><span class="line">    ethernetip_log(&quot;arkime_plugin_init() called&quot;);</span><br><span class="line"></span><br><span class="line">    // 注册插件</span><br><span class="line">    int rc = arkime_plugins_register_internal(&quot;ethernetip&quot;, TRUE, sizeof(ArkimeSession_t), ARKIME_API_VERSION);</span><br><span class="line">    if (rc == -1) &#123;</span><br><span class="line">        fprintf(stderr, &quot;ERROR: Couldn&#x27;t register plugin\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 定义 Arkime 字段</span><br><span class="line">    ethernetip_command_field = arkime_field_define(&quot;ethernetip&quot;, &quot;integer&quot;,</span><br><span class="line">                                                     &quot;ethernetip.command&quot;, &quot;EthernetIP Command&quot;, &quot;ethernetip.command&quot;,</span><br><span class="line">                                                     &quot;EthernetIP Command&quot;,</span><br><span class="line">                                                     ARKIME_FIELD_TYPE_INT_HASH, 0,</span><br><span class="line">                                                     NULL);</span><br><span class="line"></span><br><span class="line">    ethernetip_session_field = arkime_field_define(&quot;ethernetip&quot;, &quot;integer&quot;,</span><br><span class="line">                                                   &quot;ethernetip.session&quot;, &quot;EthernetIP Session&quot;, &quot;ethernetip.session&quot;,</span><br><span class="line">                                                   &quot;EthernetIP Session&quot;,</span><br><span class="line">                                                   ARKIME_FIELD_TYPE_INT_HASH, 0,</span><br><span class="line">                                                   NULL);</span><br><span class="line"></span><br><span class="line">    ethernetip_status_field = arkime_field_define(&quot;ethernetip&quot;, &quot;integer&quot;,</span><br><span class="line">                                                  &quot;ethernetip.status&quot;, &quot;EthernetIP Status&quot;, &quot;ethernetip.status&quot;,</span><br><span class="line">                                                  &quot;EthernetIP Status&quot;,</span><br><span class="line">                                                  ARKIME_FIELD_TYPE_INT_HASH, 0,</span><br><span class="line">                                                  NULL);</span><br><span class="line"></span><br><span class="line">    ethernetip_service_field = arkime_field_define(&quot;ethernetip&quot;, &quot;integer&quot;,</span><br><span class="line">                                                      &quot;ethernetip.service&quot;, &quot;EthernetIP Service&quot;, &quot;ethernetip.service&quot;,</span><br><span class="line">                                                      &quot;EthernetIP Service&quot;,</span><br><span class="line">                                                      ARKIME_FIELD_TYPE_INT_HASH, 0,</span><br><span class="line">                                                      NULL);</span><br><span class="line"></span><br><span class="line">    ethernetip_description_field = arkime_field_define(&quot;ethernetip&quot;, &quot;string&quot;,</span><br><span class="line">                                                       &quot;ethernetip.description&quot;, &quot;EthernetIP Description&quot;, &quot;ethernetip.description&quot;,</span><br><span class="line">                                                       &quot;EthernetIP Description&quot;,</span><br><span class="line">                                                       ARKIME_FIELD_TYPE_STR_HASH, 0,</span><br><span class="line">                                                       NULL);</span><br><span class="line">    ethernetip_data_field = arkime_field_define(&quot;ethernetip&quot;, &quot;string&quot;,</span><br><span class="line">                                                    &quot;ethernetip.data&quot;, &quot;EthernetIP Data&quot;, &quot;ethernetip.data&quot;,</span><br><span class="line">                                                    &quot;EthernetIP Data&quot;,</span><br><span class="line">                                                    ARKIME_FIELD_TYPE_STR_HASH, 0,</span><br><span class="line">                                                    NULL);</span><br><span class="line">        ethernetip_src_port_field = arkime_field_define(&quot;ethernetip&quot;, &quot;integer&quot;,</span><br><span class="line">                                                        &quot;ethernetip.srcPort&quot;, &quot;EthernetIP Source Port&quot;, &quot;ethernetip.srcPort&quot;,</span><br><span class="line">                                                        &quot;EthernetIP Source Port&quot;,</span><br><span class="line">                                                        ARKIME_FIELD_TYPE_INT_HASH, 0,</span><br><span class="line">                                                        NULL);</span><br><span class="line"></span><br><span class="line">        ethernetip_dest_port_field = arkime_field_define(&quot;ethernetip&quot;, &quot;integer&quot;,</span><br><span class="line">                                                     &quot;ethernetip.destPort&quot;, &quot;EthernetIP Destination Port&quot;, &quot;ethernetip.destPort&quot;,</span><br><span class="line">                                                     &quot;EthernetIP Destination Port&quot;,</span><br><span class="line">                                                     ARKIME_FIELD_TYPE_INT_HASH, 0,</span><br><span class="line">                                                     NULL);</span><br><span class="line"></span><br><span class="line">    // 注册 TCP 端口 44818 的流量处理回调函数</span><br><span class="line">    arkime_parsers_classifier_register_port(&quot;ethernetip&quot;, NULL, ETHERNETIP_PORT, ARKIME_PARSERS_PORT_TCP, (ArkimeClassifyFunc)ethernetip_process_tcp_payload);</span><br><span class="line"></span><br><span class="line">    ethernetip_log(&quot;ethernetip plugin initialized!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/******************************************************************************/</span><br><span class="line">// 判断是否是 Ethernet/IP 数据 (基本判断)</span><br><span class="line">int ethernetip_is_ethernetip(const uint8_t *payload, int len) &#123;</span><br><span class="line">    if (len &lt; 24) &#123;  // Ethernet/IP Encapsulation Header is 24 bytes</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 可以添加更严格的检查，例如检查 Encap Command 是否是已知的值</span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/******************************************************************************/</span><br><span class="line">// 处理 TCP 数据包</span><br><span class="line">void ethernetip_process_tcp_payload(ArkimeSession_t *session, const uint8_t *payload, int len) &#123;</span><br><span class="line">    char sessionString[ARKIME_SESSIONID_LEN];</span><br><span class="line">    arkime_session_id_string(session-&gt;sessionId, sessionString);</span><br><span class="line">    ethernetip_log(&quot;ethernetip_process_tcp_payload called, len = %d, session id = %s&quot;, len, sessionString);</span><br><span class="line"></span><br><span class="line">    if (len &lt;= 0) &#123;</span><br><span class="line">        ethernetip_log(&quot;ethernetip_process_tcp_payload: len &lt;= 0, returning&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断是否是 Ethernet/IP 数据</span><br><span class="line">    if (!ethernetip_is_ethernetip(payload, len)) &#123;</span><br><span class="line">        ethernetip_log(&quot;ethernetip_process_tcp_payload: not Ethernet/IP traffic, returning&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EthernetIPData *eipData = ARKIME_TYPE_ALLOC0(EthernetIPData);</span><br><span class="line">    if (!eipData) &#123;</span><br><span class="line">        ethernetip_log(&quot;ERROR - 内存分配失败&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ethernetip_log(&quot;ethernetip_process_tcp_payload: Ethernet/IP data detected, parsing&quot;);</span><br><span class="line"></span><br><span class="line">    // 解析 Ethernet/IP Encapsulation Header</span><br><span class="line">    if (ethernetip_parse_encap_header(payload, len, eipData) == 0) &#123;</span><br><span class="line">        ethernetip_log(&quot;ethernetip_process_tcp_payload: ethernetip_parse_encap_header success&quot;);</span><br><span class="line"></span><br><span class="line">        // 解析 CIP 数据</span><br><span class="line">        if (eipData-&gt;cip_data != NULL &amp;&amp; eipData-&gt;cip_length &gt; 0) &#123;</span><br><span class="line">            if (ethernetip_parse_cip_data(eipData-&gt;cip_data, eipData-&gt;cip_length, eipData) == 0) &#123;</span><br><span class="line">                // 添加 Ethernet/IP 数据到 Arkime 字段</span><br><span class="line">                arkime_field_int_add(ethernetip_command_field, session, eipData-&gt;encap_command);</span><br><span class="line">                arkime_field_int_add(ethernetip_session_field, session, eipData-&gt;encap_session);</span><br><span class="line">                arkime_field_int_add(ethernetip_status_field, session, eipData-&gt;encap_status);</span><br><span class="line">                arkime_field_int_add(ethernetip_service_field, session, eipData-&gt;cip_service);</span><br><span class="line">                 arkime_field_int_add(ethernetip_src_port_field, session, session-&gt;port1);</span><br><span class="line">                arkime_field_int_add(ethernetip_dest_port_field, session, session-&gt;port2);</span><br><span class="line">                if (eipData-&gt;description != NULL) &#123;</span><br><span class="line">                    arkime_field_string_add(ethernetip_description_field, session, eipData-&gt;description, -1, TRUE);</span><br><span class="line">                &#125;</span><br><span class="line">                 char data_hex[2 * eipData-&gt;cip_length + 1]; // 2 characters per byte + null terminator</span><br><span class="line">                    for (int i = 0; i &lt; eipData-&gt;cip_length; i++) &#123;</span><br><span class="line">                        sprintf(data_hex + 2 * i, &quot;%02X&quot;, eipData-&gt;cip_data[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    data_hex[2 * eipData-&gt;cip_length] = &#x27;\0&#x27;; // Null terminate the string</span><br><span class="line">                    arkime_field_string_add(ethernetip_data_field, session, data_hex, -1, TRUE);</span><br><span class="line"></span><br><span class="line">                ethernetip_free_data(eipData);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ethernetip_log(&quot;ethernetip_process_tcp_payload: ethernetip_parse_cip_data failed&quot;);</span><br><span class="line">                ethernetip_free_data(eipData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ethernetip_log(&quot;ethernetip_process_tcp_payload: No CIP data to parse&quot;);</span><br><span class="line">            ethernetip_free_data(eipData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ethernetip_log(&quot;ethernetip_process_tcp_payload: ethernetip_parse_encap_header failed&quot;);</span><br><span class="line">        ethernetip_free_data(eipData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/******************************************************************************/</span><br><span class="line">// 解析 Ethernet/IP Encapsulation Header</span><br><span class="line">int ethernetip_parse_encap_header(const uint8_t *payload, int len, EthernetIPData *eipData) &#123;</span><br><span class="line">    if (len &lt; 24) &#123;</span><br><span class="line">        ethernetip_log(&quot;ethernetip_parse_encap_header: len &lt; 24, returning -1&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    eipData-&gt;encap_command      = ntohl(*(uint32_t*)(payload + 0));</span><br><span class="line">    eipData-&gt;encap_length       = ntohl(*(uint32_t*)(payload + 4));</span><br><span class="line">    eipData-&gt;encap_session      = ntohl(*(uint32_t*)(payload + 8));</span><br><span class="line">    eipData-&gt;encap_status       = ntohl(*(uint32_t*)(payload + 12));</span><br><span class="line"></span><br><span class="line">     // Sender Context is 8 bytes</span><br><span class="line">    memcpy(&amp;eipData-&gt;encap_sender_context, payload + 16, 8);</span><br><span class="line"></span><br><span class="line">    eipData-&gt;encap_options      = ntohl(*(uint32_t*)(payload + 24));</span><br><span class="line"></span><br><span class="line">    ethernetip_log(&quot;ethernetip_parse_encap_header: command=0x%X, length=%u, session=0x%X, status=0x%X&quot;,</span><br><span class="line">                   eipData-&gt;encap_command, eipData-&gt;encap_length, eipData-&gt;encap_session, eipData-&gt;encap_status);</span><br><span class="line"></span><br><span class="line">    // 提取 CIP 数据</span><br><span class="line">    if (eipData-&gt;encap_length &gt; 0 &amp;&amp; len &gt;= 24 + eipData-&gt;encap_length) &#123;</span><br><span class="line">        eipData-&gt;cip_length = eipData-&gt;encap_length;</span><br><span class="line">        eipData-&gt;cip_data = ARKIME_SIZE_ALLOC0(ethernetip_cip_data, eipData-&gt;cip_length); // 使用 Arkime 的内存分配函数</span><br><span class="line">        if (!eipData-&gt;cip_data) &#123;</span><br><span class="line">            ethernetip_log(&quot;ERROR - 内存分配失败&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        memcpy(eipData-&gt;cip_data, payload + 24, eipData-&gt;cip_length);</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ethernetip_log(&quot;ethernetip_parse_encap_header: No CIP data or invalid length&quot;);</span><br><span class="line">        eipData-&gt;cip_data = NULL;</span><br><span class="line">        eipData-&gt;cip_length = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/******************************************************************************/</span><br><span class="line">// 解析 CIP 数据 (简化)</span><br><span class="line">int ethernetip_parse_cip_data(const uint8_t *cip_data, int cip_len, EthernetIPData *eipData) &#123;</span><br><span class="line">    if (cip_len &lt; 1) &#123;</span><br><span class="line">        ethernetip_log(&quot;ethernetip_parse_cip_data: cip_len &lt; 1, returning -1&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    eipData-&gt;cip_service = cip_data[0];</span><br><span class="line">    ethernetip_log(&quot;ethernetip_parse_cip_data: CIP Service Code = 0x%02X&quot;, eipData-&gt;cip_service);</span><br><span class="line"></span><br><span class="line">    eipData-&gt;description = &quot;Unknown CIP Service&quot;; // 默认描述</span><br><span class="line"></span><br><span class="line">    switch (eipData-&gt;cip_service) &#123;</span><br><span class="line">        case CIP_SVC_GET_ATTRIB_SINGLE:</span><br><span class="line">            eipData-&gt;description = &quot;Get Attribute Single&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case CIP_SVC_SET_ATTRIB_SINGLE:</span><br><span class="line">            eipData-&gt;description = &quot;Set Attribute Single&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case CIP_SVC_UNCONNECTED_SEND:</span><br><span class="line">            eipData-&gt;description = &quot;Unconnected Send&quot;;</span><br><span class="line">            break;</span><br><span class="line">         case CIP_SVC_FORWARD_OPEN:</span><br><span class="line">            eipData-&gt;description = &quot;Forward Open&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case CIP_SVC_FORWARD_CLOSE:</span><br><span class="line">            eipData-&gt;description = &quot;Forward Close&quot;;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ethernetip_log(&quot;ethernetip_parse_cip_data: Description = %s&quot;, eipData-&gt;description);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/******************************************************************************/</span><br><span class="line">// 释放 EthernetIPData 结构体内存</span><br><span class="line">void ethernetip_free_data(EthernetIPData *data) &#123;</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        if (data-&gt;cip_data) &#123;</span><br><span class="line">            ARKIME_SIZE_FREE(ethernetip_cip_data, data-&gt;cip_data);</span><br><span class="line">        &#125;</span><br><span class="line">        ARKIME_TYPE_FREE(EthernetIPData, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/******************************************************************************/</span><br><span class="line">// 供 Arkime 加载插件的函数</span><br><span class="line">#ifndef UNIT_TEST</span><br><span class="line">void arkime_plugin_load() &#123;</span><br><span class="line">    ethernetip_log(&quot;arkime_plugin_load() called&quot;);</span><br><span class="line">    arkime_plugin_init();</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>content_copydownload</p>
<p>Use code <a target="_blank" rel="noopener" href="https://support.google.com/legal/answer/13505487">with caution</a>.C</p>
<p><strong>代码解释</strong></p>
<h2 id="1-2-头文件-包含了必要的头文件，与-Modbus-插件类似。3-常量定义-定义了-Ethernet-IP-端口号和一些常用的-CIP-Service-Codes。4-数据结构-EthernetIPData-结构体用于存储-Ethernet-IP-数据，包括-Encap-Header-的字段和-CIP-数据。-这个结构体是简化的，实际应用中需要根据-CIP-协议进行扩展。5-插件初始化-arkime-plugin-init-函数注册插件、定义-Arkime-字段，并注册了-TCP-端口-44818-的流量处理回调函数-ethernetip-process-tcp-payload。6-ethernetip-is-ethernetip-函数-简单的判断，可以根据实际情况增加判断逻辑7-ethernetip-process-tcp-payload-函数"><a href="#1-2-头文件-包含了必要的头文件，与-Modbus-插件类似。3-常量定义-定义了-Ethernet-IP-端口号和一些常用的-CIP-Service-Codes。4-数据结构-EthernetIPData-结构体用于存储-Ethernet-IP-数据，包括-Encap-Header-的字段和-CIP-数据。-这个结构体是简化的，实际应用中需要根据-CIP-协议进行扩展。5-插件初始化-arkime-plugin-init-函数注册插件、定义-Arkime-字段，并注册了-TCP-端口-44818-的流量处理回调函数-ethernetip-process-tcp-payload。6-ethernetip-is-ethernetip-函数-简单的判断，可以根据实际情况增加判断逻辑7-ethernetip-process-tcp-payload-函数" class="headerlink" title="1.2. 头文件: 包含了必要的头文件，与 Modbus 插件类似。3. 常量定义: 定义了 Ethernet&#x2F;IP 端口号和一些常用的 CIP Service Codes。4. 数据结构: EthernetIPData 结构体用于存储 Ethernet&#x2F;IP 数据，包括 Encap Header 的字段和 CIP 数据。 这个结构体是简化的，实际应用中需要根据 CIP 协议进行扩展。5. 插件初始化: arkime_plugin_init() 函数注册插件、定义 Arkime 字段，并注册了 TCP 端口 44818 的流量处理回调函数 ethernetip_process_tcp_payload。6. ethernetip_is_ethernetip 函数: 简单的判断，可以根据实际情况增加判断逻辑7. ethernetip_process_tcp_payload 函数:"></a>1.<br>2. <strong>头文件:</strong> 包含了必要的头文件，与 Modbus 插件类似。<br>3. <strong>常量定义:</strong> 定义了 Ethernet&#x2F;IP 端口号和一些常用的 CIP Service Codes。<br>4. <strong>数据结构:</strong> EthernetIPData 结构体用于存储 Ethernet&#x2F;IP 数据，包括 Encap Header 的字段和 CIP 数据。 这个结构体是简化的，实际应用中需要根据 CIP 协议进行扩展。<br>5. <strong>插件初始化:</strong> arkime_plugin_init() 函数注册插件、定义 Arkime 字段，并注册了 TCP 端口 44818 的流量处理回调函数 ethernetip_process_tcp_payload。<br>6. <strong>ethernetip_is_ethernetip 函数:</strong> 简单的判断，可以根据实际情况增加判断逻辑<br>7. <strong>ethernetip_process_tcp_payload 函数:</strong></h2><ul>
<li>判断是否为 Ethernet&#x2F;IP 流量。</li>
<li>调用 ethernetip_parse_encap_header() 解析 Ethernet&#x2F;IP Encapsulation Header。</li>
<li>如果存在 CIP 数据，则调用 ethernetip_parse_cip_data() 解析 CIP 数据。</li>
<li>将解析出的数据添加到 Arkime 字段中。</li>
<li>释放内存。</li>
</ul>
<ol start="8">
<li><strong>ethernetip_parse_encap_header 函数:</strong> 解析 Ethernet&#x2F;IP Encapsulation Header，提取 Command、Length、Session、Status 等字段。</li>
<li><strong>ethernetip_parse_cip_data 函数:</strong> 解析 CIP 数据，提取 Service Code，并根据 Service Code 设置描述信息。 这个函数只是一个框架，你需要根据 CIP 协议的规范，实现更详细的解析逻辑。</li>
<li><strong>ethernetip_free_data 函数:</strong> 释放 EthernetIPData 结构体占用的内存。</li>
</ol>
<p><strong>编译和安装</strong></p>
<p>与 Modbus 插件类似，你需要创建一个 Makefile，并使用 gcc 命令编译插件。 然后将编译生成的 ethernetip_plugin.so 文件复制到 Arkime 的插件目录，并在 config.ini 文件中启用插件。</p>
<p><strong>Makefile 示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ARKIME_PREFIX ?= /opt/arkime</span><br><span class="line"></span><br><span class="line">PLUGIN_NAME = ethernetip_plugin</span><br><span class="line">PLUGIN_SO = $(PLUGIN_NAME).so</span><br><span class="line">PLUGIN_PATH = $(ARKIME_PREFIX)/plugins</span><br><span class="line"></span><br><span class="line">CFLAGS = -g -fPIC -Wall -I$(ARKIME_PREFIX)/include</span><br><span class="line">LDFLAGS = -shared</span><br><span class="line"></span><br><span class="line">all: $(PLUGIN_SO)</span><br><span class="line"></span><br><span class="line">$(PLUGIN_SO): $(PLUGIN_NAME).c</span><br><span class="line">	$(CC) $(CFLAGS) -o $@ $&lt; $(LDFLAGS)</span><br><span class="line"></span><br><span class="line">install: $(PLUGIN_SO)</span><br><span class="line">	install -D $(PLUGIN_SO) $(PLUGIN_PATH)/$(PLUGIN_SO)</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	rm -f $(PLUGIN_SO)</span><br><span class="line"></span><br><span class="line">.PHONY: all install clean</span><br></pre></td></tr></table></figure>

<p>content_copydownload</p>
<p>Use code <a target="_blank" rel="noopener" href="https://support.google.com/legal/answer/13505487">with caution</a>.Makefile</p>
<p><strong>重要提示</strong></p>
<p>- </p>
<ul>
<li><strong>理解 Ethernet&#x2F;IP 和 CIP 协议:</strong> Ethernet&#x2F;IP 和 CIP 协议非常复杂。 你需要仔细阅读相关文档，了解协议的细节。 特别是 CIP 协议的对象模型、服务、类、实例、属性等概念。</li>
<li><strong>CIP 协议解析:</strong> ethernetip_parse_cip_data() 函数只是一个框架。 你需要根据 CIP 协议的规范，实现更详细的解析逻辑。 例如，你需要解析 CIP 对象的路径、属性 ID、数据类型等。</li>
<li><strong>错误处理:</strong> 示例代码的错误处理比较简单。 在实际项目中，需要添加更完善的错误处理机制。</li>
<li><strong>性能优化:</strong> 对于高流量环境，需要对协议解析代码进行性能优化。</li>
</ul>
<p><strong>扩展方向</strong></p>
<p>1.<br>2. <strong>支持 UDP:</strong> Ethernet&#x2F;IP 也可以使用 UDP 协议。 你需要添加对 UDP 协议的支持。<br>3. <strong>解析 CIP 对象路径:</strong> CIP 对象路径用于指定要访问的对象。 你需要解析对象路径，并根据对象类型进行相应的处理。<br>4. <strong>解析 CIP 属性:</strong> CIP 属性用于读取或写入对象的数据。 你需要解析属性 ID 和数据类型，并将数据存储到 Arkime 字段中。<br>5. <strong>支持 CIP 服务:</strong> CIP 协议定义了很多服务，例如 Get Attribute Single、Set Attribute Single、Read Modify Write 等。 你需要支持更多的 CIP 服务。<br>6. <strong>使用开源库:</strong> 可以考虑使用开源的 Ethernet&#x2F;IP 或 CIP 协议解析库，例如 cpppo 等。</p>
<p>wireshark捕获S7-1200-Uploading-OB1-TIAV12.pcap<br>后数据<br>Frame 1: 66 bytes on wire (528 bits), 66 bytes captured (528 bits)<br>Ethernet II, Src: ASUSTekCOMPU_84:5e:41 (90:e6:ba:84:5e:41), Dst: SiemensNumer_08:e7:db (00:1c:06:08:e7:db)<br>Internet Protocol Version 4, Src: 192.168.1.10, Dst: 192.168.1.191<br>Transmission Control Protocol, Src Port: 60511, Dst Port: 102, Seq: 0, Len: 0</p>
<p>0000   00 1c 06 08 e7 db 90 e6 ba 84 5e 41 08 00 45 00   ……….^A..E.<br>0010   00 34 1e 18 40 00 80 06 00 00 c0 a8 01 0a c0 a8   .4..@………..<br>0020   01 bf ec 5f 00 66 14 17 dd ec 00 00 00 00 80 02   …_.f……….<br>0030   20 00 84 40 00 00 02 04 05 b4 01 03 03 08 01 01    ..@…………<br>0040   04 02                                             ..</p>
<p>Frame 2: 60 bytes on wire (480 bits), 60 bytes captured (480 bits)<br>Ethernet II, Src: SiemensNumer_08:e7:db (00:1c:06:08:e7:db), Dst: ASUSTekCOMPU_84:5e:41 (90:e6:ba:84:5e:41)<br>Internet Protocol Version 4, Src: 192.168.1.191, Dst: 192.168.1.10<br>Transmission Control Protocol, Src Port: 102, Dst Port: 60511, Seq: 0, Ack: 1, Len: 0</p>
<p>0000   90 e6 ba 84 5e 41 00 1c 06 08 e7 db 08 00 45 00   ….^A……..E.<br>0010   00 2c 01 8f 00 00 1e 06 17 24 c0 a8 01 bf c0 a8   .,…….$……<br>0020   01 0a 00 66 ec 5f 00 02 f9 c8 14 17 dd ed 60 12   …f._……..&#96;.<br>0030   10 00 2b 67 00 00 02 04 05 b4 00 00               ..+g……..</p>
<p>Frame 3: 54 bytes on wire (432 bits), 54 bytes captured (432 bits)<br>Ethernet II, Src: ASUSTekCOMPU_84:5e:41 (90:e6:ba:84:5e:41), Dst: SiemensNumer_08:e7:db (00:1c:06:08:e7:db)<br>Internet Protocol Version 4, Src: 192.168.1.10, Dst: 192.168.1.191<br>Transmission Control Protocol, Src Port: 60511, Dst Port: 102, Seq: 1, Ack: 1, Len: 0</p>
<p>0000   00 1c 06 08 e7 db 90 e6 ba 84 5e 41 08 00 45 00   ……….^A..E.<br>0010   00 28 1e 19 40 00 80 06 00 00 c0 a8 01 0a c0 a8   .(..@………..<br>0020   01 bf ec 5f 00 66 14 17 dd ed 00 02 f9 c9 50 10   …_.f……..P.<br>0030   fa f0 84 34 00 00                                 …4..</p>
<p>Frame 4: 89 bytes on wire (712 bits), 89 bytes captured (712 bits)<br>Ethernet II, Src: ASUSTekCOMPU_84:5e:41 (90:e6:ba:84:5e:41), Dst: SiemensNumer_08:e7:db (00:1c:06:08:e7:db)<br>Internet Protocol Version 4, Src: 192.168.1.10, Dst: 192.168.1.191<br>Transmission Control Protocol, Src Port: 60511, Dst Port: 102, Seq: 1, Ack: 1, Len: 35<br>TPKT, Version: 3, Length: 35<br>ISO 8073&#x2F;X.224 COTP Connection-Oriented Transport Protocol</p>
<p>0000   00 1c 06 08 e7 db 90 e6 ba 84 5e 41 08 00 45 00   ……….^A..E.<br>0010   00 4b 1e 1a 40 00 80 06 00 00 c0 a8 01 0a c0 a8   .K..@………..<br>0020   01 bf ec 5f 00 66 14 17 dd ed 00 02 f9 c9 50 18   …_.f……..P.<br>0030   fa f0 84 57 00 00 03 00 00 23 1e e0 00 00 00 11   …W…..#……<br>0040   00 c1 02 06 00 c2 0f 53 49 4d 41 54 49 43 2d 52   …….SIMATIC-R<br>0050   4f 4f 54 2d 45 53 c0 01 0a                        OOT-ES…</p>
<p>Frame 5: 89 bytes on wire (712 bits), 89 bytes captured (712 bits)<br>Ethernet II, Src: SiemensNumer_08:e7:db (00:1c:06:08:e7:db), Dst: ASUSTekCOMPU_84:5e:41 (90:e6:ba:84:5e:41)<br>Internet Protocol Version 4, Src: 192.168.1.191, Dst: 192.168.1.10<br>Transmission Control Protocol, Src Port: 102, Dst Port: 60511, Seq: 1, Ack: 36, Len: 35<br>TPKT, Version: 3, Length: 35<br>ISO 8073&#x2F;X.224 COTP Connection-Oriented Transport Protocol</p>
<p>0000   90 e6 ba 84 5e 41 00 1c 06 08 e7 db 08 00 45 00   ….^A……..E.<br>0010   00 4b 01 90 00 00 1e 06 17 04 c0 a8 01 bf c0 a8   .K…………..<br>0020   01 0a 00 66 ec 5f 00 02 f9 c9 14 17 de 10 50 18   …f._……..P.<br>0030   10 00 3c 04 00 00 03 00 00 23 1e d0 00 11 00 07   ..&lt;……#……<br>0040   00 c0 01 0a c1 02 06 00 c2 0f 53 49 4d 41 54 49   ……….SIMATI<br>0050   43 2d 52 4f 4f 54 2d 45 53                        C-ROOT-ES</p>
<p>Frame 6: 275 bytes on wire (2200 bits), 275 bytes captured (2200 bits)<br>Ethernet II, Src: ASUSTekCOMPU_84:5e:41 (90:e6:ba:84:5e:41), Dst: SiemensNumer_08:e7:db (00:1c:06:08:e7:db)<br>Internet Protocol Version 4, Src: 192.168.1.10, Dst: 192.168.1.191<br>Transmission Control Protocol, Src Port: 60511, Dst Port: 102, Seq: 36, Ack: 36, Len: 221<br>TPKT, Version: 3, Length: 221<br>ISO 8073&#x2F;X.224 COTP Connection-Oriented Transport Protocol<br>Data (214 bytes)</p>
<p>0000   00 1c 06 08 e7 db 90 e6 ba 84 5e 41 08 00 45 00   ……….^A..E.<br>0010   01 05 1e 1b 40 00 80 06 00 00 c0 a8 01 0a c0 a8   ....@………..<br>0020   01 bf ec 5f 00 66 14 17 de 10 00 02 f9 ec 50 18   …_.f……..P.<br>0030   fa cd 85 11 00 00 03 00 00 dd 02 f0 80 72 01 00   ………….r..<br>0040   ce 31 00 00 04 ca 00 00 00 01 00 00 01 20 36 00   .1……….. 6.<br>0050   00 01 1d 00 04 00 00 00 00 00 a1 00 00 00 d3 82   …………….<br>0060   1f 00 00 a3 81 69 00 15 14 53 65 72 76 65 72 53   …..i…ServerS<br>0070   65 73 73 69 6f 6e 5f 32 44 43 36 44 32 a3 82 21   ession_2DC6D2..!<br>0080   00 15 2c 31 3a 3a 3a 36 2e 30 3a 3a 54 43 50 2f   ..,1:::6.0::TCP&#x2F;<br>0090   49 50 20 2d 3e 20 41 74 68 65 72 6f 73 20 41 52   IP -&gt; Atheros AR<br>00a0   38 31 32 31 2f 41 52 38 31 31 33 2f 2e 2e 2e a3   8121&#x2F;AR8113&#x2F;….<br>00b0   82 28 00 15 00 a3 82 29 00 15 00 a3 82 2a 00 15   .(…..)…..*..<br>00c0   0f 56 4f 52 54 45 58 5f 32 31 30 33 32 34 39 31   .VORTEX_21032491<br>00d0   a3 82 2b 00 04 01 a3 82 2c 00 12 00 2d c6 d2 a3   ..+…..,…-…<br>00e0   82 2d 00 15 00 a1 00 00 00 d3 81 7f 00 00 a3 81   .-…………..<br>00f0   69 00 15 15 53 75 62 73 63 72 69 70 74 69 6f 6e   i…Subscription<br>0100   43 6f 6e 74 61 69 6e 65 72 a2 a2 00 00 00 00 72   Container……r<br>0110   01 00 00                                          …</p>
<p>root@ubuntu:&#x2F;opt&#x2F;arkime&#x2F;bin# .&#x2F;capture -r pcap &#x2F;home&#x2F;kuze&#x2F;Desktop&#x2F;s7包&#x2F;S7-1200-Uploading-OB1-TIAV12.pcap<br>Mar 10 15:14:02 main.c:259 parse_args(): WARNING: gethostname doesn’t return a fully qualified name and getdomainname failed, this may cause issues when viewing pcaps, use the –host option - ubuntu<br>Mar 10 15:14:02 http.c:318 arkime_http_send_sync(): 1&#x2F;1 SYNC 200 <a target="_blank" rel="noopener" href="http://localhost:9200/_template/arkime_sessions3_template?filter_path=**._meta">http://localhost:9200/_template/arkime_sessions3_template?filter_path=**._meta</a> 0&#x2F;96 0ms 2ms<br>Mar 10 15:14:02 http.c:318 arkime_http_send_sync(): 1&#x2F;1 SYNC 200 <a target="_blank" rel="noopener" href="http://localhost:9200/arkime_sequence/_doc/fn-ubuntu">http://localhost:9200/arkime_sequence/_doc/fn-ubuntu</a> 0&#x2F;123 0ms 1ms<br>Mar 10 15:14:02 http.c:318 arkime_http_send_sync(): 1&#x2F;1 SYNC 200 <a target="_blank" rel="noopener" href="http://localhost:9200/arkime_stats/_doc/ubuntu">http://localhost:9200/arkime_stats/_doc/ubuntu</a> 0&#x2F;948 0ms 1ms<br>Mar 10 15:14:02 http.c:318 arkime_http_send_sync(): 1&#x2F;1 SYNC 200 <a target="_blank" rel="noopener" href="http://localhost:9200/arkime_fields/_search?size=3000">http://localhost:9200/arkime_fields/_search?size=3000</a> 0&#x2F;109410 0ms 9ms<br>Mar 10 15:14:02 db.c:2805 arkime_db_init(): WARNING - No Geo Country file could be loaded, see <a target="_blank" rel="noopener" href="https://arkime.com/settings#geolite2country">https://arkime.com/settings#geolite2country</a><br>Mar 10 15:14:02 db.c:2816 arkime_db_init(): WARNING - No Geo ASN file could be loaded, see <a target="_blank" rel="noopener" href="https://arkime.com/settings#geolite2asn">https://arkime.com/settings#geolite2asn</a><br>2025-03-10 15:14:02 [s7_plugin] arkime_plugin_init() called<br>2025-03-10 15:14:02 [s7_protocol] s7_protocol_init called.<br>2025-03-10 15:14:02 [s7_plugin] S7 Plugin initialized successfully!<br>Mar 10 15:14:02 http.c:406 arkime_http_curlm_check_multi_info(): 1&#x2F;1 ASYNC 200 <a target="_blank" rel="noopener" href="http://localhost:9200/_cat/health?format=json">http://localhost:9200/_cat/health?format=json</a> 0&#x2F;197 0ms 2ms<br>Mar 10 15:14:02 reader-libpcap-file.c:187 reader_libpcapfile_process(): ERROR - pcap open failed - Couldn’t realpath file: ‘pcap’ with No such file or directory (2)<br>Mar 10 15:14:02 packet.c:689 arkime_packet_log(): packets: 0 current sessions: 0&#x2F;0 oldest: 0 - recv: 0 drop: 0 (0.00) queue: 0 disk: 0 packet: 0 close: 0 ns: 0 frags: 0&#x2F;0 pstats: 0&#x2F;0&#x2F;0&#x2F;0&#x2F;0&#x2F;0&#x2F;0 ver: 5.6.1<br>Mar 10 15:14:02 http.c:318 arkime_http_send_sync(): 1&#x2F;1 SYNC 200 <a target="_blank" rel="noopener" href="http://localhost:9200/_bulk">http://localhost:9200/_bulk</a> 1796&#x2F;1834 0ms 4ms<br>Mar 10 15:14:02 http.c:318 arkime_http_send_sync(): 1&#x2F;1 SYNC 200 <a target="_blank" rel="noopener" href="http://localhost:9200/arkime_stats/_doc/ubuntu">http://localhost:9200/arkime_stats/_doc/ubuntu</a> 801&#x2F;173 0ms 2ms<br>Mar 10 15:14:02 http.c:318 arkime_http_send_sync(): 1&#x2F;1 SYNC 200 <a target="_blank" rel="noopener" href="http://localhost:9200/arkime_*/_refresh">http://localhost:9200/arkime_*/_refresh</a> 0&#x2F;51 0ms 24ms</p>
<p>s7插件显示No data for this field<br>s7-protocol.c :<br>&#x2F;&#x2F; s7-protocol.c<br>#include “s7-protocol.h”<br>#include &lt;string.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;arpa&#x2F;inet.h&gt;<br>#include &lt;math.h&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;stdarg.h&gt;<br>#include &lt;time.h&gt;</p>
<p>&#x2F;&#x2F; 用于 s7-protocol.c 的日志记录函数<br>static void s7p_log(const char *format, …) {<br>va_list args;<br>va_start(args, format);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">      time_t timer;</span><br><span class="line">char time_buffer[26];</span><br><span class="line">struct tm tm_info;</span><br><span class="line"></span><br><span class="line">time(&amp;timer);</span><br><span class="line">if (localtime_r(&amp;timer, &amp;tm_info) == NULL) &#123;</span><br><span class="line">    perror(&quot;localtime_r&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> if (strftime(time_buffer, sizeof(time_buffer), &quot;%Y-%m-%d %H:%M:%S&quot;, &amp;tm_info) == 0) &#123;</span><br><span class="line">    fprintf(stderr, &quot;strftime failed\n&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">fprintf(stderr, &quot;%s [s7_protocol] &quot;, time_buffer);</span><br><span class="line">vfprintf(stderr, format, args);</span><br><span class="line">fprintf(stderr, &quot;\n&quot;);</span><br><span class="line">va_end(args);</span><br><span class="line">fflush(stderr);</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>}</p>
<p>&#x2F;&#x2F; TPKT 头<br>typedef struct {<br>uint8_t  version;<br>uint8_t  reserved;<br>uint16_t length;<br>} TPKTHeader;</p>
<p>&#x2F;&#x2F; COTP 头<br>typedef struct {<br>uint8_t length;<br>uint8_t pduType;<br>union {<br>struct { &#x2F;&#x2F; DT (Data) PDU<br>uint8_t tpduNumber : 7;<br>uint8_t eot : 1;<br>} dt;<br>struct { &#x2F;&#x2F; CR (Connection Request)<br>uint8_t  dstRef[2];<br>uint8_t  srcRef[2];<br>uint8_t classOption;<br>} cr;<br>} u;<br>} COTPHeader;</p>
<p>&#x2F;&#x2F; S7 PDU 头<br>typedef struct {<br>uint8_t  protocolId;<br>uint8_t  messageType;<br>uint16_t reserved;<br>uint16_t pduReference;<br>uint16_t paramLength;<br>uint16_t dataLength;<br>uint8_t errorClass;   &#x2F;&#x2F; Ack-Data 中<br>uint8_t errorCode;    &#x2F;&#x2F; Ack-Data 中<br>} S7Header;</p>
<p>&#x2F;&#x2F; S7 读&#x2F;写变量参数 (请求)<br>typedef struct {<br>uint8_t functionCode;<br>uint8_t itemCount;<br>} S7ReadWriteVarParam;</p>
<p>&#x2F;&#x2F; S7 读&#x2F;写变量项 (请求)<br>typedef struct {<br>uint8_t  syntaxId;<br>uint8_t  transportSize;<br>uint16_t length;<br>uint8_t  area;<br>uint16_t dbNumber;<br>uint32_t startOffset; &#x2F;&#x2F; 字节地址 * 8 + 位偏移<br>} S7ReadWriteVarItemReq;</p>
<p>&#x2F;&#x2F; S7 读&#x2F;写变量返回代码 (响应)<br>typedef struct {<br>uint8_t  functionCode;<br>uint8_t  itemCount;<br>} S7ReadWriteVarResponse;</p>
<p>&#x2F;&#x2F; S7 读&#x2F;写变量项 (响应)<br>typedef struct {<br>uint8_t  returnCode;<br>uint8_t  transportSize;<br>uint16_t length; &#x2F;&#x2F; BOOL 用位, 其他用字节<br>} S7ReadWriteVarItemRes;</p>
<p>&#x2F;&#x2F; S7 PLC 控制 (启动&#x2F;停止请求)<br>typedef struct {<br>uint8_t functionCode;<br>uint8_t method;      &#x2F;&#x2F; 0x09 表示停止, 0x04&#x2F;0x05 表示启动<br>uint8_t unknown[6];  &#x2F;&#x2F; 固定长度<br>uint16_t paramLength;<br>} S7PLCControlParam;</p>
<p>&#x2F;&#x2F; S7 PLC 控制 (响应)<br>typedef struct {<br>uint8_t functionCode;<br>} S7PLCControlResponse;</p>
<p>&#x2F;&#x2F; S7 请求下载 (请求)<br>typedef struct {<br>uint8_t functionCode;<br>uint8_t subFunction; &#x2F;&#x2F; 0x01 &#x3D; 请求下载, 0x03 &#x3D; 结束下载<br>uint8_t blockType;   &#x2F;&#x2F; ‘B’, ‘F’, ‘O’ 等<br>uint8_t padding[5];<br>uint32_t blockNumber;<br>} S7ReqDownloadParam;</p>
<p>&#x2F;&#x2F; S7 下载块&#x2F;上传 (请求)<br>typedef struct {<br>uint8_t functionCode;<br>uint8_t subFunction; &#x2F;&#x2F; 下载: 0x02, 上传: 0x01, 结束上传: 0x02<br>} S7DownloadBlockParam;</p>
<p>&#x2F;&#x2F; S7 下载&#x2F;上传 (响应)<br>typedef struct {<br>uint8_t functionCode;<br>uint8_t subFunction; &#x2F;&#x2F; 下载: 0x02, 上传: 0x01, 结束上传&#x3D;0x02<br>uint8_t padding[3];   &#x2F;&#x2F; 通常为 0<br>} S7DownloadUploadResponse;</p>
<p>&#x2F;&#x2F; S7 数据类型解码辅助函数 (将 S7 字节数据转换为字符串)<br>char* s7_decode_data(const S7Item *item, char * resultBuf, size_t bufSize)<br>{<br>if (!item || !item-&gt;data || item-&gt;dataLengthBytes &#x3D;&#x3D; 0 || !resultBuf || bufSize &#x3D;&#x3D; 0) {<br>s7p_log(“s7_decode_data: Invalid input parameters.”);<br>return NULL; &#x2F;&#x2F; 无效输入<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">      switch (item-&gt;transportSize)</span><br><span class="line">&#123;</span><br><span class="line">    case 0x01: // BOOL (位)</span><br><span class="line">        snprintf(resultBuf, bufSize, &quot;%s&quot;, (item-&gt;data[0] &amp; (1 &lt;&lt; (item-&gt;startOffset % 8))) ? &quot;true&quot; : &quot;false&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case 0x02: // BYTE, WORD, DWORD, INT, DINT</span><br><span class="line">       if (item-&gt;length == 8) &#123; // BYTE, S7_Char</span><br><span class="line">            snprintf(resultBuf, bufSize, &quot;0x%02X&quot;, item-&gt;data[0]);</span><br><span class="line">       &#125; else if (item-&gt;length == 16) &#123; // WORD, INT</span><br><span class="line">           uint16_t value = ntohs(*(uint16_t *)item-&gt;data);</span><br><span class="line">            if (item-&gt;area == 0x1E || item-&gt;area == 0x1F) // Counter/Timer</span><br><span class="line">            &#123;</span><br><span class="line">               snprintf(resultBuf, bufSize, &quot;%u&quot;, value);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                snprintf(resultBuf, bufSize, &quot;%d&quot;, (int16_t)value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       else if (item-&gt;length == 32) &#123;  //DWORD, DINT</span><br><span class="line">          uint32_t value = ntohl(*(uint32_t*)item-&gt;data);</span><br><span class="line">           if (item-&gt;area == 0x1E || item-&gt;area == 0x1F)</span><br><span class="line">           &#123;</span><br><span class="line">              snprintf(resultBuf, bufSize, &quot;%u&quot;, value);</span><br><span class="line">           &#125;</span><br><span class="line">           else</span><br><span class="line">           &#123;</span><br><span class="line">              snprintf(resultBuf, bufSize, &quot;%d&quot;, (int32_t)value); //DINT</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       else&#123;</span><br><span class="line">          snprintf(resultBuf, bufSize, &quot;UnsupportedLength&quot;);</span><br><span class="line">          s7p_log(&quot;s7_decode_data: Unsupported length for transport size 0x02: %d&quot;, item-&gt;length);</span><br><span class="line">       &#125;</span><br><span class="line">        break;</span><br><span class="line">    case 0x04: // REAL (浮点数)</span><br><span class="line">        if (item-&gt;dataLengthBytes == 4) &#123;</span><br><span class="line">            uint32_t temp = ntohl(*(uint32_t *)item-&gt;data);</span><br><span class="line">            float f;</span><br><span class="line">            memcpy(&amp;f, &amp;temp, 4);</span><br><span class="line">            snprintf(resultBuf, bufSize, &quot;%f&quot;, f);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">             snprintf(resultBuf, bufSize, &quot;InvalidReal&quot;);</span><br><span class="line">             s7p_log(&quot;s7_decode_data: Invalid data length for REAL: %d&quot;, item-&gt;dataLengthBytes);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    case 0x09: //Counter, Timer</span><br><span class="line">      if (item-&gt;length == 16)</span><br><span class="line">      &#123;</span><br><span class="line">          //BCD 格式</span><br><span class="line">          uint16_t value = ntohs(*(uint16_t *)item-&gt;data);</span><br><span class="line">          uint16_t bcdValue = ((value &gt;&gt; 12) &amp; 0x000F) * 100 + ((value &gt;&gt; 8) &amp; 0x000F) * 10 + ((value &gt;&gt; 4) &amp; 0x000F);</span><br><span class="line">           snprintf(resultBuf, bufSize, &quot;%u&quot;, bcdValue);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      else&#123;</span><br><span class="line">         snprintf(resultBuf, bufSize, &quot;UnsupportedLength&quot;);</span><br><span class="line">         s7p_log(&quot;s7_decode_data: Unsupported length for Counter/Timer: %d&quot;, item-&gt;length);</span><br><span class="line">      &#125;</span><br><span class="line">      break;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">        snprintf(resultBuf, bufSize, &quot;UnknownType&quot;);</span><br><span class="line">        s7p_log(&quot;s7_decode_data: Unknown transport size: 0x%02x&quot;, item-&gt;transportSize);</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br><span class="line">return resultBuf;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>IGNORE_WHEN_COPYING_START</p>
<p> content_copy  download </p>
<p> Use code <a target="_blank" rel="noopener" href="https://support.google.com/legal/answer/13505487">with caution</a>.</p>
<p>IGNORE_WHEN_COPYING_END</p>
<p>}</p>
<p>&#x2F;&#x2F; 释放 S7Packet 中动态分配的资源<br>void s7_free_packet(S7Packet *packet) {<br>if (packet) {<br>if (packet-&gt;items) {<br>for (int i &#x3D; 0; i &lt; packet-&gt;itemCount; i++) {<br>if (packet-&gt;items[i].data) {<br>free(packet-&gt;items[i].data);<br>packet-&gt;items[i].data &#x3D; NULL;<br>}<br>}<br>free(packet-&gt;items);<br>packet-&gt;items &#x3D; NULL;<br>}<br>if (packet-&gt;blockData)<br>{<br>free(packet-&gt;blockData);<br>packet-&gt;blockData &#x3D; NULL;<br>}<br>&#x2F;&#x2F;其他需要释放的内存<br>packet-&gt;messageType &#x3D; 0;<br>packet-&gt;functionCode &#x3D; 0;<br>packet-&gt;itemCount &#x3D; 0;<br>packet-&gt;errorClass &#x3D; 0;<br>packet-&gt;errorCode &#x3D; 0;<br>packet-&gt;pduReference &#x3D; 0;<br>packet-&gt;blockType &#x3D; 0;<br>packet-&gt;blockNumber &#x3D; 0;<br>packet-&gt;blockDataLen &#x3D; 0;<br>packet-&gt;method &#x3D; 0;<br>}<br>}</p>
<p>&#x2F;&#x2F; 解析 Read Var 请求  移除static<br>int parse_s7_read_var_request(const unsigned char *param, int paramLen, S7Packet *packet) {<br>s7p_log(“parse_s7_read_var_request called.”);<br>if (!param || !packet) {<br>s7p_log(“parse_s7_read_var_request: NULL parameter(s) received.”);<br>return -1;<br>}<br>S7ReadWriteVarParam *readVarParam &#x3D; (S7ReadWriteVarParam *)param;<br>packet-&gt;functionCode &#x3D; (S7FunctionCode)readVarParam-&gt;functionCode;<br>packet-&gt;itemCount    &#x3D; readVarParam-&gt;itemCount;<br>s7p_log(“parse_s7_read_var_request: functionCode&#x3D;0x%02x, itemCount&#x3D;%d”, packet-&gt;functionCode, packet-&gt;itemCount);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">      packet-&gt;items = (S7Item *)malloc(sizeof(S7Item) * packet-&gt;itemCount);</span><br><span class="line">if (!packet-&gt;items)</span><br><span class="line">&#123;</span><br><span class="line">    s7p_log(&quot;parse_s7_read_var_request: Memory allocation failed for items.&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line">memset(packet-&gt;items, 0, sizeof(S7Item) * packet-&gt;itemCount);</span><br><span class="line"></span><br><span class="line">const unsigned char *itemData = param + sizeof(S7ReadWriteVarParam);</span><br><span class="line">for (int i = 0; i &lt; packet-&gt;itemCount; i++) &#123;</span><br><span class="line">    // 长度检查</span><br><span class="line">    if ((size_t)paramLen &lt; sizeof(S7ReadWriteVarParam) + (i+1)*12) &#123;</span><br><span class="line">        s7p_log(&quot;parse_s7_read_var_request: Parameter length check failed.&quot;);</span><br><span class="line">        s7_free_packet(packet);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    packet-&gt;items[i].syntaxId      = *itemData++;</span><br><span class="line">    packet-&gt;items[i].transportSize = *itemData++;</span><br><span class="line">    packet-&gt;items[i].length        = ntohs(*(uint16_t *)itemData);</span><br><span class="line">    itemData += 2;</span><br><span class="line">    packet-&gt;items[i].area          = *itemData++;</span><br><span class="line">    packet-&gt;items[i].dbNumber      = ntohs(*(uint16_t *)itemData);</span><br><span class="line">    itemData += 2;</span><br><span class="line">    packet-&gt;items[i].startOffset   = ((uint32_t)*itemData &lt;&lt; 16) | ((uint32_t)*(itemData + 1) &lt;&lt; 8) | *(itemData + 2);</span><br><span class="line">    itemData += 3;</span><br><span class="line">    s7p_log(&quot;parse_s7_read_var_request: Item %d - syntaxId: 0x%02x, transportSize: 0x%02x, length: %d, area: 0x%02x, dbNumber: %d, startOffset: %u&quot;,</span><br><span class="line">       i, packet-&gt;items[i].syntaxId, packet-&gt;items[i].transportSize, packet-&gt;items[i].length,</span><br><span class="line">       packet-&gt;items[i].area, packet-&gt;items[i].dbNumber, packet-&gt;items[i].startOffset);</span><br><span class="line">&#125;</span><br><span class="line"> s7p_log(&quot;parse_s7_read_var_request: Successfully parsed Read Var Request.&quot;);</span><br><span class="line">return 0;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>IGNORE_WHEN_COPYING_START</p>
<p> content_copy  download </p>
<p> Use code <a target="_blank" rel="noopener" href="https://support.google.com/legal/answer/13505487">with caution</a>.</p>
<p>IGNORE_WHEN_COPYING_END</p>
<p>}</p>
<p>&#x2F;&#x2F; 解析 Read Var 响应 移除static<br>int parse_s7_read_var_response(const unsigned char *param, int paramLen, const unsigned char *data, int dataLen, S7Packet *packet)<br>{<br>s7p_log(“parse_s7_read_var_response called.”);<br>if (!param || !data || !packet) {<br>s7p_log(“parse_s7_read_var_response: NULL parameter(s) received.”);<br>return -1;<br>}<br>(void)paramLen;<br>S7ReadWriteVarResponse *readVarParam &#x3D; (S7ReadWriteVarResponse *)param;<br>packet-&gt;functionCode &#x3D; (S7FunctionCode)readVarParam-&gt;functionCode;<br>packet-&gt;itemCount    &#x3D; readVarParam-&gt;itemCount;<br>packet-&gt;errorClass &#x3D; (S7ErrorCode)param[2];<br>packet-&gt;errorCode  &#x3D; (S7ErrorCode)param[3];<br>s7p_log(“parse_s7_read_var_response: functionCode&#x3D;0x%02x, itemCount&#x3D;%d, errorClass&#x3D;0x%02x, errorCode&#x3D;0x%02x”,<br>packet-&gt;functionCode, packet-&gt;itemCount, packet-&gt;errorClass, packet-&gt;errorCode);<br>packet-&gt;items &#x3D; (S7Item *)malloc(sizeof(S7Item) * packet-&gt;itemCount);<br>if (!packet-&gt;items)<br>{<br>s7p_log(“parse_s7_read_var_response: Memory allocation failed for items.”);<br>return -1;<br>}<br>memset(packet-&gt;items, 0, sizeof(S7Item) * packet-&gt;itemCount);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">      // 如果有错误，无需解析 item data</span><br><span class="line">if (packet-&gt;errorClass != S7_ERR_NO_ERROR || packet-&gt;errorCode != S7_ERR_NO_ERROR) &#123;</span><br><span class="line">    s7p_log(&quot;parse_s7_read_var_response: Error detected. Skipping item data parsing.&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const unsigned char *itemData = data;</span><br><span class="line">for (int i = 0; i &lt; packet-&gt;itemCount; i++)</span><br><span class="line">&#123;</span><br><span class="line">    packet-&gt;items[i].returnCode = *itemData++;</span><br><span class="line">    s7p_log(&quot;parse_s7_read_var_response: Item %d - returnCode: 0x%02x&quot;, i, packet-&gt;items[i].returnCode);</span><br><span class="line">    if (packet-&gt;items[i].returnCode != 0xff) // 0xff == 无错误</span><br><span class="line">    &#123;</span><br><span class="line">        itemData += 2; // 跳过 length 字段</span><br><span class="line">        s7p_log(&quot;parse_s7_read_var_response: Item %d - Non-0xff return code. Skipping data.&quot;, i);</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    packet-&gt;items[i].transportSize = *itemData++;</span><br><span class="line">    packet-&gt;items[i].length = ntohs(*(uint16_t *)itemData);</span><br><span class="line">    itemData += 2;</span><br><span class="line">    packet-&gt;items[i].syntaxId = 0x12; // S7ANY</span><br><span class="line">     s7p_log(&quot;parse_s7_read_var_response: Item %d - transportSize: 0x%02x, length: %d&quot;,</span><br><span class="line">           i, packet-&gt;items[i].transportSize, packet-&gt;items[i].length);</span><br><span class="line"></span><br><span class="line">    // 计算 data 长度 (bytes)</span><br><span class="line">    uint16_t dataLengthBytes;</span><br><span class="line">    if (packet-&gt;items[i].transportSize == 0x01) &#123; // BOOL</span><br><span class="line">        dataLengthBytes = (packet-&gt;items[i].length + 7) / 8;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dataLengthBytes = packet-&gt;items[i].length;</span><br><span class="line">    &#125;</span><br><span class="line">    packet-&gt;items[i].dataLengthBytes = dataLengthBytes;</span><br><span class="line"></span><br><span class="line">    // 分配内存并复制 item data</span><br><span class="line">    if (dataLengthBytes &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        packet-&gt;items[i].data = (uint8_t*)malloc(dataLengthBytes);</span><br><span class="line">        if (!packet-&gt;items[i].data) &#123;</span><br><span class="line">            s7p_log(&quot;parse_s7_read_var_response: Memory allocation failed for item data.&quot;);</span><br><span class="line">            s7_free_packet(packet);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        // data section 长度检查</span><br><span class="line">        if ((itemData + dataLengthBytes) &gt; (data + dataLen)) &#123;</span><br><span class="line">             s7p_log(&quot;parse_s7_read_var_response: Data length check failed.  Not enough data in packet.&quot;);</span><br><span class="line">            s7_free_packet(packet);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        memcpy(packet-&gt;items[i].data, itemData, dataLengthBytes);</span><br><span class="line">         s7p_log(&quot;parse_s7_read_var_response: Item %d - Copied %d bytes of data.&quot;, i, dataLengthBytes);</span><br><span class="line">        itemData += dataLengthBytes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> s7p_log(&quot;parse_s7_read_var_response: Successfully parsed Read Var Response.&quot;);</span><br><span class="line">return 0;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>IGNORE_WHEN_COPYING_START</p>
<p> content_copy  download </p>
<p> Use code <a target="_blank" rel="noopener" href="https://support.google.com/legal/answer/13505487">with caution</a>.</p>
<p>IGNORE_WHEN_COPYING_END</p>
<p>}</p>
<p>&#x2F;&#x2F; 解析 Write Var 请求 移除static<br>int parse_s7_write_var_request(const unsigned char *param, int paramLen, S7Packet *packet) {<br>s7p_log(“parse_s7_write_var_request called.”);<br>if (!param || !packet) {<br>s7p_log(“parse_s7_write_var_request: NULL parameter(s) received.”);<br>return -1;<br>}<br>S7ReadWriteVarParam *writeVarParam &#x3D; (S7ReadWriteVarParam *)param;<br>packet-&gt;functionCode &#x3D; (S7FunctionCode)writeVarParam-&gt;functionCode;<br>packet-&gt;itemCount    &#x3D; writeVarParam-&gt;itemCount;<br>s7p_log(“parse_s7_write_var_request: functionCode&#x3D;0x%02x, itemCount&#x3D;%d”, packet-&gt;functionCode, packet-&gt;itemCount);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">      packet-&gt;items = (S7Item *)malloc(sizeof(S7Item) * packet-&gt;itemCount);</span><br><span class="line">if (!packet-&gt;items)</span><br><span class="line">&#123;</span><br><span class="line">    s7p_log(&quot;parse_s7_write_var_request: Memory allocation failed for items.&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">memset(packet-&gt;items, 0, sizeof(S7Item) * packet-&gt;itemCount);</span><br><span class="line"></span><br><span class="line">const unsigned char *itemData = param + sizeof(S7ReadWriteVarParam);</span><br><span class="line">for (int i = 0; i &lt; packet-&gt;itemCount; i++) &#123;</span><br><span class="line">    // 长度检查</span><br><span class="line">    if ((size_t)paramLen &lt; sizeof(S7ReadWriteVarParam) + (i+1)*12)</span><br><span class="line">    &#123;</span><br><span class="line">        s7p_log(&quot;parse_s7_write_var_request: Parameter length check failed.&quot;);</span><br><span class="line">        s7_free_packet(packet);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    packet-&gt;items[i].syntaxId      = *itemData++;</span><br><span class="line">    packet-&gt;items[i].transportSize = *itemData++;</span><br><span class="line">    packet-&gt;items[i].length        = ntohs(*(uint16_t *)itemData);</span><br><span class="line">    itemData += 2;</span><br><span class="line">    packet-&gt;items[i].area          = *itemData++;</span><br><span class="line">    packet-&gt;items[i].dbNumber      = ntohs(*(uint16_t *)itemData);</span><br><span class="line">    itemData += 2;</span><br><span class="line">    packet-&gt;items[i].startOffset   = ((uint32_t)*itemData &lt;&lt; 16) | ((uint32_t)*(itemData + 1) &lt;&lt; 8) | *(itemData + 2);</span><br><span class="line">    itemData += 3;</span><br><span class="line">     s7p_log(&quot;parse_s7_write_var_request: Item %d - syntaxId: 0x%02x, transportSize: 0x%02x, length: %d, area: 0x%02x, dbNumber: %d, startOffset: %u&quot;,</span><br><span class="line">        i, packet-&gt;items[i].syntaxId, packet-&gt;items[i].transportSize, packet-&gt;items[i].length,</span><br><span class="line">        packet-&gt;items[i].area, packet-&gt;items[i].dbNumber, packet-&gt;items[i].startOffset);</span><br><span class="line">&#125;</span><br><span class="line">s7p_log(&quot;parse_s7_write_var_request: Successfully parsed Write Var Request.&quot;);</span><br><span class="line">return 0;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>IGNORE_WHEN_COPYING_START</p>
<p> content_copy  download </p>
<p> Use code <a target="_blank" rel="noopener" href="https://support.google.com/legal/answer/13505487">with caution</a>.</p>
<p>IGNORE_WHEN_COPYING_END</p>
<p>}</p>
<p>&#x2F;&#x2F; 解析 Write Var 响应 移除static<br>int parse_s7_write_var_response(const unsigned char* param, int paramLen, const unsigned char* data, int dataLen, S7Packet* packet)<br>{<br>s7p_log(“parse_s7_write_var_response called.”);<br>if (!param || !packet) {<br>s7p_log(“parse_s7_write_var_response: NULL parameter(s) received.”);<br>return -1;<br>}<br>(void)data;<br>(void)dataLen;<br>(void)paramLen;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">      S7ReadWriteVarResponse* writeResp = (S7ReadWriteVarResponse*)param;</span><br><span class="line">packet-&gt;functionCode = (S7FunctionCode)writeResp-&gt;functionCode;</span><br><span class="line">packet-&gt;itemCount = writeResp-&gt;itemCount;</span><br><span class="line"> s7p_log(&quot;parse_s7_write_var_response: functionCode=0x%02x, itemCount=%d&quot;, packet-&gt;functionCode, packet-&gt;itemCount);</span><br><span class="line"></span><br><span class="line">packet-&gt;errorClass = (S7ErrorCode)param[2];</span><br><span class="line">packet-&gt;errorCode  = (S7ErrorCode)param[3];</span><br><span class="line">s7p_log(&quot;parse_s7_write_var_response: errorClass=0x%02x, errorCode=0x%02x&quot;, packet-&gt;errorClass, packet-&gt;errorCode);</span><br><span class="line"></span><br><span class="line">packet-&gt;items = (S7Item*)malloc(sizeof(S7Item) * packet-&gt;itemCount);</span><br><span class="line">if (!packet-&gt;items) &#123;</span><br><span class="line">     s7p_log(&quot;parse_s7_write_var_response: Memory allocation failed for items.&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line">memset(packet-&gt;items, 0, sizeof(S7Item) * packet-&gt;itemCount);</span><br><span class="line"></span><br><span class="line">const unsigned char* itemData = param + sizeof(S7ReadWriteVarResponse);</span><br><span class="line">for (int i = 0; i &lt; packet-&gt;itemCount; i++) &#123;</span><br><span class="line">    // 长度检查 (return code 是 1 byte)</span><br><span class="line">    if ((size_t)paramLen &lt; sizeof(S7ReadWriteVarResponse) + (i + 1) * sizeof(uint8_t))</span><br><span class="line">    &#123;</span><br><span class="line">        s7p_log(&quot;parse_s7_write_var_response: Parameter length check failed.&quot;);</span><br><span class="line">        s7_free_packet(packet);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    packet-&gt;items[i].returnCode = *itemData++;</span><br><span class="line">    s7p_log(&quot;parse_s7_write_var_response: Item %d - returnCode: 0x%02x&quot;, i, packet-&gt;items[i].returnCode);</span><br><span class="line">&#125;</span><br><span class="line">s7p_log(&quot;parse_s7_write_var_response: Successfully parsed Write Var Response.&quot;);</span><br><span class="line">return 0;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>IGNORE_WHEN_COPYING_START</p>
<p> content_copy  download </p>
<p> Use code <a target="_blank" rel="noopener" href="https://support.google.com/legal/answer/13505487">with caution</a>.</p>
<p>IGNORE_WHEN_COPYING_END</p>
<p>}</p>
<p>&#x2F;&#x2F; 解析 PLC Control (Start&#x2F;Stop) 请求  移除static<br>int parse_s7_plc_control_request(const unsigned char *param, int paramLen, S7Packet *packet)<br>{<br>s7p_log(“parse_s7_plc_control_request called.”);<br>if (!param || !packet) {<br>s7p_log(“parse_s7_plc_control_request: NULL parameter(s) received.”);<br>return -1;<br>}<br>S7PLCControlParam *plcControlParam &#x3D; (S7PLCControlParam *)param;<br>&#x2F;&#x2F; 长度检查<br>if ((size_t)paramLen &lt; sizeof(S7PLCControlParam)) {<br>s7p_log(“parse_s7_plc_control_request: Parameter length check failed.”);<br>return -1;<br>}<br>packet-&gt;functionCode &#x3D; (S7FunctionCode)plcControlParam-&gt;functionCode;<br>packet-&gt;method &#x3D; plcControlParam-&gt;method;<br>s7p_log(“parse_s7_plc_control_request: functionCode&#x3D;0x%02x, method&#x3D;0x%02x”, packet-&gt;functionCode, packet-&gt;method);<br>s7p_log(“parse_s7_plc_control_request: Successfully parsed PLC Control Request.”);<br>return 0;<br>}</p>
<p>&#x2F;&#x2F; 解析 PLC Control 响应 移除static<br>int parse_s7_plc_control_response(const unsigned char* param, int paramLen, S7Packet* packet) {<br>s7p_log(“parse_s7_plc_control_response called.”);<br>if (!param || !packet) {<br>s7p_log(“parse_s7_plc_control_response: NULL parameter(s) received.”);<br>return -1;<br>}<br>(void)paramLen;<br>S7PLCControlResponse* plcControlResp &#x3D; (S7PLCControlResponse*)param;<br>packet-&gt;functionCode &#x3D; (S7FunctionCode)plcControlResp-&gt;functionCode;<br>s7p_log(“parse_s7_plc_control_response: functionCode&#x3D;0x%02x”, packet-&gt;functionCode);<br>s7p_log(“parse_s7_plc_control_response: Successfully parsed PLC Control Response”);<br>return 0;<br>}</p>
<p>&#x2F;&#x2F; 解析 S7 Request Download 请求 移除static<br>int parse_s7_req_download_request(const unsigned char <em>param, int paramLen, S7Packet *packet)<br>{<br>s7p_log(“parse_s7_req_download_request called.”);<br>if (!param || !packet) {<br>s7p_log(“parse_s7_req_download_request: NULL parameter(s) received.”);<br>return -1;<br>}<br>S7ReqDownloadParam* reqDownloadParam &#x3D; (S7ReqDownloadParam</em>)param;<br>&#x2F;&#x2F; 长度检查<br>if ((size_t)paramLen &lt; sizeof(S7ReqDownloadParam)) {<br>s7p_log(“parse_s7_req_download_request: Parameter length check failed.”);<br>return -1;<br>}<br>packet-&gt;functionCode &#x3D; (S7FunctionCode)reqDownloadParam-&gt;functionCode; &#x2F;&#x2F; 使用枚举<br>packet-&gt;blockType &#x3D; reqDownloadParam-&gt;blockType;<br>packet-&gt;blockNumber &#x3D; ntohl(reqDownloadParam-&gt;blockNumber);<br>s7p_log(“parse_s7_req_download_request: functionCode&#x3D;0x%02x, blockType&#x3D;%c, blockNumber&#x3D;%u”,<br>packet-&gt;functionCode, packet-&gt;blockType, packet-&gt;blockNumber);<br>s7p_log(“parse_s7_req_download_request: Successfully parsed Request Download Request.”);<br>return 0;<br>}</p>
<p>&#x2F;&#x2F; 解析 S7 Download Block 请求 移除static<br>int parse_s7_download_block_request(const unsigned char <em>param, int paramLen,  S7Packet</em> packet)<br>{<br>s7p_log(“parse_s7_download_block_request called.”);<br>if (!param || !packet) {<br>s7p_log(“parse_s7_download_block_request: NULL parameter(s) received.”);<br>return -1;<br>}<br>(void)paramLen; &#x2F;&#x2F;避免未使用参数警告<br>S7DownloadBlockParam* downloadBlockParam &#x3D; (S7DownloadBlockParam*)param;<br>packet-&gt;functionCode &#x3D; (S7FunctionCode)downloadBlockParam-&gt;functionCode; &#x2F;&#x2F; 使用枚举<br>s7p_log(“parse_s7_download_block_request: functionCode&#x3D;0x%02x”, packet-&gt;functionCode);<br>s7p_log(“parse_s7_download_block_request: Successfully parsed Download Block Request.”);<br>return 0;<br>}</p>
<p>&#x2F;&#x2F; 解析 S7 Upload 请求 移除static<br>int parse_s7_upload_request(const unsigned char* param, int paramLen, S7Packet* packet)<br>{<br>s7p_log(“parse_s7_upload_request called.”);<br>if (!param || !packet) {<br>s7p_log(“parse_s7_upload_request: NULL parameter(s) received.”);<br>return -1;<br>}<br>(void)paramLen; &#x2F;&#x2F;避免未使用参数警告<br>S7DownloadBlockParam* uploadBlockParam &#x3D; (S7DownloadBlockParam*)param;  &#x2F;&#x2F; Re-use structure<br>packet-&gt;functionCode &#x3D; (S7FunctionCode)uploadBlockParam-&gt;functionCode; &#x2F;&#x2F; 使用枚举<br>s7p_log(“parse_s7_upload_request: functionCode&#x3D;0x%02x”, packet-&gt;functionCode);<br>s7p_log(“parse_s7_upload_request: Successfully parsed Upload Request.”);<br>return 0;<br>}</p>
<p>&#x2F;&#x2F; 解析 S7 Download&#x2F;Upload 响应 移除static<br>int parse_s7_download_upload_response(const unsigned char <em>param, int paramLen, S7Packet *packet)<br>{<br>s7p_log(“parse_s7_download_upload_response called.”);<br>if (!param || !packet) {<br>s7p_log(“parse_s7_download_upload_response: NULL parameter(s) received.”);<br>return -1;<br>}<br>(void)paramLen; &#x2F;&#x2F; 避免未使用参数警告<br>S7DownloadUploadResponse* downloadUploadResp &#x3D; (S7DownloadUploadResponse</em>)param;<br>packet-&gt;functionCode &#x3D; (S7FunctionCode)downloadUploadResp-&gt;functionCode; &#x2F;&#x2F; 使用枚举<br>s7p_log(“parse_s7_download_upload_response: functionCode&#x3D;0x%02x”, packet-&gt;functionCode);<br>s7p_log(“parse_s7_download_upload_response: Successfully parsed Download&#x2F;Upload Response.”);<br>return 0;<br>}</p>
<p>&#x2F;&#x2F; 辅助函数：查找解析函数 (请求)<br>S7ParamParserReq find_parser_req(uint8_t functionCode) {<br>for (int i &#x3D; 0; s7_param_parsers_req[i].parser !&#x3D; NULL; i++) {<br>if (s7_param_parsers_req[i].functionCode &#x3D;&#x3D; functionCode) {<br>return s7_param_parsers_req[i].parser;<br>}<br>}<br>s7p_log(“find_parser_req: No parser found for function code 0x%02x”, functionCode);<br>return NULL;<br>}</p>
<p>&#x2F;&#x2F; 辅助函数：查找解析函数 (响应)<br>void *find_parser_res(uint8_t functionCode, int *type) {<br>for (int i &#x3D; 0; s7_param_parsers_res[i].parser !&#x3D; NULL; i++) {<br>if (s7_param_parsers_res[i].functionCode &#x3D;&#x3D; functionCode) {<br>*type &#x3D; s7_param_parsers_res[i].type;<br>return s7_param_parsers_res[i].parser;<br>}<br>}<br>*type &#x3D; -1;<br>s7p_log(“find_parser_res: No parser found for function code 0x%02x”, functionCode);<br>return NULL;<br>}</p>
<p>&#x2F;&#x2F;S7 协议解析的入口函数<br>int s7_protocol_parse(const unsigned char *data, int len, S7Packet *packet) {<br>s7p_log(“s7_protocol_parse called.  Data length: %d”, len);<br>if (!data || !packet) {<br>s7p_log(“s7_protocol_parse: NULL parameter(s) received.”);<br>return -1;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">      // 1. 解析 TPKT 头</span><br><span class="line">if ((size_t)len &lt; sizeof(TPKTHeader))  &#123;</span><br><span class="line">    s7p_log(&quot;s7_protocol_parse: Packet too short for TPKT header.&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TPKTHeader *tpkt = (TPKTHeader *)data;</span><br><span class="line">if (tpkt-&gt;version != 3) &#123;</span><br><span class="line">    s7p_log(&quot;s7_protocol_parse: Invalid TPKT version: %d&quot;, tpkt-&gt;version);</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line">s7p_log(&quot;s7_protocol_parse: TPKT Version: %d&quot;, tpkt-&gt;version);</span><br><span class="line"></span><br><span class="line">int tpktLength = ntohs(tpkt-&gt;length);</span><br><span class="line">s7p_log(&quot;s7_protocol_parse: TPKT Length (packet length): %d&quot;, tpktLength);</span><br><span class="line">if (len &lt; tpktLength) &#123;</span><br><span class="line">    s7p_log(&quot;s7_protocol_parse: Packet length (%d) less than TPKT length (%d).&quot;, len, tpktLength);</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 解析 COTP 头</span><br><span class="line">const unsigned char *cotpData = data + sizeof(TPKTHeader);</span><br><span class="line">COTPHeader *cotp = (COTPHeader *)cotpData;</span><br><span class="line">int cotpLength = cotp-&gt;length + 1; // COTP 长度字段不包括自身</span><br><span class="line">s7p_log(&quot;s7_protocol_parse: COTP Length: %d,  COTP PDU Type: 0x%02x&quot;, cotpLength, cotp-&gt;pduType);</span><br><span class="line"></span><br><span class="line">if (cotp-&gt;pduType != 0xF0 &amp;&amp; cotp-&gt;pduType != 0xE0) &#123;  // 0xF0: DT, 0xE0: CR</span><br><span class="line">    s7p_log(&quot;s7_protocol_parse: Unsupported COTP PDU type: 0x%02x&quot;, cotp-&gt;pduType);</span><br><span class="line">    return -1; // 不是支持的 COTP PDU 类型</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (cotp-&gt;pduType == 0xE0) &#123;</span><br><span class="line">    s7p_log(&quot;s7_protocol_parse: COTP CR (Connection Request) detected.  Returning.&quot;);</span><br><span class="line">    packet-&gt;functionCode = S7_FUNCTION_SETUP_COMM; // COTP CR (Setup Communication)</span><br><span class="line">    return 0; //  COTP CR 是连接请求，所以我们在这里停止解析。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3. 解析 S7 头</span><br><span class="line">const unsigned char *s7Data = cotpData + cotpLength;</span><br><span class="line">int s7DataLength = tpktLength - sizeof(TPKTHeader) - cotpLength;</span><br><span class="line">s7p_log(&quot;s7_protocol_parse: S7 Data Length: %d&quot;, s7DataLength);</span><br><span class="line">if ((size_t)s7DataLength &lt; sizeof(S7Header))</span><br><span class="line">&#123;</span><br><span class="line">    s7p_log(&quot;s7_protocol_parse: Remaining data too short for S7 header.&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">S7Header *s7Header = (S7Header *)s7Data;</span><br><span class="line">if (s7Header-&gt;protocolId != 0x32)</span><br><span class="line">&#123;</span><br><span class="line">    s7p_log(&quot;s7_protocol_parse: Invalid S7 protocol ID: 0x%02x&quot;, s7Header-&gt;protocolId);</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line">packet-&gt;messageType = (S7MessageType)s7Header-&gt;messageType;   // 使用枚举</span><br><span class="line">packet-&gt;pduReference = ntohs(s7Header-&gt;pduReference);</span><br><span class="line">packet-&gt;errorClass = (S7ErrorCode)s7Header-&gt;errorClass;       // 使用枚举</span><br><span class="line">packet-&gt;errorCode = (S7ErrorCode)s7Header-&gt;errorCode;        // 使用枚举</span><br><span class="line"></span><br><span class="line">s7p_log(&quot;s7_protocol_parse: S7 Protocol ID: 0x%02x, Message Type: 0x%02x, PDU Ref: %d, Error Class: 0x%02x, Error Code: 0x%02x&quot;,</span><br><span class="line">        s7Header-&gt;protocolId, packet-&gt;messageType, packet-&gt;pduReference, packet-&gt;errorClass, packet-&gt;errorCode);</span><br><span class="line"></span><br><span class="line">const unsigned char *s7Param = s7Data + sizeof(S7Header);</span><br><span class="line">int s7ParamLength = ntohs(s7Header-&gt;paramLength);</span><br><span class="line">const unsigned char *s7DataItem = s7Data + sizeof(S7Header) + s7ParamLength;</span><br><span class="line">int s7DataLen = ntohs(s7Header-&gt;dataLength);</span><br><span class="line">s7p_log(&quot;s7_protocol_parse: S7 Param Length: %d, S7 Data Length: %d&quot;, s7ParamLength, s7DataLen);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 4. 解析 S7 Parameter 和 Data (使用查找表)</span><br><span class="line">if (s7Header-&gt;messageType == S7_MESSAGE_TYPE_JOB) &#123; // Job</span><br><span class="line">    s7p_log(&quot;s7_protocol_parse: Message Type: Job Request&quot;);</span><br><span class="line">    S7ParamParserReq parser = find_parser_req(s7Param[0]); // param 的第一个字节是 functionCode</span><br><span class="line">    if (parser) &#123;</span><br><span class="line">        if (parser(s7Param, s7ParamLength, packet) != 0) &#123;</span><br><span class="line">            s7p_log(&quot;s7_protocol_parse:  S7 parameter parsing failed (Job Request).&quot;);</span><br><span class="line">            s7_free_packet(packet);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        s7p_log(&quot;s7_protocol_parse:  Unknown S7 function code in Job Request: 0x%02x&quot;, s7Param[0]);</span><br><span class="line">        return -1; // 未知 function code</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">else if (s7Header-&gt;messageType == S7_MESSAGE_TYPE_ACK_DATA) &#123; // Ack-Data</span><br><span class="line">    s7p_log(&quot;s7_protocol_parse: Message Type: Ack-Data Response&quot;);</span><br><span class="line">    int parserType;</span><br><span class="line">    void *parser = find_parser_res(s7Param[0], &amp;parserType); //param的第一个字节是functionCode</span><br><span class="line">    if(parser) &#123;</span><br><span class="line">        if (parserType == 0) &#123; // S7ParamParserRes (有 data)</span><br><span class="line">            s7p_log(&quot;s7_protocol_parse:  Calling Ack-Data response parser (with data).&quot;);</span><br><span class="line">            S7ParamParserRes resParser = (S7ParamParserRes)parser;</span><br><span class="line">            if (resParser(s7Param, s7ParamLength, s7DataItem, s7DataLen, packet) != 0) &#123;</span><br><span class="line">                 s7p_log(&quot;s7_protocol_parse:  S7 parameter parsing failed (Ack-Data response).&quot;);</span><br><span class="line">                s7_free_packet(packet);</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (parserType == 1) &#123; // S7ParamParserSimpleRes (无 data)</span><br><span class="line">             s7p_log(&quot;s7_protocol_parse:  Calling Ack-Data response parser (no data).&quot;);</span><br><span class="line">            S7ParamParserSimpleRes simpleParser = (S7ParamParserSimpleRes)parser;</span><br><span class="line">            if (simpleParser(s7Param, s7ParamLength, packet) != 0) &#123;</span><br><span class="line">                s7p_log(&quot;s7_protocol_parse:  S7 parameter parsing failed (Ack-Data response).&quot;);</span><br><span class="line">                s7_free_packet(packet);</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">             s7p_log(&quot;s7_protocol_parse:  Invalid parser type for Ack-Data response: %d&quot;, parserType);</span><br><span class="line">            s7_free_packet(packet);</span><br><span class="line">            return -1; // 无效 parser 类型</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        s7p_log(&quot;s7_protocol_parse:  Unknown S7 function code in Ack-Data response: 0x%02x&quot;, s7Param[0]);</span><br><span class="line">        return -1; // 未知 function code</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    s7p_log(&quot;s7_protocol_parse:  Unsupported S7 message type: 0x%02x&quot;, s7Header-&gt;messageType);</span><br><span class="line">    return -1; // 不是 Job 或 Ack-Data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果 dataLen &gt; 0 且是 Download Block 请求, 保存 block 数据</span><br><span class="line">if (s7DataLen &gt; 0 &amp;&amp; packet-&gt;functionCode == S7_FUNCTION_DOWNLOAD_BLOCK)</span><br><span class="line">&#123;</span><br><span class="line">    s7p_log(&quot;s7_protocol_parse:  Downloading block data. Length: %d&quot;, s7DataLen);</span><br><span class="line">    packet-&gt;blockData = (uint8_t*)malloc(s7DataLen);</span><br><span class="line">    if (!packet-&gt;blockData)</span><br><span class="line">    &#123;</span><br><span class="line">        s7p_log(&quot;s7_protocol_parse: Memory allocation failed for block data.&quot;);</span><br><span class="line">        s7_free_packet(packet);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    memcpy(packet-&gt;blockData, s7DataItem, s7DataLen);</span><br><span class="line">    packet-&gt;blockDataLen = s7DataLen;</span><br><span class="line">     s7p_log(&quot;s7_protocol_parse:  Copied %d bytes of block data.&quot;, s7DataLen);</span><br><span class="line">&#125;</span><br><span class="line"> s7p_log(&quot;s7_protocol_parse: S7 parsing complete.&quot;);</span><br><span class="line">return 0; // 成功</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>IGNORE_WHEN_COPYING_START</p>
<p> content_copy  download </p>
<p> Use code <a target="_blank" rel="noopener" href="https://support.google.com/legal/answer/13505487">with caution</a>.</p>
<p>IGNORE_WHEN_COPYING_END</p>
<p>}</p>
<p>void s7_protocol_cleanup() {<br>&#x2F;&#x2F; 清理逻辑 (如果有的话)<br>s7p_log(“s7_protocol_cleanup called.”);<br>}</p>
<p>int s7_protocol_init() {<br>&#x2F;&#x2F; 初始化逻辑 (如果有的话)<br>s7p_log(“s7_protocol_init called.”);<br>return 0;<br>}</p>
<p>s7-protocol.h:<br>&#x2F;&#x2F;s7-protocol.h<br>#ifndef S7_PROTOCOL_H<br>#define S7_PROTOCOL_H</p>
<p>#include &lt;stdint.h&gt;<br>#include &lt;stdbool.h&gt;<br>#include &lt;stddef.h&gt;  &#x2F;&#x2F; 包含 size_t 的定义</p>
<p>&#x2F;&#x2F; S7 错误代码枚举<br>typedef enum {<br>S7_ERR_NO_ERROR      &#x3D; 0x00,<br>&#x2F;&#x2F; … (其他错误代码)<br>S7_ERR_WRONG_PDU     &#x3D; 0x07,<br>S7_ERR_INVALID_BLOCK_LENGTH&#x3D;0x0a,<br>S7_ERR_INVALID_DATA_SIZE&#x3D;0xd4,<br>S7_ERR_FUNCTION_NOT_AVAIL&#x3D;0xd6,<br>S7_ERR_INSUFFICIENT_RESOURCES&#x3D;0xd8<br>} S7ErrorCode;</p>
<p>&#x2F;&#x2F; S7 消息类型枚举<br>typedef enum {<br>S7_MESSAGE_TYPE_JOB       &#x3D; 0x01,<br>S7_MESSAGE_TYPE_ACK       &#x3D; 0x02,<br>S7_MESSAGE_TYPE_ACK_DATA  &#x3D; 0x03,<br>S7_MESSAGE_TYPE_USERDATA  &#x3D; 0x07<br>} S7MessageType;</p>
<p>&#x2F;&#x2F; S7 功能码枚举<br>typedef enum {<br>S7_FUNCTION_READ_VAR          &#x3D; 0x04,<br>S7_FUNCTION_WRITE_VAR         &#x3D; 0x05,<br>S7_FUNCTION_REQ_DOWNLOAD      &#x3D; 0x1A,<br>S7_FUNCTION_DOWNLOAD_BLOCK    &#x3D; 0x1B,<br>S7_FUNCTION_DOWNLOAD_ENDED    &#x3D; 0x1C,<br>S7_FUNCTION_START_UPLOAD      &#x3D; 0x1D,<br>S7_FUNCTION_UPLOAD            &#x3D; 0x1E,<br>S7_FUNCTION_END_UPLOAD        &#x3D; 0x1F,<br>S7_FUNCTION_PLC_STOP          &#x3D; 0x29,<br>S7_FUNCTION_PLC_START         &#x3D; 0x28,<br>S7_FUNCTION_SETUP_COMM        &#x3D; 0xF0  &#x2F;&#x2F; 特殊情况：COTP 连接请求<br>} S7FunctionCode;</p>
<p>&#x2F;&#x2F; 表示单个 S7 项的结构体 (用于读&#x2F;写操作)<br>typedef struct {<br>uint8_t  syntaxId;      &#x2F;&#x2F; 0x10 (S7ANY) 或 0x12 (用于响应)<br>uint8_t  transportSize; &#x2F;&#x2F; 数据类型 (例如，BOOL, BYTE, WORD, REAL)<br>uint16_t length;        &#x2F;&#x2F; 长度，以位 (BOOL) 或字节为单位<br>uint8_t  area;          &#x2F;&#x2F; 内存区域 (例如，I, Q, M, DB, CT, TM)<br>uint16_t dbNumber;      &#x2F;&#x2F; 数据块编号 (如果适用)<br>uint32_t startOffset;   &#x2F;&#x2F; 字节地址 * 8 + 位偏移<br>uint8_t  returnCode;    &#x2F;&#x2F; 0xFF 表示成功 (仅限响应)<br>uint8_t  *data;          &#x2F;&#x2F; 指向数据缓冲区的指针<br>uint16_t dataLengthBytes;&#x2F;&#x2F; 数据的实际长度（以字节为单位）<br>} S7Item;</p>
<p>&#x2F;&#x2F; 表示已解析的 S7 数据包的结构体<br>typedef struct {<br>S7MessageType  messageType;     &#x2F;&#x2F; Job, Ack, Ack-Data, UserData<br>S7FunctionCode functionCode;    &#x2F;&#x2F; ReadVar, WriteVar, PLCStop 等<br>int            itemCount;      &#x2F;&#x2F; 读&#x2F;写变量请求&#x2F;响应中的项数<br>S7Item        *items;          &#x2F;&#x2F; S7 项的数组 (用于读&#x2F;写请求&#x2F;响应)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">      uint8_t        blockType;       // &#x27;B&#x27;, &#x27;F&#x27;, &#x27;O&#x27; 等 (用于块操作)</span><br><span class="line">uint32_t       blockNumber;     // 下载/上传的块编号</span><br><span class="line">uint8_t       *blockData;      // 指向块数据的指针 (下载块请求)</span><br><span class="line">size_t         blockDataLen;   // blockData 的长度</span><br><span class="line"></span><br><span class="line">S7ErrorCode   errorClass;      // S7 错误类</span><br><span class="line">S7ErrorCode   errorCode;       // S7 错误代码</span><br><span class="line"></span><br><span class="line">uint16_t       pduReference;</span><br><span class="line">uint8_t        method;   //0x09 停止; 0x04/0x05 启动</span><br><span class="line">// ... 其他相关字段</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>IGNORE_WHEN_COPYING_START</p>
<p> content_copy  download </p>
<p> Use code <a target="_blank" rel="noopener" href="https://support.google.com/legal/answer/13505487">with caution</a>.</p>
<p>IGNORE_WHEN_COPYING_END</p>
<p>} S7Packet;</p>
<p>&#x2F;&#x2F; 函数原型<br>int  s7_protocol_init();<br>int  s7_protocol_parse(const unsigned char *data, int len, S7Packet *packet);<br>void s7_protocol_cleanup();<br>void s7_free_packet(S7Packet <em>packet);<br>char</em> s7_decode_data(const S7Item *item, char * resultBuf, size_t bufSize);</p>
<p>#include &lt;string.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;arpa&#x2F;inet.h&gt;<br>#include &lt;math.h&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;stdarg.h&gt;<br>#include &lt;time.h&gt;</p>
<p>&#x2F;&#x2F; 函数指针类型 (请求)：参数为 param, paramLen, packet<br>typedef int (*S7ParamParserReq)(const unsigned char *param, int paramLen, S7Packet *packet);</p>
<p>&#x2F;&#x2F; 函数指针类型 (响应)：参数为 param, paramLen, data, dataLen, packet<br>typedef int (*S7ParamParserRes)(const unsigned char *param, int paramLen, const unsigned char *data, int dataLen, S7Packet *packet);</p>
<p>&#x2F;&#x2F; 函数指针类型 (无 data 的响应): param, paramLen, packet<br>typedef int (*S7ParamParserSimpleRes)(const unsigned char *param, int paramLen, S7Packet *packet);</p>
<p>&#x2F;&#x2F; 前向声明解析函数<br>int parse_s7_read_var_request(const unsigned char *param, int paramLen, S7Packet *packet);<br>int parse_s7_read_var_response(const unsigned char *param, int paramLen, const unsigned char *data, int dataLen, S7Packet <em>packet);<br>int parse_s7_write_var_request(const unsigned char *param, int paramLen,  S7Packet *packet);<br>int parse_s7_write_var_response(const unsigned char* param, int paramLen, const unsigned char* data, int dataLen, S7Packet</em> packet);<br>int parse_s7_plc_control_request(const unsigned char <em>param, int paramLen, S7Packet *packet);<br>int parse_s7_plc_control_response(const unsigned char* param, int paramLen, S7Packet</em> packet);<br>int parse_s7_req_download_request(const unsigned char <em>param, int paramLen, S7Packet *packet);<br>int parse_s7_download_block_request(const unsigned char *param, int paramLen,  S7Packet* packet);<br>int parse_s7_upload_request(const unsigned char* param, int paramLen, S7Packet</em> packet);<br>int parse_s7_download_upload_response(const unsigned char *param, int paramLen, S7Packet *packet);</p>
<p>&#x2F;&#x2F; S7 参数解析函数查找表 (Job Requests)<br>static const struct {<br>uint8_t           functionCode;<br>S7ParamParserReq parser;<br>} s7_param_parsers_req[] &#x3D; {<br>{S7_FUNCTION_READ_VAR,      parse_s7_read_var_request},<br>{S7_FUNCTION_WRITE_VAR,     parse_s7_write_var_request},<br>{S7_FUNCTION_PLC_STOP,      parse_s7_plc_control_request},<br>{S7_FUNCTION_PLC_START,     parse_s7_plc_control_request},<br>{S7_FUNCTION_REQ_DOWNLOAD,  parse_s7_req_download_request},<br>{S7_FUNCTION_DOWNLOAD_BLOCK, parse_s7_download_block_request},<br>{S7_FUNCTION_START_UPLOAD,  parse_s7_upload_request},<br>{0, NULL} &#x2F;&#x2F; 结束标记<br>};</p>
<p>&#x2F;&#x2F; S7 参数解析函数查找表 (Ack-Data Responses)<br>static const struct {<br>uint8_t               functionCode;<br>void                 <em>parser;<br>int                   type;     &#x2F;&#x2F; 0 for S7ParamParserRes, 1 for S7ParamParserSimpleRes<br>} s7_param_parsers_res[] &#x3D; {<br>{S7_FUNCTION_READ_VAR,      parse_s7_read_var_response, 0},        &#x2F;&#x2F; 有 data<br>{S7_FUNCTION_WRITE_VAR,     (void</em>)parse_s7_write_var_response, 0}, &#x2F;&#x2F; 有 data<br>{S7_FUNCTION_PLC_STOP,      (void*)parse_s7_plc_control_response, 1}, &#x2F;&#x2F; 无 data<br>{S7_FUNCTION_PLC_START,    (void*)parse_s7_plc_control_response, 1}, &#x2F;&#x2F; 无 data<br>{S7_FUNCTION_DOWNLOAD_BLOCK, (void*)parse_s7_download_upload_response, 1}, &#x2F;&#x2F; 无 data<br>{S7_FUNCTION_DOWNLOAD_ENDED, (void*)parse_s7_download_upload_response, 1}, &#x2F;&#x2F; 无 data<br>{S7_FUNCTION_UPLOAD, (void*)parse_s7_download_upload_response, 1},       &#x2F;&#x2F; 无 data<br>{S7_FUNCTION_END_UPLOAD, (void*)parse_s7_download_upload_response, 1},     &#x2F;&#x2F; 无 data<br>{0, NULL, 0} &#x2F;&#x2F; 结束标记<br>};<br>#endif &#x2F;&#x2F; S7_PROTOCOL_H</p>
<p>s7.c:<br>&#x2F;&#x2F;s7.c<br>#include “arkime.h”<br>#include “s7-protocol.h”<br>#include &lt;string.h&gt;<br>#include &lt;arpa&#x2F;inet.h&gt; &#x2F;&#x2F; For htonl, ntohs<br>#include &lt;time.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;stdarg.h&gt; &#x2F;&#x2F; For va_list, etc.<br>#include &lt;glib.h&gt;<br>#include &lt;netinet&#x2F;ip.h&gt; &#x2F;&#x2F; For struct ip<br>#include &lt;netinet&#x2F;tcp.h&gt; &#x2F;&#x2F; For struct tcphdr</p>
<p>&#x2F;&#x2F; Arkime 字段定义 (全局变量)<br>static int s7FunctionCodeField;<br>static int s7DataBlockIdField; &#x2F;&#x2F; Deprecated<br>static int s7ItemCountField;<br>static int s7TransportSizeField;<br>static int s7DataLengthField;<br>static int s7AreaField;<br>static int s7DBNumberField;<br>static int s7StartOffsetField;<br>static int s7ErrorClassField;<br>static int s7ErrorCodeField;<br>static int s7ReturnCodeField;<br>static int s7DataField;<br>static int s7PDUReferenceField;<br>static int s7MessageTypeField;<br>static int s7BlockTypeField;<br>static int s7BlockNumberField;<br>static int s7BlockDataField;<br>static int s7MethodField;</p>
<p>&#x2F;&#x2F; 日志函数 (使用 fprintf)<br>void s7_log(const char *format, …) {<br>va_list args;<br>va_start(args, format);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">      time_t timer;</span><br><span class="line">char time_buffer[26];</span><br><span class="line">struct tm tm_info;</span><br><span class="line"></span><br><span class="line">time(&amp;timer);</span><br><span class="line">if (localtime_r(&amp;timer, &amp;tm_info) == NULL) &#123;</span><br><span class="line">    perror(&quot;localtime_r&quot;); // 处理错误</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (strftime(time_buffer, sizeof(time_buffer), &quot;%Y-%m-%d %H:%M:%S&quot;, &amp;tm_info) == 0) &#123;</span><br><span class="line">    fprintf(stderr, &quot;strftime failed\n&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;%s [s7_plugin] &quot;, time_buffer);</span><br><span class="line">vfprintf(stderr, format, args); // 直接输出到 stderr</span><br><span class="line">fprintf(stderr, &quot;\n&quot;);</span><br><span class="line">va_end(args);</span><br><span class="line">fflush(stderr); // 确保立即输出</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>IGNORE_WHEN_COPYING_START</p>
<p> content_copy  download </p>
<p> Use code <a target="_blank" rel="noopener" href="https://support.google.com/legal/answer/13505487">with caution</a>.</p>
<p>IGNORE_WHEN_COPYING_END</p>
<p>}</p>
<p>&#x2F;&#x2F; 分类器函数<br>void s7_classify(ArkimeSession_t *session, const uint8_t *data, int remaining, int UNUSED(which), void *UNUSED(uw))<br>{<br>s7_log(“s7_classify: Called. remaining&#x3D;%d, srcPort&#x3D;%d, dstPort&#x3D;%d”, remaining, session-&gt;port1, session-&gt;port2);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">      // 打印数据包的前 20 个字节 (用于调试)</span><br><span class="line">fprintf(stderr, &quot;s7_classify: Data: &quot;);</span><br><span class="line">for (int i = 0; i &lt; 20 &amp;&amp; i &lt; remaining; i++) &#123;</span><br><span class="line">    fprintf(stderr, &quot;%02x &quot;, data[i]);</span><br><span class="line">&#125;</span><br><span class="line">fprintf(stderr, &quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">// 1. 检查是否是TCP,且端口为102</span><br><span class="line">if (session-&gt;port1 != 102 &amp;&amp; session-&gt;port2 != 102) &#123;</span><br><span class="line">     s7_log(&quot;s7_classify: Not port 102&quot;);</span><br><span class="line">    return; // 不是 102 端口，直接返回</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2.ARKIME 会在TCP连接建立后自动调用parser,以及三次握手期间的SYN, ACK包,如果数据包长度足够，我们再尝试进一步分类</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>IGNORE_WHEN_COPYING_START</p>
<p> content_copy  download </p>
<p> Use code <a target="_blank" rel="noopener" href="https://support.google.com/legal/answer/13505487">with caution</a>.</p>
<p>IGNORE_WHEN_COPYING_END</p>
<p>if (remaining &gt;&#x3D; 6 &amp;&amp; data[0] &#x3D;&#x3D; 0x03) {<br>s7_log(“s7_classify: TPKT version check passed.”);<br>&#x2F;&#x2F; 检查 COTP PDU 类型 (DT Data 或 Connection Request)<br>if (data[1] !&#x3D; 0){ &#x2F;&#x2F;COTP 长度不为0<br>int cotp_len &#x3D; data[4] + 1;<br>if (remaining &gt;&#x3D; 4 + cotp_len &amp;&amp; (data[4+1] &#x3D;&#x3D; 0xf0 || data[4 + 1] &#x3D;&#x3D; 0xe0))<br>{<br>s7_log(“s7_classify: Looks like S7 traffic.  Returning.”);<br>arkime_session_add_protocol(session, “s7”); &#x2F;&#x2F; 在classify里打标签<br>return;<br>}<br>else{<br>s7_log(“s7_classify: COTP PDU type check failed.”);<br>}<br>}<br>else{<br>s7_log(“s7_classify: COTP length is zero”);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      &#125;</span><br><span class="line">else&#123;</span><br><span class="line">  s7_log(&quot;s7_classify: Basic checks failed.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">s7_log(&quot;s7_classify:  S7 connection establishment or non-S7, returning.&quot;);</span><br><span class="line">return ; // 即使没有 S7 数据，也要返回，让 Arkime 继续处理 TCP 连接</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>IGNORE_WHEN_COPYING_START</p>
<p> content_copy  download </p>
<p> Use code <a target="_blank" rel="noopener" href="https://support.google.com/legal/answer/13505487">with caution</a>.</p>
<p>IGNORE_WHEN_COPYING_END</p>
<p>}</p>
<p>&#x2F;&#x2F; 数据包解析函数<br>int s7_plugin_parser(ArkimeSession_t *session, void *UNUSED(uw), const unsigned char *data, int len, int UNUSED(which)) {<br>if (session &#x3D;&#x3D; NULL) {<br>s7_log(“ERROR: s7_plugin_parser called with NULL session”);<br>return 0;<br>}<br>s7_log(“s7_plugin_parser: Parser called!”);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line">      if (session-&gt;port1 == 102 || session-&gt;port2 == 102)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //arkime_session_add_protocol(session, &quot;s7&quot;); //在classify里打标签</span><br><span class="line">    s7_log(&quot;S7 Plugin: parser called for session %p, srcPort: %d, dstPort: %d&quot;, session, session-&gt;port1, session-&gt;port2);</span><br><span class="line"></span><br><span class="line">    // 检查是否是 TCP SYN/ACK (连接建立阶段)</span><br><span class="line">    if (len &lt; 7) &#123;</span><br><span class="line">        s7_log(&quot;s7_plugin_parser:  Likely a TCP SYN/ACK packet.  No S7 data to parse.&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    S7Packet s7packet;</span><br><span class="line">    memset(&amp;s7packet, 0, sizeof(s7packet));</span><br><span class="line"></span><br><span class="line">    int result = s7_protocol_parse(data, len, &amp;s7packet);</span><br><span class="line"></span><br><span class="line">    if (result == 0) &#123;</span><br><span class="line">         s7_log(&quot;s7_plugin_parser: s7_protocol_parse successful&quot;);</span><br><span class="line">        if (s7packet.functionCode != 0) &#123;</span><br><span class="line">            arkime_field_int_add(s7FunctionCodeField, session, s7packet.functionCode);</span><br><span class="line">            s7_log(&quot;s7_plugin_parser: Added s7FunctionCodeField: %d&quot;, s7packet.functionCode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (s7packet.itemCount != 0) &#123;</span><br><span class="line">            arkime_field_int_add(s7ItemCountField, session, s7packet.itemCount);</span><br><span class="line">            s7_log(&quot;s7_plugin_parser: Added s7ItemCountField: %d&quot;, s7packet.itemCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (s7packet.messageType !=0) &#123;</span><br><span class="line">            arkime_field_int_add(s7MessageTypeField, session, s7packet.messageType);</span><br><span class="line">            s7_log(&quot;s7_plugin_parser: Added s7MessageTypeField: %d&quot;, s7packet.messageType);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        if (s7packet.pduReference != 0) &#123;</span><br><span class="line">            arkime_field_int_add(s7PDUReferenceField, session, s7packet.pduReference);</span><br><span class="line">            s7_log(&quot;s7_plugin_parser: Added s7PDUReferenceField: %d&quot;, s7packet.pduReference);</span><br><span class="line">        &#125;</span><br><span class="line">        if(s7packet.method != 0)&#123;</span><br><span class="line">            arkime_field_int_add(s7MethodField, session, s7packet.method);</span><br><span class="line">            s7_log(&quot;s7_plugin_parser: Added s7MethodField: %d&quot;, s7packet.method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (s7packet.functionCode == S7_FUNCTION_REQ_DOWNLOAD ||</span><br><span class="line">            s7packet.functionCode == S7_FUNCTION_DOWNLOAD_BLOCK ||</span><br><span class="line">            s7packet.functionCode == S7_FUNCTION_START_UPLOAD ||</span><br><span class="line">            s7packet.functionCode == S7_FUNCTION_UPLOAD)</span><br><span class="line">        &#123;</span><br><span class="line">            if (s7packet.blockType != 0) &#123;</span><br><span class="line">                char blockTypeStr[2] = &#123;s7packet.blockType, 0&#125;;</span><br><span class="line">                arkime_field_string_add(s7BlockTypeField, session, blockTypeStr, 1, TRUE);</span><br><span class="line">                s7_log(&quot;s7_plugin_parser: Added s7BlockTypeField: %s&quot;, blockTypeStr);</span><br><span class="line">            &#125;</span><br><span class="line">            if(s7packet.blockNumber != 0)&#123;</span><br><span class="line">                arkime_field_int_add(s7BlockNumberField, session, s7packet.blockNumber);</span><br><span class="line">                s7_log(&quot;s7_plugin_parser: Added s7BlockNumberField: %d&quot;, s7packet.blockNumber);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (s7packet.blockData &amp;&amp; s7packet.blockDataLen &gt; 0) &#123;</span><br><span class="line">                char *encodedData = g_base64_encode(s7packet.blockData, s7packet.blockDataLen);</span><br><span class="line">                arkime_field_string_add(s7BlockDataField, session, encodedData, strlen(encodedData), TRUE);</span><br><span class="line">                 s7_log(&quot;s7_plugin_parser: Added s7BlockDataField: %s&quot;, encodedData);</span><br><span class="line">                g_free(encodedData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (s7packet.items) &#123;</span><br><span class="line">            for (int i = 0; i &lt; s7packet.itemCount; i++) &#123;</span><br><span class="line">                S7Item *item = &amp;s7packet.items[i];</span><br><span class="line">                if(item)</span><br><span class="line">                &#123;</span><br><span class="line">                     if (item-&gt;transportSize != 0) &#123;</span><br><span class="line">                        arkime_field_int_add(s7TransportSizeField, session, item-&gt;transportSize);</span><br><span class="line">                        s7_log(&quot;s7_plugin_parser: Added s7TransportSizeField: %d&quot;, item-&gt;transportSize);</span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                    if (item-&gt;length != 0) &#123;</span><br><span class="line">                        arkime_field_int_add(s7DataLengthField, session, item-&gt;length);</span><br><span class="line">                        s7_log(&quot;s7_plugin_parser: Added s7DataLengthField: %d&quot;, item-&gt;length);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (item-&gt;returnCode != 0) &#123;</span><br><span class="line">                        arkime_field_int_add(s7ReturnCodeField, session, item-&gt;returnCode);</span><br><span class="line">                        s7_log(&quot;s7_plugin_parser: Added s7ReturnCodeField: %d&quot;, item-&gt;returnCode);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    switch (item-&gt;area) &#123;</span><br><span class="line">                        case 0x81:</span><br><span class="line">                            arkime_field_string_add(s7AreaField, session, &quot;PA&quot;, 2, TRUE);</span><br><span class="line">                            s7_log(&quot;s7_plugin_parser: Added s7AreaField: PA&quot;);</span><br><span class="line">                            break; // Process Image Input</span><br><span class="line">                        case 0x82:</span><br><span class="line">                            arkime_field_string_add(s7AreaField, session, &quot;PB&quot;, 2, TRUE);</span><br><span class="line">                             s7_log(&quot;s7_plugin_parser: Added s7AreaField: PB&quot;);</span><br><span class="line">                            break; // Process Image Output</span><br><span class="line">                        case 0x83:</span><br><span class="line">                            arkime_field_string_add(s7AreaField, session, &quot;M&quot;, 1, TRUE);</span><br><span class="line">                            s7_log(&quot;s7_plugin_parser: Added s7AreaField: M&quot;);</span><br><span class="line">                            break; // Merkers</span><br><span class="line">                        case 0x84:</span><br><span class="line">                            arkime_field_string_add(s7AreaField, session, &quot;DB&quot;, 2, TRUE);</span><br><span class="line">                            s7_log(&quot;s7_plugin_parser: Added s7AreaField: DB&quot;);</span><br><span class="line">                            break; // Data Blocks</span><br><span class="line">                        case 0x1C:</span><br><span class="line">                           arkime_field_string_add(s7AreaField, session, &quot;CT&quot;, 2, TRUE);</span><br><span class="line">                           s7_log(&quot;s7_plugin_parser: Added s7AreaField: CT&quot;);</span><br><span class="line">                           break; //S7 Counters</span><br><span class="line"></span><br><span class="line">                        case 0x1D:</span><br><span class="line">                            arkime_field_string_add(s7AreaField, session, &quot;TM&quot;, 2, TRUE);</span><br><span class="line">                            s7_log(&quot;s7_plugin_parser: Added s7AreaField: TM&quot;);</span><br><span class="line">                            break; // S7 Timers</span><br><span class="line">                        default:</span><br><span class="line">                            arkime_field_string_add(s7AreaField, session, &quot;UNKNOWN&quot;, 7, TRUE);</span><br><span class="line">                            s7_log(&quot;s7_plugin_parser: Added s7AreaField: UNKNOWN&quot;);</span><br><span class="line">                            break;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (item-&gt;dbNumber != 0) &#123;</span><br><span class="line">                        arkime_field_int_add(s7DBNumberField, session, item-&gt;dbNumber);</span><br><span class="line">                        s7_log(&quot;s7_plugin_parser: Added s7DBNumberField: %d&quot;, item-&gt;dbNumber);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                     if (item-&gt;startOffset != 0) &#123;</span><br><span class="line">                        arkime_field_int_add(s7StartOffsetField, session, item-&gt;startOffset);</span><br><span class="line">                        s7_log(&quot;s7_plugin_parser: Added s7StartOffsetField: %d&quot;, item-&gt;startOffset);</span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                    if (item-&gt;data &amp;&amp; item-&gt;dataLengthBytes &gt; 0) &#123;</span><br><span class="line">                        char resultBuf[256];</span><br><span class="line">                        if (s7_decode_data(item, resultBuf, sizeof(resultBuf))) &#123;</span><br><span class="line">                            arkime_field_string_add(s7DataField, session, resultBuf, strlen(resultBuf), TRUE);</span><br><span class="line">                            s7_log(&quot;s7_plugin_parser: Added s7DataField: %s&quot;, resultBuf);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s7packet.errorClass != 0 || s7packet.errorCode != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            arkime_field_int_add(s7ErrorClassField, session, s7packet.errorClass);</span><br><span class="line">            s7_log(&quot;s7_plugin_parser: Added s7ErrorClassField: %d&quot;, s7packet.errorClass);</span><br><span class="line"></span><br><span class="line">            arkime_field_int_add(s7ErrorCodeField, session, s7packet.errorCode);</span><br><span class="line">            s7_log(&quot;s7_plugin_parser: Added s7ErrorCodeField: %d&quot;, s7packet.errorCode);</span><br><span class="line">        &#125;</span><br><span class="line">        s7_free_packet(&amp;s7packet);</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        s7_log(&quot;S7 parsing failed for session %p&quot;, session);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>IGNORE_WHEN_COPYING_START</p>
<p> content_copy  download </p>
<p> Use code <a target="_blank" rel="noopener" href="https://support.google.com/legal/answer/13505487">with caution</a>.</p>
<p>IGNORE_WHEN_COPYING_END</p>
<p>}</p>
<p>&#x2F;&#x2F; 插件初始化, 程序启动时定义字段<br>void arkime_plugin_init()<br>{<br>s7_log(“arkime_plugin_init() called”);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">      s7FunctionCodeField = arkime_field_define(&quot;s7&quot;, &quot;integer&quot;,</span><br><span class="line">    &quot;s7.functionCode&quot;, &quot;S7 Function Code&quot;, &quot;s7.fc&quot;,</span><br><span class="line">    &quot;S7 function code&quot;,</span><br><span class="line">    ARKIME_FIELD_TYPE_INT_GHASH,  ARKIME_FIELD_FLAG_CNT,</span><br><span class="line">    &quot;category&quot;, &quot;s7&quot;,</span><br><span class="line">    NULL);</span><br><span class="line"></span><br><span class="line">s7ItemCountField = arkime_field_define(&quot;s7&quot;, &quot;integer&quot;,</span><br><span class="line">    &quot;s7.itemCount&quot;, &quot;S7 Item Count&quot;, &quot;s7.items&quot;,</span><br><span class="line">    &quot;S7 item count&quot;,</span><br><span class="line">    ARKIME_FIELD_TYPE_INT_GHASH, ARKIME_FIELD_FLAG_CNT,</span><br><span class="line">    &quot;category&quot;, &quot;s7&quot;,</span><br><span class="line">    NULL);</span><br><span class="line"></span><br><span class="line">s7TransportSizeField = arkime_field_define(&quot;s7&quot;, &quot;integer&quot;,</span><br><span class="line">    &quot;s7.transportSize&quot;, &quot;S7 Transport Size&quot;, &quot;s7.tsize&quot;,</span><br><span class="line">    &quot;S7 transport size&quot;,</span><br><span class="line">    ARKIME_FIELD_TYPE_INT_GHASH, ARKIME_FIELD_FLAG_CNT,</span><br><span class="line">    &quot;category&quot;, &quot;s7&quot;,</span><br><span class="line">    &quot;help&quot;, &quot;BIT=1, BYTE/WORD/DWORD=2, COUNTER/TIMER=9, REAL=4&quot;,</span><br><span class="line">    NULL);</span><br><span class="line"></span><br><span class="line">s7DataLengthField = arkime_field_define(&quot;s7&quot;, &quot;integer&quot;,</span><br><span class="line">    &quot;s7.dataLength&quot;, &quot;S7 Data Length&quot;, &quot;s7.dlen&quot;,</span><br><span class="line">    &quot;S7 data length in bits&quot;,</span><br><span class="line">    ARKIME_FIELD_TYPE_INT_GHASH, ARKIME_FIELD_FLAG_CNT,</span><br><span class="line">    &quot;category&quot;, &quot;s7&quot;,</span><br><span class="line">    NULL);</span><br><span class="line"></span><br><span class="line">s7AreaField = arkime_field_define(&quot;s7&quot;, &quot;lotext&quot;,</span><br><span class="line">    &quot;s7.area&quot;, &quot;S7 Area&quot;, &quot;s7.area&quot;,</span><br><span class="line">    &quot;S7 memory area&quot;,</span><br><span class="line">    ARKIME_FIELD_TYPE_STR_HASH, ARKIME_FIELD_FLAG_CNT,</span><br><span class="line">     &quot;category&quot;, &quot;s7&quot;,</span><br><span class="line">    &quot;help&quot;, &quot;PA=ProcessImageInput, PB=ProcessImageOutput, M=Merkers, DB=DataBlocks, CT=Counters, TM=Timers&quot;,</span><br><span class="line">    NULL);</span><br><span class="line"></span><br><span class="line"> s7DBNumberField = arkime_field_define(&quot;s7&quot;, &quot;integer&quot;,</span><br><span class="line">    &quot;s7.dbNumber&quot;, &quot;S7 DB Number&quot;, &quot;s7.db&quot;,</span><br><span class="line">    &quot;S7 data block number&quot;,</span><br><span class="line">    ARKIME_FIELD_TYPE_INT_GHASH, ARKIME_FIELD_FLAG_CNT,</span><br><span class="line">     &quot;category&quot;, &quot;s7&quot;,</span><br><span class="line">    NULL);</span><br><span class="line"></span><br><span class="line">s7StartOffsetField = arkime_field_define(&quot;s7&quot;, &quot;integer&quot;,</span><br><span class="line">    &quot;s7.startOffset&quot;, &quot;S7 Start Offset&quot;, &quot;s7.offset&quot;,</span><br><span class="line">    &quot;S7 start offset in bits&quot;,</span><br><span class="line">    ARKIME_FIELD_TYPE_INT_GHASH, ARKIME_FIELD_FLAG_CNT,</span><br><span class="line">     &quot;category&quot;, &quot;s7&quot;,</span><br><span class="line">    NULL);</span><br><span class="line"></span><br><span class="line">s7ErrorClassField = arkime_field_define(&quot;s7&quot;, &quot;integer&quot;,</span><br><span class="line">    &quot;s7.errorClass&quot;, &quot;S7 Error Class&quot;, &quot;s7.eclass&quot;,</span><br><span class="line">    &quot;S7 error class&quot;,</span><br><span class="line">    ARKIME_FIELD_TYPE_INT_GHASH, ARKIME_FIELD_FLAG_CNT,</span><br><span class="line">     &quot;category&quot;, &quot;s7&quot;,</span><br><span class="line">    NULL);</span><br><span class="line"></span><br><span class="line"> s7ErrorCodeField = arkime_field_define(&quot;s7&quot;, &quot;integer&quot;,</span><br><span class="line">    &quot;s7.errorCode&quot;, &quot;S7 Error Code&quot;, &quot;s7.ecode&quot;,</span><br><span class="line">    &quot;S7 error code&quot;,</span><br><span class="line">    ARKIME_FIELD_TYPE_INT_GHASH, ARKIME_FIELD_FLAG_CNT,</span><br><span class="line">     &quot;category&quot;, &quot;s7&quot;,</span><br><span class="line">    NULL);</span><br><span class="line"></span><br><span class="line"> s7ReturnCodeField = arkime_field_define(&quot;s7&quot;, &quot;integer&quot;,</span><br><span class="line">    &quot;s7.returnCode&quot;, &quot;S7 Return Code&quot;, &quot;s7.rcode&quot;,</span><br><span class="line">    &quot;S7 return code for each item&quot;,</span><br><span class="line">    ARKIME_FIELD_TYPE_INT_GHASH, ARKIME_FIELD_FLAG_CNT,</span><br><span class="line">     &quot;category&quot;, &quot;s7&quot;,</span><br><span class="line">    NULL);</span><br><span class="line"></span><br><span class="line">s7DataField = arkime_field_define(&quot;s7&quot;, &quot;string&quot;,</span><br><span class="line">    &quot;s7.data&quot;, &quot;S7 Data&quot;, &quot;s7.data&quot;,</span><br><span class="line">    &quot;S7 data value&quot;,</span><br><span class="line">    ARKIME_FIELD_TYPE_STR_HASH,  0,</span><br><span class="line">     &quot;category&quot;, &quot;s7&quot;,</span><br><span class="line">    NULL);</span><br><span class="line"></span><br><span class="line">s7PDUReferenceField = arkime_field_define(&quot;s7&quot;, &quot;integer&quot;,</span><br><span class="line">    &quot;s7.pduReference&quot;, &quot;S7 PDU Reference&quot;, &quot;s7.pduref&quot;,</span><br><span class="line">    &quot;S7 PDU reference&quot;,</span><br><span class="line">    ARKIME_FIELD_TYPE_INT_GHASH,  ARKIME_FIELD_FLAG_CNT,</span><br><span class="line">     &quot;category&quot;, &quot;s7&quot;,</span><br><span class="line">    NULL);</span><br><span class="line"></span><br><span class="line">s7MessageTypeField = arkime_field_define(&quot;s7&quot;, &quot;integer&quot;,</span><br><span class="line">    &quot;s7.messageType&quot;, &quot;S7 Message Type&quot;, &quot;s7.mtype&quot;,</span><br><span class="line">    &quot;S7 message type&quot;,</span><br><span class="line">    ARKIME_FIELD_TYPE_INT_GHASH, ARKIME_FIELD_FLAG_CNT,</span><br><span class="line">     &quot;category&quot;, &quot;s7&quot;,</span><br><span class="line">    &quot;help&quot;, &quot;1=Job, 2=Ack, 3=Ack-Data, 7=UserData&quot;,</span><br><span class="line">    NULL);</span><br><span class="line"></span><br><span class="line">s7BlockTypeField = arkime_field_define(&quot;s7&quot;, &quot;lotext&quot;,</span><br><span class="line">    &quot;s7.blockType&quot;, &quot;S7 Block Type&quot;, &quot;s7.btype&quot;,</span><br><span class="line">    &quot;S7 Block Type&quot;,</span><br><span class="line">    ARKIME_FIELD_TYPE_STR, ARKIME_FIELD_FLAG_CNT,</span><br><span class="line">     &quot;category&quot;, &quot;s7&quot;,</span><br><span class="line">    &quot;help&quot;, &quot;B=Program, F=Data, O=Organization&quot;,</span><br><span class="line">    NULL);</span><br><span class="line"></span><br><span class="line">s7BlockNumberField = arkime_field_define(&quot;s7&quot;, &quot;integer&quot;,</span><br><span class="line">    &quot;s7.blockNumber&quot;, &quot;S7 Block Number&quot;, &quot;s7.bnum&quot;,</span><br><span class="line">    &quot;S7 Block Number&quot;,</span><br><span class="line">    ARKIME_FIELD_TYPE_INT_GHASH, ARKIME_FIELD_FLAG_CNT,</span><br><span class="line">     &quot;category&quot;, &quot;s7&quot;,</span><br><span class="line">    NULL);</span><br><span class="line"></span><br><span class="line">s7BlockDataField = arkime_field_define(&quot;s7&quot;, &quot;string&quot;,</span><br><span class="line">    &quot;s7.blockData&quot;, &quot;S7 Block Data&quot;, &quot;s7.bdata&quot;,</span><br><span class="line">    &quot;S7 Block Data&quot;,</span><br><span class="line">    ARKIME_FIELD_TYPE_STR, 0,</span><br><span class="line">     &quot;category&quot;, &quot;s7&quot;,</span><br><span class="line">    NULL);</span><br><span class="line"></span><br><span class="line">s7DataBlockIdField = arkime_field_define(&quot;s7&quot;, &quot;integer&quot;,  // Deprecated</span><br><span class="line">    &quot;s7.dataBlockId&quot;, &quot;S7 Data Block ID&quot;, &quot;s7dbid&quot;,</span><br><span class="line">    &quot;S7 data block ID (Deprecated)&quot;,</span><br><span class="line">    ARKIME_FIELD_TYPE_INT_GHASH,  ARKIME_FIELD_FLAG_CNT | ARKIME_FIELD_FLAG_DISABLED,</span><br><span class="line">     &quot;category&quot;, &quot;s7&quot;,</span><br><span class="line">    NULL);</span><br><span class="line">s7MethodField = arkime_field_define(&quot;s7&quot;, &quot;integer&quot;,</span><br><span class="line">    &quot;s7.method&quot;, &quot;S7 Method&quot;, &quot;s7.method&quot;,</span><br><span class="line">    &quot;S7 Method (PLC Start/Stop)&quot;,</span><br><span class="line">    ARKIME_FIELD_TYPE_INT_GHASH,  0,</span><br><span class="line">    &quot;category&quot;, &quot;s7&quot;,</span><br><span class="line">     NULL);</span><br><span class="line"></span><br><span class="line">// 初始化 S7 解析库</span><br><span class="line">s7_protocol_init();</span><br><span class="line"></span><br><span class="line">s7_log(&quot;S7 Plugin initialized successfully!&quot;);</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>IGNORE_WHEN_COPYING_START</p>
<p> content_copy  download </p>
<p> Use code <a target="_blank" rel="noopener" href="https://support.google.com/legal/answer/13505487">with caution</a>.</p>
<p>IGNORE_WHEN_COPYING_END</p>
<p>}</p>
<p>&#x2F;&#x2F; 插件退出 (可选)<br>void s7_plugin_exit()<br>{<br>s7_protocol_cleanup(); &#x2F;&#x2F; 清理 s7-protocol 库<br>}</p>
<p>&#x2F;&#x2F; Arkime 插件入口点, 程序加载时注册解析函数<br>#ifndef UNIT_TEST<br>void arkime_plugin_load() {<br>s7_log(“arkime_plugin_load() called”);<br>&#x2F;&#x2F; 注册 TCP 端口 102 的分类器，将流量定向到 s7_plugin_parser, 匹配TPKT头部的版本号0x03<br>arkime_parsers_classifier_register_tcp(“s7”, NULL, 0, (unsigned char *)”\x03”, 1, s7_classify);<br>arkime_plugin_init(); &#x2F;&#x2F; 初始化插件<br>}<br>#endif</p>
<p>wireshark捕获S7-1511-opc-request-all-types.pcap<br>的数据为<br>Frame 1: 66 bytes on wire (528 bits), 66 bytes captured (528 bits)<br>Ethernet II, Src: VMware_34:60:5d (00:50:56:34:60:5d), Dst: Siemens_13:41:73 (00:1b:1b:13:41:73)<br>Internet Protocol Version 4, Src: 192.168.25.146, Dst: 192.168.25.139<br>Transmission Control Protocol, Src Port: 55863, Dst Port: 102, Seq: 0, Len: 0</p>
<p>0000   00 1b 1b 13 41 73 00 50 56 34 60 5d 08 00 45 00   ….As.PV4&#96;]..E.<br>0010   00 34 43 6c 40 00 80 06 02 ea c0 a8 19 92 c0 a8   .4Cl@………..<br>0020   19 8b da 37 00 66 a0 f0 b7 38 00 00 00 00 80 02   …7.f…8……<br>0030   20 00 67 e1 00 00 02 04 05 b4 01 03 03 02 01 01    .g………….<br>0040   04 02                                             ..</p>
<p>Frame 2: 66 bytes on wire (528 bits), 66 bytes captured (528 bits)<br>Ethernet II, Src: VMware_34:60:5d (00:50:56:34:60:5d), Dst: Siemens_13:41:73 (00:1b:1b:13:41:73)<br>Internet Protocol Version 4, Src: 192.168.25.146, Dst: 192.168.25.139<br>Transmission Control Protocol, Src Port: 55863, Dst Port: 102, Seq: 0, Len: 0</p>
<p>0000   00 1b 1b 13 41 73 00 50 56 34 60 5d 08 00 45 00   ….As.PV4&#96;]..E.<br>0010   00 34 43 6c 40 00 80 06 02 ea c0 a8 19 92 c0 a8   .4Cl@………..<br>0020   19 8b da 37 00 66 a0 f0 b7 38 00 00 00 00 80 02   …7.f…8……<br>0030   20 00 67 e1 00 00 02 04 05 b4 01 03 03 02 01 01    .g………….<br>0040   04 02                                             ..</p>
<p>Frame 3: 60 bytes on wire (480 bits), 60 bytes captured (480 bits)<br>Ethernet II, Src: Siemens_13:41:73 (00:1b:1b:13:41:73), Dst: VMware_34:60:5d (00:50:56:34:60:5d)<br>Internet Protocol Version 4, Src: 192.168.25.139, Dst: 192.168.25.146<br>Transmission Control Protocol, Src Port: 102, Dst Port: 55863, Seq: 0, Ack: 1, Len: 0</p>
<p>0000   00 50 56 34 60 5d 00 1b 1b 13 41 73 08 00 45 00   .PV4]….As..E. 0010   00 2c 02 f7 00 00 1e 06 e5 67 c0 a8 19 8b c0 a8   .,…….g…… 0020   19 92 00 66 da 37 00 04 be 88 a0 f0 b7 39 60 12   …f.7…….9.<br>0030   10 00 e2 53 00 00 02 04 05 b4 02 f0               …S……..</p>
<p>Frame 4: 54 bytes on wire (432 bits), 54 bytes captured (432 bits)<br>Ethernet II, Src: VMware_34:60:5d (00:50:56:34:60:5d), Dst: Siemens_13:41:73 (00:1b:1b:13:41:73)<br>Internet Protocol Version 4, Src: 192.168.25.146, Dst: 192.168.25.139<br>Transmission Control Protocol, Src Port: 55863, Dst Port: 102, Seq: 1, Ack: 1, Len: 0</p>
<p>0000   00 1b 1b 13 41 73 00 50 56 34 60 5d 08 00 45 00   ….As.PV4&#96;]..E.<br>0010   00 28 43 6d 40 00 80 06 02 f5 c0 a8 19 92 c0 a8   .(Cm@………..<br>0020   19 8b da 37 00 66 a0 f0 b7 39 00 04 be 89 50 10   …7.f…9….P.<br>0030   fa f0 0f 20 00 00                                 … ..</p>
<p>Frame 5: 54 bytes on wire (432 bits), 54 bytes captured (432 bits)<br>Ethernet II, Src: VMware_34:60:5d (00:50:56:34:60:5d), Dst: Siemens_13:41:73 (00:1b:1b:13:41:73)<br>Internet Protocol Version 4, Src: 192.168.25.146, Dst: 192.168.25.139<br>Transmission Control Protocol, Src Port: 55863, Dst Port: 102, Seq: 1, Ack: 1, Len: 0</p>
<p>0000   00 1b 1b 13 41 73 00 50 56 34 60 5d 08 00 45 00   ….As.PV4&#96;]..E.<br>0010   00 28 43 6d 40 00 80 06 02 f5 c0 a8 19 92 c0 a8   .(Cm@………..<br>0020   19 8b da 37 00 66 a0 f0 b7 39 00 04 be 89 50 10   …7.f…9….P.<br>0030   fa f0 0f 20 00 00                                 … ..</p>
<p>Frame 6: 104 bytes on wire (832 bits), 104 bytes captured (832 bits)<br>Ethernet II, Src: VMware_34:60:5d (00:50:56:34:60:5d), Dst: Siemens_13:41:73 (00:1b:1b:13:41:73)<br>Internet Protocol Version 4, Src: 192.168.25.146, Dst: 192.168.25.139<br>Transmission Control Protocol, Src Port: 55863, Dst Port: 102, Seq: 1, Ack: 1, Len: 50<br>TPKT, Version: 3, Length: 50<br>ISO 8073&#x2F;X.224 COTP Connection-Oriented Transport Protocol</p>
<p>0000   00 1b 1b 13 41 73 00 50 56 34 60 5d 08 00 45 00   ….As.PV4&#96;]..E.<br>0010   00 5a 43 6e 40 00 80 06 02 c2 c0 a8 19 92 c0 a8   .ZCn@………..<br>0020   19 8b da 37 00 66 a0 f0 b7 39 00 04 be 89 50 18   …7.f…9….P.<br>0030   fa f0 a8 2c 00 00 03 00 00 32 2d e0 00 00 00 28   …,…..2-….(<br>0040   00 c1 10 53 4e 4f 50 43 43 30 30 30 32 30 30 30   …SNOPCC0002000<br>0050   30 30 31 c2 10 53 49 4d 41 54 49 43 2d 52 4f 4f   001..SIMATIC-ROO<br>0060   54 2d 4f 54 48 c0 01 0a                           T-OTH…</p>
<p>更改代码，from scapy.all import *</p>
<h1 id="—-配置-根据你的虚拟机配置-—"><a href="#—-配置-根据你的虚拟机配置-—" class="headerlink" title="— 配置 (根据你的虚拟机配置) —"></a>— 配置 (根据你的虚拟机配置) —</h1><p>dst_mac &#x3D; “00:0c:29:70:3a:0a”  # 虚拟机网卡 MAC 地址<br>src_mac &#x3D; “00:0c:29:70:3a:0a”  # 虚拟机网卡 MAC 地址 (通常与 dst_mac 相同)<br>dst_ip &#x3D; “192.168.52.142”    # 虚拟机 IP 地址<br>src_ip &#x3D; “192.168.52.142”    # 虚拟机 IP 地址 (通常与 dst_ip 相同)<br>dst_port &#x3D; 44818              # Ethernet&#x2F;IP 端口<br>src_port &#x3D; 54321              # 随机源端口<br>iface &#x3D; “ens33”               # 网络接口名称</p>
<p>print(“— 开始构建 Ethernet&#x2F;IP 数据包 —“)</p>
<h1 id="—-构建数据包-—"><a href="#—-构建数据包-—" class="headerlink" title="— 构建数据包 —"></a>— 构建数据包 —</h1><h1 id="1-Ethernet-层"><a href="#1-Ethernet-层" class="headerlink" title="1. Ethernet 层"></a>1. Ethernet 层</h1><p>ether &#x3D; Ether(src&#x3D;src_mac, dst&#x3D;dst_mac)</p>
<h1 id="2-IP-层"><a href="#2-IP-层" class="headerlink" title="2. IP 层"></a>2. IP 层</h1><p>ip &#x3D; IP(src&#x3D;src_ip, dst&#x3D;dst_ip)</p>
<h1 id="3-TCP-层-Ethernet-IP-通常基于-TCP"><a href="#3-TCP-层-Ethernet-IP-通常基于-TCP" class="headerlink" title="3. TCP 层 (Ethernet&#x2F;IP 通常基于 TCP)"></a>3. TCP 层 (Ethernet&#x2F;IP 通常基于 TCP)</h1><p>tcp &#x3D; TCP(sport&#x3D;src_port, dport&#x3D;dst_port, flags&#x3D;”PA”)  # PSH+ACK</p>
<h1 id="4-ENIP-CIP-数据-手动构建-NOP-No-Operation-命令"><a href="#4-ENIP-CIP-数据-手动构建-NOP-No-Operation-命令" class="headerlink" title="4. ENIP&#x2F;CIP 数据 (手动构建) - NOP (No Operation) 命令"></a>4. ENIP&#x2F;CIP 数据 (手动构建) - NOP (No Operation) 命令</h1><p>enip_cip_data &#x3D; b”\x00\x00”  # NOP command (两个字节的 0x00)</p>
<h1 id="—-组合数据包-使用-Scapy-的-Raw-层-—"><a href="#—-组合数据包-使用-Scapy-的-Raw-层-—" class="headerlink" title="— 组合数据包 (使用 Scapy 的 Raw 层) —"></a>— 组合数据包 (使用 Scapy 的 Raw 层) —</h1><p>packet &#x3D; ether &#x2F; ip &#x2F; tcp &#x2F; Raw(load&#x3D;enip_cip_data)</p>
<p>print(“数据包构建完成。”)</p>
<h1 id="—-发送数据包-—"><a href="#—-发送数据包-—" class="headerlink" title="— 发送数据包 —"></a>— 发送数据包 —</h1><p>try:<br>print(f”正在通过接口 {iface} 发送数据包…”)<br>sent_count &#x3D; sendp(packet, iface&#x3D;iface, verbose&#x3D;0)  # 使用 sendp, 指定接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      if sent_count == 1:</span><br><span class="line">    print(f&quot;成功发送 &#123;sent_count&#125; 个数据包！&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(f&quot;发送数据包数量异常：&#123;sent_count&#125;&quot;)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>except OSError as e:<br>print(f”发送数据包时发生错误: {e}”)<br>if “No such device” in str(e):<br>print(“  请检查网络接口名称 (iface) 是否正确。”)<br>elif “Network is down” in str(e):<br>print(“  网络已关闭。请检查网络连接。”)<br>else:<br>print(“  其他网络错误。”)</p>
<p>except Exception as e:<br>print(f”发生其他异常: {e}”)</p>
<p>finally:<br>print(“— 数据包发送操作完成 —“)</p>
<p>运行该代码后，ethernetip插件无法捕获到数据，要求模仿modbus插件代码，使其输出结果可以返回<br>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;stdint.h&gt;<br>#include &lt;arpa&#x2F;inet.h&gt;<br>#include &lt;time.h&gt;<br>#include &lt;glib.h&gt;  &#x2F;&#x2F; 包含 glib.h 头文件<br>#include &lt;dlfcn.h&gt; &#x2F;&#x2F; 包含 dlfcn.h 头文件<br>#include “arkime.h”</p>
<p>extern ArkimeConfig_t config;</p>
<p>#define ARKIME_API_VERSION 542<br>#define ARKIME_SESSIONID_LEN 40</p>
<p>&#x2F;&#x2F; Modbus 功能码定义<br>#define MODBUS_READ_COILS          0x01<br>#define MODBUS_READ_DISCRETE_INPUTS 0x02<br>#define MODBUS_READ_HOLDING_REGISTERS 0x03<br>#define MODBUS_READ_INPUT_REGISTERS 0x04<br>#define MODBUS_WRITE_SINGLE_COIL    0x05<br>#define MODBUS_WRITE_SINGLE_REGISTER 0x06<br>#define MODBUS_WRITE_MULTIPLE_COILS  0x0F<br>#define MODBUS_WRITE_MULTIPLE_REGISTERS 0x10</p>
<p>&#x2F;&#x2F; Modbus 异常码定义<br>#define MODBUS_EXC_ILLEGAL_FUNCTION      0x01<br>#define MODBUS_EXC_ILLEGAL_DATA_ADDRESS  0x02<br>#define MODBUS_EXC_ILLEGAL_DATA_VALUE     0x03<br>#define MODBUS_EXC_SLAVE_DEVICE_FAILURE  0x04<br>#define MODBUS_EXC_ACKNOWLEDGE           0x05<br>#define MODBUS_EXC_SLAVE_DEVICE_BUSY     0x06<br>#define MODBUS_EXC_NEGATIVE_ACKNOWLEDGE  0x07<br>#define MODBUS_EXC_MEMORY_PARITY_ERROR   0x08</p>
<p>&#x2F;&#x2F; 定义 Modbus 数据结构<br>typedef struct {<br>uint16_t transactionId;<br>uint16_t protocolId;<br>uint16_t length;<br>uint8_t  unitId;<br>uint8_t  functionCode;<br>uint16_t address;       &#x2F;&#x2F; 数据地址<br>uint16_t quantity;      &#x2F;&#x2F; 读取或者写入的数量<br>uint16_t value;         &#x2F;&#x2F; 单个寄存器或线圈的值<br>uint8_t *data;          &#x2F;&#x2F; 写入或读取的数据<br>uint16_t dataLength;    &#x2F;&#x2F; 数据长度<br>uint8_t  exceptionCode; &#x2F;&#x2F; 异常码<br>char   *description;    &#x2F;&#x2F; 描述信息<br>} ModbusData;</p>
<p>&#x2F;&#x2F; 全局变量，存储字段位置<br>static int modbus_transaction_id_field;<br>static int modbus_function_code_field;<br>static int modbus_description_field;<br>static int modbus_unit_id_field;<br>static int modbus_address_field;<br>static int modbus_quantity_field;<br>static int modbus_data_field;<br>static int modbus_src_port_field;<br>static int modbus_dest_port_field;<br>static int modbus_exc_code_field;</p>
<p>&#x2F;&#x2F; 函数声明 (保持不变)<br>void modbus_free_data(ModbusData *data);<br>void modbus_process_tcp_payload(ArkimeSession_t *session, const uint8_t *payload, int len);<br>int modbus_parse_pdu(const uint8_t *payload, int len, ModbusData *modbusData, ArkimeSession_t *session);</p>
<p>&#x2F;&#x2F; 自定义错误打印函数，带时间戳<br>void modbus_log(const char *format, …) {<br>va_list args;<br>va_start(args, format);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">      time_t timer;</span><br><span class="line">char buffer[26];</span><br><span class="line">struct tm tm_info; // 声明 struct tm 变量</span><br><span class="line">time(&amp;timer);</span><br><span class="line"></span><br><span class="line">localtime_r(&amp;timer, &amp;tm_info); // 使用 localtime_r 函数</span><br><span class="line"></span><br><span class="line">strftime(buffer, 26, &quot;%Y-%m-%d %H:%M:%S&quot;, &amp;tm_info); // 传递指针</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;%s [modbus_plugin] &quot;, buffer);</span><br><span class="line">vfprintf(stderr, format, args);</span><br><span class="line">fprintf(stderr, &quot;\n&quot;);</span><br><span class="line">va_end(args);</span><br><span class="line">fflush(stderr);</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>IGNORE_WHEN_COPYING_START</p>
<p> content_copy  download </p>
<p> Use code <a target="_blank" rel="noopener" href="https://support.google.com/legal/answer/13505487">with caution</a>.</p>
<p>IGNORE_WHEN_COPYING_END</p>
<p>}</p>
<p>&#x2F;******************************************************************************&#x2F;<br>&#x2F;&#x2F; 插件初始化函数<br>void arkime_plugin_init() {<br>modbus_log(“arkime_plugin_init() called”);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">      // 注册插件</span><br><span class="line">int rc = arkime_plugins_register_internal(&quot;modbus&quot;, TRUE, sizeof(ArkimeSession_t), ARKIME_API_VERSION);</span><br><span class="line">if (rc == -1) &#123;</span><br><span class="line">    fprintf(stderr, &quot;ERROR: Couldn&#x27;t register plugin\n&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义 Arkime 字段</span><br><span class="line">modbus_transaction_id_field = arkime_field_define(&quot;modbus&quot;, &quot;integer&quot;,</span><br><span class="line">                                                 &quot;modbus.transactionId&quot;, &quot;Modbus Transaction ID&quot;, &quot;modbus.transactionId&quot;,</span><br><span class="line">                                                 &quot;Modbus Transaction ID&quot;,</span><br><span class="line">                                                 ARKIME_FIELD_TYPE_INT_HASH, 0,</span><br><span class="line">                                                 NULL);</span><br><span class="line"></span><br><span class="line">modbus_function_code_field = arkime_field_define(&quot;modbus&quot;, &quot;integer&quot;,</span><br><span class="line">                                               &quot;modbus.functionCode&quot;, &quot;Modbus Function Code&quot;, &quot;modbus.functionCode&quot;,</span><br><span class="line">                                               &quot;Modbus Function Code&quot;,</span><br><span class="line">                                               ARKIME_FIELD_TYPE_INT_HASH, 0,</span><br><span class="line">                                               NULL);</span><br><span class="line"></span><br><span class="line">modbus_description_field = arkime_field_define(&quot;modbus&quot;, &quot;string&quot;,</span><br><span class="line">                                              &quot;modbus.description&quot;, &quot;Modbus Description&quot;, &quot;modbus.description&quot;,</span><br><span class="line">                                              &quot;Modbus Description&quot;,</span><br><span class="line">                                              ARKIME_FIELD_TYPE_STR_HASH, 0,</span><br><span class="line">                                              NULL);</span><br><span class="line"></span><br><span class="line">modbus_unit_id_field = arkime_field_define(&quot;modbus&quot;, &quot;integer&quot;,</span><br><span class="line">                                                  &quot;modbus.unitId&quot;, &quot;Modbus Unit ID&quot;, &quot;modbus.unitId&quot;,</span><br><span class="line">                                                  &quot;Modbus Unit ID&quot;,</span><br><span class="line">                                                  ARKIME_FIELD_TYPE_INT_HASH, 0,</span><br><span class="line">                                                  NULL);</span><br><span class="line"></span><br><span class="line">modbus_address_field = arkime_field_define(&quot;modbus&quot;, &quot;integer&quot;,</span><br><span class="line">                                                   &quot;modbus.address&quot;, &quot;Modbus Address&quot;, &quot;modbus.address&quot;,</span><br><span class="line">                                                   &quot;Modbus Address&quot;,</span><br><span class="line">                                                   ARKIME_FIELD_TYPE_INT_HASH, 0,</span><br><span class="line">                                                   NULL);</span><br><span class="line"></span><br><span class="line">modbus_quantity_field = arkime_field_define(&quot;modbus&quot;, &quot;integer&quot;,</span><br><span class="line">                                                    &quot;modbus.quantity&quot;, &quot;Modbus Quantity&quot;, &quot;modbus.quantity&quot;,</span><br><span class="line">                                                    &quot;Modbus Quantity&quot;,</span><br><span class="line">                                                    ARKIME_FIELD_TYPE_INT_HASH, 0,</span><br><span class="line">                                                    NULL);</span><br><span class="line"></span><br><span class="line">modbus_data_field = arkime_field_define(&quot;modbus&quot;, &quot;string&quot;,</span><br><span class="line">                                                &quot;modbus.data&quot;, &quot;Modbus Data&quot;, &quot;modbus.data&quot;,</span><br><span class="line">                                                &quot;Modbus Data&quot;,</span><br><span class="line">                                                ARKIME_FIELD_TYPE_STR_HASH, 0,</span><br><span class="line">                                                NULL);</span><br><span class="line">modbus_src_port_field = arkime_field_define(&quot;modbus&quot;, &quot;integer&quot;,</span><br><span class="line">                                                    &quot;modbus.srcPort&quot;, &quot;Modbus Source Port&quot;, &quot;modbus.srcPort&quot;,</span><br><span class="line">                                                    &quot;Modbus Source Port&quot;,</span><br><span class="line">                                                    ARKIME_FIELD_TYPE_INT_HASH, 0,</span><br><span class="line">                                                    NULL);</span><br><span class="line"></span><br><span class="line">modbus_dest_port_field = arkime_field_define(&quot;modbus&quot;, &quot;integer&quot;,</span><br><span class="line">                                                 &quot;modbus.destPort&quot;, &quot;Modbus Destination Port&quot;, &quot;modbus.destPort&quot;,</span><br><span class="line">                                                 &quot;Modbus Destination Port&quot;,</span><br><span class="line">                                                 ARKIME_FIELD_TYPE_INT_HASH, 0,</span><br><span class="line">                                                 NULL);</span><br><span class="line">modbus_exc_code_field = arkime_field_define(&quot;modbus&quot;, &quot;integer&quot;,</span><br><span class="line">                                                 &quot;modbus.exceptionCode&quot;, &quot;Modbus Exception Code&quot;, &quot;modbus.exceptionCode&quot;,</span><br><span class="line">                                                 &quot;Modbus Exception Code&quot;,</span><br><span class="line">                                                 ARKIME_FIELD_TYPE_INT_HASH, 0,</span><br><span class="line">                                                 NULL);</span><br><span class="line"></span><br><span class="line">// 注册 TCP 端口 502 的流量处理回调函数</span><br><span class="line">arkime_parsers_classifier_register_port(&quot;modbus&quot;, NULL, 502, ARKIME_PARSERS_PORT_TCP, (ArkimeClassifyFunc)modbus_process_tcp_payload);</span><br><span class="line"></span><br><span class="line">modbus_log(&quot;modbus plugin initialized!&quot;);</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>IGNORE_WHEN_COPYING_START</p>
<p> content_copy  download </p>
<p> Use code <a target="_blank" rel="noopener" href="https://support.google.com/legal/answer/13505487">with caution</a>.</p>
<p>IGNORE_WHEN_COPYING_END</p>
<p>}</p>
<p>&#x2F;******************************************************************************&#x2F;<br>&#x2F;&#x2F; 判断是否是 Modbus 数据 (更严格的检查) (保持不变)<br>int modbus_is_modbus(const uint8_t *payload, int len) {<br>if (len &lt; 7) {<br>modbus_log(“modbus_is_modbus: len &lt; 7, returning FALSE”);<br>return FALSE;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">      // 检查协议标识符, Modbus TCP 固定为 0</span><br><span class="line">uint16_t protocolId = ntohs(*(uint16_t*)(payload + 2));</span><br><span class="line">if (protocolId != 0) &#123;</span><br><span class="line">    modbus_log(&quot;modbus_is_modbus: protocolId != 0, returning FALSE&quot;);</span><br><span class="line">    return FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 检查长度字段，确保其值与实际长度匹配 (减去前 6 个字节)</span><br><span class="line">uint16_t expectedLength = ntohs(*(uint16_t*)(payload + 4));</span><br><span class="line">if (expectedLength != len - 6) &#123;</span><br><span class="line">    modbus_log(&quot;modbus_is_modbus: expectedLength != len - 6, returning FALSE&quot;);</span><br><span class="line">    return FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">modbus_log(&quot;modbus_is_modbus: is Modbus TCP&quot;);</span><br><span class="line">return TRUE;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>IGNORE_WHEN_COPYING_START</p>
<p> content_copy  download </p>
<p> Use code <a target="_blank" rel="noopener" href="https://support.google.com/legal/answer/13505487">with caution</a>.</p>
<p>IGNORE_WHEN_COPYING_END</p>
<p>}</p>
<p>&#x2F;******************************************************************************&#x2F;<br>&#x2F;&#x2F; 处理 TCP 数据包<br>void modbus_process_tcp_payload(ArkimeSession_t *session, const uint8_t *payload, int len) {<br>char sessionString[ARKIME_SESSIONID_LEN];<br>arkime_session_id_string(session-&gt;sessionId, sessionString);<br>modbus_log(“modbus_process_tcp_payload called, len &#x3D; %d, session id &#x3D; %s”, len, sessionString);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">      if (len &lt;= 0) &#123;</span><br><span class="line">    modbus_log(&quot;modbus_process_tcp_payload: len &lt;= 0, returning&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断是否是 Modbus 数据</span><br><span class="line">if (!modbus_is_modbus(payload, len)) &#123;</span><br><span class="line">    modbus_log(&quot;modbus_process_tcp_payload: not Modbus traffic, returning&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ModbusData *modbusData = ARKIME_TYPE_ALLOC0(ModbusData); // 使用 Arkime 的内存分配函数</span><br><span class="line">if (!modbusData) &#123;</span><br><span class="line">    modbus_log(&quot;ERROR - 内存分配失败&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">modbus_log(&quot;modbus_process_tcp_payload: Modbus data detected, parsing PDU&quot;);</span><br><span class="line"></span><br><span class="line">// 解析 Modbus PDU</span><br><span class="line">if (modbus_parse_pdu(payload, len, modbusData, session) == 0) &#123; // 传递 session 指针</span><br><span class="line">    modbus_log(&quot;modbus_process_tcp_payload: modbus_parse_pdu success, adding fields&quot;);</span><br><span class="line">    // 添加 Modbus 数据到 Arkime 字段</span><br><span class="line">    arkime_field_int_add(modbus_transaction_id_field, session, modbusData-&gt;transactionId);</span><br><span class="line">    modbus_log(&quot;modbus_process_tcp_payload: added transactionId = %u&quot;, modbusData-&gt;transactionId);</span><br><span class="line"></span><br><span class="line">    arkime_field_int_add(modbus_function_code_field, session, modbusData-&gt;functionCode);</span><br><span class="line">    modbus_log(&quot;modbus_process_tcp_payload: added functionCode = %u&quot;, modbusData-&gt;functionCode);</span><br><span class="line"></span><br><span class="line">    arkime_field_int_add(modbus_unit_id_field, session, modbusData-&gt;unitId);</span><br><span class="line">    modbus_log(&quot;modbus_process_tcp_payload: added unitId = %u&quot;, modbusData-&gt;unitId);</span><br><span class="line"></span><br><span class="line">    arkime_field_int_add(modbus_src_port_field, session, session-&gt;port1);</span><br><span class="line">    modbus_log(&quot;modbus_process_tcp_payload: added srcPort = %u&quot;, session-&gt;port1);</span><br><span class="line"></span><br><span class="line">    arkime_field_int_add(modbus_dest_port_field, session, session-&gt;port2);</span><br><span class="line">    modbus_log(&quot;modbus_process_tcp_payload: added destPort = %u&quot;, session-&gt;port2);</span><br><span class="line"></span><br><span class="line">    if (modbusData-&gt;exceptionCode != 0)&#123;</span><br><span class="line">        arkime_field_int_add(modbus_exc_code_field, session,  modbusData-&gt;exceptionCode);</span><br><span class="line">        modbus_log(&quot;modbus_process_tcp_payload: added exceptionCode = %u&quot;, modbusData-&gt;exceptionCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (modbusData-&gt;address != 0xFFFF)&#123;</span><br><span class="line">        arkime_field_int_add(modbus_address_field, session,  modbusData-&gt;address);</span><br><span class="line">         modbus_log(&quot;modbus_process_tcp_payload: added address = %u&quot;,  modbusData-&gt;address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     if (modbusData-&gt;quantity != 0xFFFF)&#123;</span><br><span class="line">        arkime_field_int_add(modbus_quantity_field, session,  modbusData-&gt;quantity);</span><br><span class="line">         modbus_log(&quot;modbus_process_tcp_payload: added quantity = %u&quot;,   modbusData-&gt;quantity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 避免 NULL 指针解引用</span><br><span class="line">    if (modbusData-&gt;description != NULL) &#123;</span><br><span class="line">        arkime_field_string_add(modbus_description_field, session, modbusData-&gt;description, -1, TRUE);</span><br><span class="line">        modbus_log(&quot;modbus_process_tcp_payload: added description = %s&quot;,modbusData-&gt;description);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        modbus_log(&quot;modbus_process_tcp_payload: description is NULL&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (modbusData-&gt;dataLength &gt; 0 &amp;&amp; modbusData-&gt;data != NULL) &#123;</span><br><span class="line">        char hex_string[1024];</span><br><span class="line">        arkime_sprint_hex_string(hex_string, modbusData-&gt;data, modbusData-&gt;dataLength);</span><br><span class="line">        arkime_field_string_add(modbus_data_field, session, hex_string, -1, TRUE);</span><br><span class="line">        modbus_log(&quot;modbus_process_tcp_payload: added data: %s&quot;, hex_string);  // 打印实际数据</span><br><span class="line">         ARKIME_SIZE_FREE(modbus_data, modbusData-&gt;data);</span><br><span class="line">         modbusData-&gt;data = NULL;</span><br><span class="line">         modbusData-&gt;dataLength=0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modbus_free_data(modbusData);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    modbus_log(&quot;modbus_process_tcp_payload: modbus_parse_pdu failed&quot;);</span><br><span class="line">    modbus_free_data(modbusData);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>IGNORE_WHEN_COPYING_START</p>
<p> content_copy  download </p>
<p> Use code <a target="_blank" rel="noopener" href="https://support.google.com/legal/answer/13505487">with caution</a>.</p>
<p>IGNORE_WHEN_COPYING_END</p>
<p>}</p>
<p>&#x2F;******************************************************************************&#x2F;<br>&#x2F;&#x2F; 解析 Modbus PDU (保持不变)<br>int modbus_parse_pdu(const uint8_t *payload, int len, ModbusData *modbusData, ArkimeSession_t *session) {<br>modbus_log(“modbus_parse_pdu called, len &#x3D; %d,functionCode&#x3D;%d”, len,payload[7]);<br>if (len &lt; 8) {<br>modbus_log(“modbus_parse_pdu: len &lt; 8, returning -1”);<br>return -1; &#x2F;&#x2F; 至少需要 8 个字节<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line">      modbusData-&gt;transactionId = ntohs(*(uint16_t*)(payload + 0));</span><br><span class="line">modbus_log(&quot;modbus_parse_pdu: transactionId = %u&quot;,modbusData-&gt;transactionId);</span><br><span class="line">modbusData-&gt;protocolId    = ntohs(*(uint16_t*)(payload + 2));</span><br><span class="line">modbus_log(&quot;modbus_parse_pdu: protocolId = %u&quot;,modbusData-&gt;protocolId);</span><br><span class="line">modbusData-&gt;length        = ntohs(*(uint16_t*)(payload + 4));</span><br><span class="line">modbus_log(&quot;modbus_parse_pdu: length = %u&quot;,modbusData-&gt;length);</span><br><span class="line">modbusData-&gt;unitId        = payload[6];</span><br><span class="line">modbus_log(&quot;modbus_parse_pdu: unitId = %u&quot;,modbusData-&gt;unitId);</span><br><span class="line">modbusData-&gt;functionCode  = payload[7];</span><br><span class="line">modbus_log(&quot;modbus_parse_pdu: functionCode = %u&quot;,modbusData-&gt;functionCode);</span><br><span class="line"></span><br><span class="line">const uint8_t *pdu = payload + 8;</span><br><span class="line">int pdu_len = len - 8;</span><br><span class="line"></span><br><span class="line">modbusData-&gt;description = &quot;Unknown&quot;; // 设置默认值</span><br><span class="line">//设置默认值，避免显示异常</span><br><span class="line">modbusData-&gt;address = 0xFFFF;</span><br><span class="line">modbusData-&gt;quantity = 0xFFFF;</span><br><span class="line">modbusData-&gt;exceptionCode = 0x00;</span><br><span class="line"></span><br><span class="line">switch (modbusData-&gt;functionCode) &#123;</span><br><span class="line">    case MODBUS_READ_COILS:         // 0x01</span><br><span class="line">    case MODBUS_READ_DISCRETE_INPUTS:  // 0x02</span><br><span class="line">    case MODBUS_READ_HOLDING_REGISTERS: // 0x03</span><br><span class="line">    case MODBUS_READ_INPUT_REGISTERS:   // 0x04</span><br><span class="line">    &#123;</span><br><span class="line">        if (pdu_len &lt; 4) &#123;</span><br><span class="line">            modbus_log(&quot;modbus_parse_pdu: read function, pdu_len &lt; 4, returning -1&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        modbusData-&gt;address  = ntohs(*(uint16_t*)(pdu + 0));</span><br><span class="line">        modbus_log(&quot;modbus_parse_pdu: address = %u&quot;, modbusData-&gt;address);</span><br><span class="line">        modbusData-&gt;quantity = ntohs(*(uint16_t*)(pdu + 2));</span><br><span class="line">        modbus_log(&quot;modbus_parse_pdu: quantity = %u&quot;,modbusData-&gt;quantity);</span><br><span class="line"></span><br><span class="line">        switch (modbusData-&gt;functionCode) &#123;</span><br><span class="line">            case MODBUS_READ_COILS:</span><br><span class="line">                modbusData-&gt;description = &quot;Read Coils&quot;;</span><br><span class="line">                modbus_log(&quot;modbus_parse_pdu: description = Read Coils&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case MODBUS_READ_DISCRETE_INPUTS:</span><br><span class="line">                modbusData-&gt;description = &quot;Read Discrete Inputs&quot;;</span><br><span class="line">                modbus_log(&quot;modbus_parse_pdu: description = Read Discrete Inputs&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case MODBUS_READ_HOLDING_REGISTERS:</span><br><span class="line">                modbusData-&gt;description = &quot;Read Holding Registers&quot;;</span><br><span class="line">                modbus_log(&quot;modbus_parse_pdu: description = Read Holding Registers&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case MODBUS_READ_INPUT_REGISTERS:</span><br><span class="line">                modbusData-&gt;description = &quot;Read Input Registers&quot;;</span><br><span class="line">                modbus_log(&quot;modbus_parse_pdu: description = Read Input Registers&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    case MODBUS_WRITE_SINGLE_COIL:    // 0x05</span><br><span class="line">    case MODBUS_WRITE_SINGLE_REGISTER: // 0x06</span><br><span class="line">    &#123;</span><br><span class="line">        if (pdu_len &lt; 4) &#123;</span><br><span class="line">            modbus_log(&quot;modbus_parse_pdu: write single function, pdu_len &lt; 4, returning -1&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modbusData-&gt;address = ntohs(*(uint16_t*)(pdu + 0));</span><br><span class="line">        modbus_log(&quot;modbus_parse_pdu: address = %u&quot;, modbusData-&gt;address);</span><br><span class="line">        modbusData-&gt;value   = ntohs(*(uint16_t*)(pdu + 2));</span><br><span class="line">        modbus_log(&quot;modbus_parse_pdu: value = %u&quot;,modbusData-&gt;value);</span><br><span class="line"></span><br><span class="line">        switch (modbusData-&gt;functionCode) &#123;</span><br><span class="line">            case MODBUS_WRITE_SINGLE_COIL:</span><br><span class="line">                modbusData-&gt;description = &quot;Write Single Coil&quot;;</span><br><span class="line">                modbus_log(&quot;modbus_parse_pdu: description = Write Single Coil&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case MODBUS_WRITE_SINGLE_REGISTER:</span><br><span class="line">                modbusData-&gt;description = &quot;Write Single Register&quot;;</span><br><span class="line">                modbus_log(&quot;modbus_parse_pdu: description = Write Single Register&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    case MODBUS_WRITE_MULTIPLE_COILS:    // 0x0F</span><br><span class="line">    case MODBUS_WRITE_MULTIPLE_REGISTERS: // 0x10</span><br><span class="line">    &#123;</span><br><span class="line">        if (pdu_len &lt; 5) &#123;</span><br><span class="line">            modbus_log(&quot;modbus_parse_pdu: write multiple function, pdu_len &lt; 5, returning -1&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modbusData-&gt;address  = ntohs(*(uint16_t*)(pdu + 0));</span><br><span class="line">        modbus_log(&quot;modbus_parse_pdu: address = %u&quot;,modbusData-&gt;address);</span><br><span class="line">        modbusData-&gt;quantity = ntohs(*(uint16_t*)(pdu + 2));</span><br><span class="line">        modbus_log(&quot;modbus_parse_pdu: quantity = %u&quot;,modbusData-&gt;quantity);</span><br><span class="line">        modbusData-&gt;dataLength = pdu[4];</span><br><span class="line">        modbus_log(&quot;modbus_parse_pdu: dataLength = %u&quot;,modbusData-&gt;dataLength);</span><br><span class="line"></span><br><span class="line">        if (pdu_len &lt; 5 + modbusData-&gt;dataLength) &#123;</span><br><span class="line">            modbus_log(&quot;modbus_parse_pdu: write multiple function, pdu_len &lt; 5 + dataLength, returning -1&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modbusData-&gt;data = ARKIME_SIZE_ALLOC0(modbus_data, modbusData-&gt;dataLength); // 使用 Arkime 的内存分配函数</span><br><span class="line">        if (!modbusData-&gt;data) &#123;</span><br><span class="line">            modbus_log(&quot;ERROR - 内存分配失败&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        memcpy(modbusData-&gt;data, pdu + 5, modbusData-&gt;dataLength);</span><br><span class="line"></span><br><span class="line">        switch (modbusData-&gt;functionCode) &#123;</span><br><span class="line">            case MODBUS_WRITE_MULTIPLE_COILS:</span><br><span class="line">                modbusData-&gt;description = &quot;Write Multiple Coils&quot;;</span><br><span class="line">                modbus_log(&quot;modbus_parse_pdu: description = Write Multiple Coils&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case MODBUS_WRITE_MULTIPLE_REGISTERS:</span><br><span class="line">                modbusData-&gt;description = &quot;Write Multiple Registers&quot;;</span><br><span class="line">                modbus_log(&quot;modbus_parse_pdu: description = Write Multiple Registers&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    case 0x80 ... 0xFF: // Exception Response</span><br><span class="line">    &#123;</span><br><span class="line">        if (pdu_len &lt; 1) &#123;</span><br><span class="line">            modbus_log(&quot;modbus_parse_pdu: exception response, pdu_len &lt; 1, returning -1&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        modbusData-&gt;exceptionCode = pdu[0];</span><br><span class="line">        modbus_log(&quot;modbus_parse_pdu: exceptionCode = %u&quot;,modbusData-&gt;exceptionCode);</span><br><span class="line"></span><br><span class="line">        switch (modbusData-&gt;exceptionCode) &#123;</span><br><span class="line">            case MODBUS_EXC_ILLEGAL_FUNCTION:</span><br><span class="line">                modbusData-&gt;description = &quot;Exception: Illegal Function&quot;;</span><br><span class="line">                modbus_log(&quot;modbus_parse_pdu: description = Exception: Illegal Function&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case MODBUS_EXC_ILLEGAL_DATA_ADDRESS:</span><br><span class="line">                modbusData-&gt;description = &quot;Exception: Illegal Data Address&quot;;</span><br><span class="line">                modbus_log(&quot;modbus_parse_pdu: description = Exception: Illegal Data Address&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case MODBUS_EXC_ILLEGAL_DATA_VALUE:</span><br><span class="line">                modbusData-&gt;description = &quot;Exception: Illegal Data Value&quot;;</span><br><span class="line">                modbus_log(&quot;modbus_parse_pdu: description = Exception: Illegal Data Value&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case MODBUS_EXC_SLAVE_DEVICE_FAILURE:</span><br><span class="line">                modbusData-&gt;description = &quot;Exception: Slave Device Failure&quot;;</span><br><span class="line">                modbus_log(&quot;modbus_parse_pdu: description = Exception: Slave Device Failure&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case MODBUS_EXC_ACKNOWLEDGE:</span><br><span class="line">                modbusData-&gt;description = &quot;Exception: Acknowledge&quot;;</span><br><span class="line">                modbus_log(&quot;modbus_parse_pdu: description = Exception: Acknowledge&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case MODBUS_EXC_SLAVE_DEVICE_BUSY:</span><br><span class="line">                modbusData-&gt;description = &quot;Exception: Slave Device Busy&quot;;</span><br><span class="line">                modbus_log(&quot;modbus_parse_pdu: description = Exception: Slave Device Busy&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case MODBUS_EXC_NEGATIVE_ACKNOWLEDGE:</span><br><span class="line">                modbusData-&gt;description = &quot;Exception: Negative Acknowledge&quot;;</span><br><span class="line">                modbus_log(&quot;modbus_parse_pdu: description = Exception: Negative Acknowledge&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case MODBUS_EXC_MEMORY_PARITY_ERROR:</span><br><span class="line">                modbusData-&gt;description = &quot;Exception: Memory Parity Error&quot;;</span><br><span class="line">                modbus_log(&quot;modbus_parse_pdu: description = Exception: Memory Parity Error&quot;);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                modbusData-&gt;description = &quot;Exception: Unknown Error&quot;;</span><br><span class="line">                modbus_log(&quot;modbus_parse_pdu: description = Exception: Unknown Error&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">        modbus_log(&quot;modbus_parse_pdu: unknown function code, returning -1&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>IGNORE_WHEN_COPYING_START</p>
<p> content_copy  download </p>
<p> Use code <a target="_blank" rel="noopener" href="https://support.google.com/legal/answer/13505487">with caution</a>.</p>
<p>IGNORE_WHEN_COPYING_END</p>
<p>}</p>
<p>&#x2F;******************************************************************************&#x2F;<br>&#x2F;&#x2F; 释放 ModbusData 结构体内存 (保持不变)<br>void modbus_free_data(ModbusData *data) {<br>if (data) {<br>if (data-&gt;data) {<br>ARKIME_SIZE_FREE(modbus_data, data-&gt;data); &#x2F;&#x2F; 使用 Arkime 的内存释放函数<br>}<br>ARKIME_TYPE_FREE(ModbusData, data); &#x2F;&#x2F; 使用 Arkime 的内存释放函数<br>}<br>}</p>
<p>&#x2F;******************************************************************************&#x2F;<br>&#x2F;&#x2F; 供 Arkime 加载插件的函数<br>#ifndef UNIT_TEST<br>void arkime_plugin_load() {</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      modbus_log(&quot;arkime_plugin_load() called&quot;);</span><br><span class="line">arkime_plugin_init();</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>IGNORE_WHEN_COPYING_START</p>
<p> content_copy  download </p>
<p> Use code <a target="_blank" rel="noopener" href="https://support.google.com/legal/answer/13505487">with caution</a>.</p>
<p>IGNORE_WHEN_COPYING_END</p>
<p>}<br>#endif</p>
<p>输出结果：<br>2025-03-13 15:26:34 [modbus_plugin] modbus_is_modbus: is Modbus TCP<br>2025-03-13 15:26:34 [modbus_plugin] modbus_process_tcp_payload: Modbus data detected, parsing PDU<br>2025-03-13 15:26:34 [modbus_plugin] modbus_parse_pdu called, len &#x3D; 12,functionCode&#x3D;3<br>2025-03-13 15:26:34 [modbus_plugin] modbus_parse_pdu: transactionId &#x3D; 1<br>2025-03-13 15:26:34 [modbus_plugin] modbus_parse_pdu: protocolId &#x3D; 0<br>2025-03-13 15:26:34 [modbus_plugin] modbus_parse_pdu: length &#x3D; 6<br>2025-03-13 15:26:34 [modbus_plugin] modbus_parse_pdu: unitId &#x3D; 1<br>2025-03-13 15:26:34 [modbus_plugin] modbus_parse_pdu: functionCode &#x3D; 3<br>2025-03-13 15:26:34 [modbus_plugin] modbus_parse_pdu: address &#x3D; 0<br>2025-03-13 15:26:34 [modbus_plugin] modbus_parse_pdu: quantity &#x3D; 2<br>2025-03-13 15:26:34 [modbus_plugin] modbus_parse_pdu: description &#x3D; Read Holding Registers<br>2025-03-13 15:26:34 [modbus_plugin] modbus_process_tcp_payload: modbus_parse_pdu success, adding fields<br>2025-03-13 15:26:34 [modbus_plugin] modbus_process_tcp_payload: added transactionId &#x3D; 1<br>2025-03-13 15:26:34 [modbus_plugin] modbus_process_tcp_payload: added functionCode &#x3D; 3<br>2025-03-13 15:26:34 [modbus_plugin] modbus_process_tcp_payload: added unitId &#x3D; 1<br>2025-03-13 15:26:34 [modbus_plugin] modbus_process_tcp_payload: added srcPort &#x3D; 54321<br>2025-03-13 15:26:34 [modbus_plugin] modbus_process_tcp_payload: added destPort &#x3D; 502<br>2025-03-13 15:26:34 [modbus_plugin] modbus_process_tcp_payload: added address &#x3D; 0<br>2025-03-13 15:26:34 [modbus_plugin] modbus_process_tcp_payload: added quantity &#x3D; 2<br>2025-03-13 15:26:34 [modbus_plugin] modbus_process_tcp_payload: added description &#x3D; Read Holding Registers</p>
<p> sudo tcpdump -i ens33 -w ethernetip_test.pcap port 44818</p>
<p>sudo &#x2F;opt&#x2F;arkime&#x2F;bin&#x2F;capture -c &#x2F;opt&#x2F;arkime&#x2F;etc&#x2F;config.ini -r ethernetip_test.pcap</p>

<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2024/12/08/%E8%8B%B1%E8%AF%AD%E5%86%99%E4%BD%9C%E5%92%8C%E7%BF%BB%E8%AF%91/">英语写作和翻译</a></div></section></div>




  <div class="related-wrap md-text" id="comments">
    <section class='header cmt-title cap theme'>
      <p>快来参与讨论吧~</p>

    </section>
    <section class='body cmt-body giscus'>
      

<svg class="loading" style="vertical-align:middle;fill:currentColor;overflow:hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg>

<div id="giscus" src="https://giscus.app/client.js" data-repo="kuzemax/blogcomment" data-repo-id="R_kgDONHzubA" data-category="Announcements" data-category-id="DIC_kwDONHzubM4Cjz7s" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous"></div>

    </section>
  </div>



<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">kuzemax</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.29.1">Stellar 1.29.1</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#ModbusData%EF%BC%9A%E5%AE%9A%E4%B9%89%E4%BA%86%E4%B8%80%E4%B8%AA%E7%BB%93%E6%9E%84%E4%BD%93%E6%9D%A5%E5%AD%98%E5%82%A8%E8%A7%A3%E6%9E%90%E5%90%8E%E7%9A%84-Modbus-%E6%95%B0%E6%8D%AE%E3%80%82"><span class="toc-text">-- ModbusData：定义了一个结构体来存储解析后的 Modbus 数据。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%99%E6%98%AF%E6%8F%92%E4%BB%B6%E7%9A%84%E5%85%A5%E5%8F%A3%E7%82%B9%EF%BC%8C%E5%BD%93-Arkime-%E5%8A%A0%E8%BD%BD%E6%8F%92%E4%BB%B6%E6%97%B6%E4%BC%9A%E8%A2%AB%E8%B0%83%E7%94%A8%E3%80%82-arkime-plugins-register-internal-%E2%80%A6-%E5%90%91-Arkime-%E6%B3%A8%E5%86%8C%E6%8F%92%E4%BB%B6%E3%80%82-TRUE-%E8%A1%A8%E7%A4%BA%E6%AD%A4%E6%8F%92%E4%BB%B6%E4%BC%9A%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E3%80%82-arkime-field-define-%E2%80%A6-%EF%BC%9A%E5%AE%9A%E4%B9%89-Arkime-%E5%AD%97%E6%AE%B5%E3%80%82-%E6%AF%8F%E4%B8%AA-arkime-field-define-%E8%B0%83%E7%94%A8%E9%83%BD%E4%B8%BA-Modbus-%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%AD%97%E6%AE%B5%E3%80%82-%E8%BF%99%E4%BA%9B%E5%AD%97%E6%AE%B5%E5%B0%86%E5%9C%A8-Arkime-%E7%9A%84-Web-%E7%95%8C%E9%9D%A2%E4%B8%AD%E5%8F%AF%E8%A7%81%E3%80%82"><span class="toc-text">-- 这是插件的入口点，当 Arkime 加载插件时会被调用。- arkime_plugins_register_internal(…): 向 Arkime 注册插件。 TRUE 表示此插件会修改数据。- arkime_field_define(…)：定义 Arkime 字段。 每个 arkime_field_define 调用都为 Modbus 协议的一个属性创建一个新的字段。 这些字段将在 Arkime 的 Web 界面中可见。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%95%B0%E6%8D%AE%E5%8C%85%E6%98%AF%E5%90%A6%E7%AC%A6%E5%90%88-Modbus-TCP-%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A6%81%E6%B1%82%EF%BC%9A"><span class="toc-text">-- 检查数据包是否符合 Modbus TCP 格式的基本要求：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%99%E6%98%AF%E5%A4%84%E7%90%86-Modbus-%E6%B5%81%E9%87%8F%E7%9A%84%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E3%80%82-%E9%A6%96%E5%85%88%EF%BC%8C%E5%AE%83%E6%A3%80%E6%9F%A5%E6%95%B0%E6%8D%AE%E5%8C%85%E9%95%BF%E5%BA%A6%E5%92%8C%E6%98%AF%E5%90%A6%E4%B8%BA-Modbus-%E6%B5%81%E9%87%8F%E3%80%82-%E7%84%B6%E5%90%8E%EF%BC%8C%E5%AE%83%E5%88%86%E9%85%8D%E4%B8%80%E4%B8%AA-ModbusData-%E7%BB%93%E6%9E%84%E4%BD%93%E6%9D%A5%E5%AD%98%E5%82%A8%E8%A7%A3%E6%9E%90%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E3%80%82-%E8%B0%83%E7%94%A8-modbus-parse-pdu-%E5%87%BD%E6%95%B0%E6%9D%A5%E8%A7%A3%E6%9E%90-Modbus-%E5%BA%94%E7%94%A8%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83-PDU-%E3%80%82-%E5%A6%82%E6%9E%9C%E8%A7%A3%E6%9E%90%E6%88%90%E5%8A%9F%EF%BC%8C%E5%AE%83%E4%BD%BF%E7%94%A8-arkime-field-int-add-%E5%92%8C-arkime-field-string-add-%E5%87%BD%E6%95%B0%E5%B0%86%E8%A7%A3%E6%9E%90%E5%87%BA%E7%9A%84-Modbus-%E6%95%B0%E6%8D%AE%E6%B7%BB%E5%8A%A0%E5%88%B0-Arkime-%E4%BC%9A%E8%AF%9D%E7%9A%84%E7%9B%B8%E5%BA%94%E5%AD%97%E6%AE%B5%E4%B8%AD%E3%80%82"><span class="toc-text">-- 这是处理 Modbus 流量的核心函数。- 首先，它检查数据包长度和是否为 Modbus 流量。- 然后，它分配一个 ModbusData 结构体来存储解析后的数据。- 调用 modbus_parse_pdu() 函数来解析 Modbus 应用数据单元 (PDU)。- 如果解析成功，它使用 arkime_field_int_add() 和 arkime_field_string_add() 函数将解析出的 Modbus 数据添加到 Arkime 会话的相应字段中。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%99%E4%B8%AA%E5%87%BD%E6%95%B0%E8%B4%9F%E8%B4%A3%E8%A7%A3%E6%9E%90-Modbus-%E5%BA%94%E7%94%A8%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83-PDU-%E3%80%82-%E5%AE%83%E9%A6%96%E5%85%88%E6%8F%90%E5%8F%96-Modbus-%E6%B6%88%E6%81%AF%E5%A4%B4%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5%EF%BC%88%E4%BA%8B%E5%8A%A1-ID%E3%80%81%E5%8D%8F%E8%AE%AE-ID%E3%80%81%E9%95%BF%E5%BA%A6%E3%80%81%E5%8D%95%E5%85%83-ID%E3%80%81%E5%8A%9F%E8%83%BD%E7%A0%81%EF%BC%89%E3%80%82-%E7%84%B6%E5%90%8E%EF%BC%8C%E5%AE%83%E6%A0%B9%E6%8D%AE%E5%8A%9F%E8%83%BD%E7%A0%81%E6%9D%A5%E8%A7%A3%E6%9E%90-PDU-%E7%9A%84%E5%85%B6%E4%BD%99%E9%83%A8%E5%88%86%EF%BC%9A"><span class="toc-text">-- 这个函数负责解析 Modbus 应用数据单元 (PDU)。- 它首先提取 Modbus 消息头中的字段（事务 ID、协议 ID、长度、单元 ID、功能码）。- 然后，它根据功能码来解析 PDU 的其余部分：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%A4%B4%E6%96%87%E4%BB%B6-%E5%8C%85%E5%90%AB%E4%BA%86%E5%BF%85%E8%A6%81%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6%EF%BC%8C%E4%B8%8E-Modbus-%E6%8F%92%E4%BB%B6%E7%B1%BB%E4%BC%BC%E3%80%823-%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89-%E5%AE%9A%E4%B9%89%E4%BA%86-Ethernet-IP-%E7%AB%AF%E5%8F%A3%E5%8F%B7%E5%92%8C%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84-CIP-Service-Codes%E3%80%824-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-EthernetIPData-%E7%BB%93%E6%9E%84%E4%BD%93%E7%94%A8%E4%BA%8E%E5%AD%98%E5%82%A8-Ethernet-IP-%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%8C%85%E6%8B%AC-Encap-Header-%E7%9A%84%E5%AD%97%E6%AE%B5%E5%92%8C-CIP-%E6%95%B0%E6%8D%AE%E3%80%82-%E8%BF%99%E4%B8%AA%E7%BB%93%E6%9E%84%E4%BD%93%E6%98%AF%E7%AE%80%E5%8C%96%E7%9A%84%EF%BC%8C%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%AD%E9%9C%80%E8%A6%81%E6%A0%B9%E6%8D%AE-CIP-%E5%8D%8F%E8%AE%AE%E8%BF%9B%E8%A1%8C%E6%89%A9%E5%B1%95%E3%80%825-%E6%8F%92%E4%BB%B6%E5%88%9D%E5%A7%8B%E5%8C%96-arkime-plugin-init-%E5%87%BD%E6%95%B0%E6%B3%A8%E5%86%8C%E6%8F%92%E4%BB%B6%E3%80%81%E5%AE%9A%E4%B9%89-Arkime-%E5%AD%97%E6%AE%B5%EF%BC%8C%E5%B9%B6%E6%B3%A8%E5%86%8C%E4%BA%86-TCP-%E7%AB%AF%E5%8F%A3-44818-%E7%9A%84%E6%B5%81%E9%87%8F%E5%A4%84%E7%90%86%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0-ethernetip-process-tcp-payload%E3%80%826-ethernetip-is-ethernetip-%E5%87%BD%E6%95%B0-%E7%AE%80%E5%8D%95%E7%9A%84%E5%88%A4%E6%96%AD%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%A0%B9%E6%8D%AE%E5%AE%9E%E9%99%85%E6%83%85%E5%86%B5%E5%A2%9E%E5%8A%A0%E5%88%A4%E6%96%AD%E9%80%BB%E8%BE%917-ethernetip-process-tcp-payload-%E5%87%BD%E6%95%B0"><span class="toc-text">1.2. 头文件: 包含了必要的头文件，与 Modbus 插件类似。3. 常量定义: 定义了 Ethernet&#x2F;IP 端口号和一些常用的 CIP Service Codes。4. 数据结构: EthernetIPData 结构体用于存储 Ethernet&#x2F;IP 数据，包括 Encap Header 的字段和 CIP 数据。 这个结构体是简化的，实际应用中需要根据 CIP 协议进行扩展。5. 插件初始化: arkime_plugin_init() 函数注册插件、定义 Arkime 字段，并注册了 TCP 端口 44818 的流量处理回调函数 ethernetip_process_tcp_payload。6. ethernetip_is_ethernetip 函数: 简单的判断，可以根据实际情况增加判断逻辑7. ethernetip_process_tcp_payload 函数:</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%80%94-%E9%85%8D%E7%BD%AE-%E6%A0%B9%E6%8D%AE%E4%BD%A0%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE-%E2%80%94"><span class="toc-text">— 配置 (根据你的虚拟机配置) —</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%80%94-%E6%9E%84%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%8C%85-%E2%80%94"><span class="toc-text">— 构建数据包 —</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Ethernet-%E5%B1%82"><span class="toc-text">1. Ethernet 层</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-IP-%E5%B1%82"><span class="toc-text">2. IP 层</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-TCP-%E5%B1%82-Ethernet-IP-%E9%80%9A%E5%B8%B8%E5%9F%BA%E4%BA%8E-TCP"><span class="toc-text">3. TCP 层 (Ethernet&#x2F;IP 通常基于 TCP)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-ENIP-CIP-%E6%95%B0%E6%8D%AE-%E6%89%8B%E5%8A%A8%E6%9E%84%E5%BB%BA-NOP-No-Operation-%E5%91%BD%E4%BB%A4"><span class="toc-text">4. ENIP&#x2F;CIP 数据 (手动构建) - NOP (No Operation) 命令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%80%94-%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E5%8C%85-%E4%BD%BF%E7%94%A8-Scapy-%E7%9A%84-Raw-%E5%B1%82-%E2%80%94"><span class="toc-text">— 组合数据包 (使用 Scapy 的 Raw 层) —</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%80%94-%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%8C%85-%E2%80%94"><span class="toc-text">— 发送数据包 —</span></a></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a><a class="buttom" onclick="util.scrollComment()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M10.46 1.25h3.08c1.603 0 2.86 0 3.864.095c1.023.098 1.861.3 2.6.752a5.75 5.75 0 0 1 1.899 1.899c.452.738.654 1.577.752 2.6c.095 1.004.095 2.261.095 3.865v1.067c0 1.141 0 2.036-.05 2.759c-.05.735-.153 1.347-.388 1.913a5.75 5.75 0 0 1-3.112 3.112c-.805.334-1.721.408-2.977.43a10.81 10.81 0 0 0-.929.036c-.198.022-.275.054-.32.08c-.047.028-.112.078-.224.232c-.121.166-.258.396-.476.764l-.542.916c-.773 1.307-2.69 1.307-3.464 0l-.542-.916a10.605 10.605 0 0 0-.476-.764c-.112-.154-.177-.204-.224-.232c-.045-.026-.122-.058-.32-.08c-.212-.023-.49-.03-.93-.037c-1.255-.021-2.171-.095-2.976-.429A5.75 5.75 0 0 1 1.688 16.2c-.235-.566-.338-1.178-.389-1.913c-.049-.723-.049-1.618-.049-2.76v-1.066c0-1.604 0-2.86.095-3.865c.098-1.023.3-1.862.752-2.6a5.75 5.75 0 0 1 1.899-1.899c.738-.452 1.577-.654 2.6-.752C7.6 1.25 8.857 1.25 10.461 1.25M6.739 2.839c-.914.087-1.495.253-1.959.537A4.25 4.25 0 0 0 3.376 4.78c-.284.464-.45 1.045-.537 1.96c-.088.924-.089 2.11-.089 3.761v1c0 1.175 0 2.019.046 2.685c.045.659.131 1.089.278 1.441a4.25 4.25 0 0 0 2.3 2.3c.515.214 1.173.294 2.429.316h.031c.398.007.747.013 1.037.045c.311.035.616.104.909.274c.29.17.5.395.682.645c.169.232.342.525.538.856l.559.944a.52.52 0 0 0 .882 0l.559-.944c.196-.331.37-.624.538-.856c.182-.25.392-.476.682-.645c.293-.17.598-.24.909-.274c.29-.032.639-.038 1.037-.045h.032c1.255-.022 1.913-.102 2.428-.316a4.25 4.25 0 0 0 2.3-2.3c.147-.352.233-.782.278-1.441c.046-.666.046-1.51.046-2.685v-1c0-1.651 0-2.837-.089-3.762c-.087-.914-.253-1.495-.537-1.959a4.25 4.25 0 0 0-1.403-1.403c-.464-.284-1.045-.45-1.96-.537c-.924-.088-2.11-.089-3.761-.089h-3c-1.651 0-2.837 0-3.762.089" clip-rule="evenodd"/><path fill="currentColor" d="M9 11a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0"/></svg><span>参与讨论</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"skip_search":null,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js`,
    marked: `https://cdn.jsdelivr.net/npm/marked@13.0.1/lib/marked.umd.min.js`
  }
  

</script>

<script type="text/javascript">
  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },
    
    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function(response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function(data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function(error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
  };
</script>

<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>


<!-- required -->
<script src="/js/main.js?v=1.29.1" defer></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    applyThemeToGiscus(theme)
  }

  const applyThemeToGiscus = (theme) => {
    theme = theme === 'auto' ? 'preferred_color_scheme' : theme

    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)

    const messages = {
      light: `切换到浅色模式`,
      dark: `切换到深色模式`,
      auto: `切换到跟随系统配色`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    }
  })()
</script>


<!-- optional -->

  <script type="module">
  const el = document.querySelector('#comments #giscus');
  util.viewportLazyload(el, load_discus, false);

  function load_discus() {
    if (!el) return;
    try {
        el.innerHTML = '';
      } catch (error) {
        console.error(error);
      }
      const script = document.createElement('script');
      script.async = true;
      for (const key of Object.keys(el.attributes)) {
        const attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
  }
</script>




<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
