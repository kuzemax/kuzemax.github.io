[{"title":"编写基于arkime的工控插件的学习过程","path":"/2025/02/05/编写基于arkime的工控插件的学习过程/","content":"在虚拟机上安装samba服务器 sudo service smbd start 然后在主机上连接虚拟机 写代码会方便点插件要求：如何基于流量引擎Arkime开发OPC、Modbus、SiemensS7、Ethernet&#x2F;IP、IEC104⼯控协议解析插件.1.能够解析⼯控协议（OPC、Modbus、SiemensS7、Ethernet&#x2F;IP、IEC104）2.以插件so⽅式集成到 Arkime 流量解析引擎3.将解析数据存储到 Elasticsearch,⽀持在Arkime Viewer 界⾯中搜索和查看。技 术 要 求1.兼容多种架构。2.C语⾔开发、涉及第三⽅库或插件的依赖需采⽤静态编译⽅式。3.保证插件与Arkime流量解析引擎⽆缝协作，提升解析和搜索性能 这里先做Modbus插件测试 建立文件夹顺序 modbus-plugin CMakeList.txt build include src modbus_plugin.c modbus_plugin.c的内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;time.h&gt;#include &lt;glib.h&gt; // 包含 glib.h 头文件#include &lt;dlfcn.h&gt; // 包含 dlfcn.h 头文件#include &quot;arkime.h&quot;extern ArkimeConfig_t config;#define ARKIME_API_VERSION 542#define ARKIME_SESSIONID_LEN 40// Modbus 功能码定义#define MODBUS_READ_COILS 0x01#define MODBUS_READ_DISCRETE_INPUTS 0x02#define MODBUS_READ_HOLDING_REGISTERS 0x03#define MODBUS_READ_INPUT_REGISTERS 0x04#define MODBUS_WRITE_SINGLE_COIL 0x05#define MODBUS_WRITE_SINGLE_REGISTER 0x06#define MODBUS_WRITE_MULTIPLE_COILS 0x0F#define MODBUS_WRITE_MULTIPLE_REGISTERS 0x10// Modbus 异常码定义#define MODBUS_EXC_ILLEGAL_FUNCTION 0x01#define MODBUS_EXC_ILLEGAL_DATA_ADDRESS 0x02#define MODBUS_EXC_ILLEGAL_DATA_VALUE 0x03#define MODBUS_EXC_SLAVE_DEVICE_FAILURE 0x04#define MODBUS_EXC_ACKNOWLEDGE 0x05#define MODBUS_EXC_SLAVE_DEVICE_BUSY 0x06#define MODBUS_EXC_NEGATIVE_ACKNOWLEDGE 0x07#define MODBUS_EXC_MEMORY_PARITY_ERROR 0x08// 定义 Modbus 数据结构typedef struct &#123; uint16_t transactionId; uint16_t protocolId; uint16_t length; uint8_t unitId; uint8_t functionCode; uint16_t address; // 数据地址 uint16_t quantity; // 读取或者写入的数量 uint16_t value; // 单个寄存器或线圈的值 uint8_t *data; // 写入或读取的数据 uint16_t dataLength; // 数据长度 uint8_t exceptionCode; // 异常码 char *description; // 描述信息&#125; ModbusData;// 全局变量，存储字段位置static int modbus_transaction_id_field;static int modbus_function_code_field;static int modbus_description_field;static int modbus_unit_id_field;static int modbus_address_field;static int modbus_quantity_field;static int modbus_data_field;static int modbus_src_port_field;static int modbus_dest_port_field;static int modbus_exc_code_field;// 函数声明 (保持不变)void modbus_free_data(ModbusData *data);void modbus_process_tcp_payload(ArkimeSession_t *session, const uint8_t *payload, int len);int modbus_parse_pdu(const uint8_t *payload, int len, ModbusData *modbusData);// 自定义错误打印函数，带时间戳void modbus_log(const char *format, ...) &#123; va_list args; va_start(args, format); time_t timer; char buffer[26]; struct tm tm_info; // 声明 struct tm 变量 time(&amp;timer); localtime_r(&amp;timer, &amp;tm_info); // 使用 localtime_r 函数 strftime(buffer, 26, &quot;%Y-%m-%d %H:%M:%S&quot;, &amp;tm_info); // 传递指针 fprintf(stderr, &quot;%s [modbus_plugin] &quot;, buffer); vfprintf(stderr, format, args); fprintf(stderr, &quot; &quot;); va_end(args); fflush(stderr);&#125;/******************************************************************************/// 插件初始化函数void arkime_plugin_init() &#123; modbus_log(&quot;arkime_plugin_init() called&quot;); // 注册插件 int rc = arkime_plugins_register_internal(&quot;modbus&quot;, TRUE, sizeof(ArkimeSession_t), ARKIME_API_VERSION); if (rc == -1) &#123; fprintf(stderr, &quot;ERROR: Couldn&#x27;t register plugin &quot;); exit(1); &#125; // 定义 Arkime 字段 modbus_transaction_id_field = arkime_field_define(&quot;modbus&quot;, &quot;integer&quot;, &quot;modbus.transactionId&quot;, &quot;Modbus Transaction ID&quot;, &quot;modbus.transactionId&quot;, &quot;Modbus Transaction ID&quot;, ARKIME_FIELD_TYPE_INT_HASH, 0, NULL); modbus_function_code_field = arkime_field_define(&quot;modbus&quot;, &quot;integer&quot;, &quot;modbus.functionCode&quot;, &quot;Modbus Function Code&quot;, &quot;modbus.functionCode&quot;, &quot;Modbus Function Code&quot;, ARKIME_FIELD_TYPE_INT_HASH, 0, NULL); modbus_description_field = arkime_field_define(&quot;modbus&quot;, &quot;string&quot;, &quot;modbus.description&quot;, &quot;Modbus Description&quot;, &quot;modbus.description&quot;, &quot;Modbus Description&quot;, ARKIME_FIELD_TYPE_STR_HASH, 0, NULL); modbus_unit_id_field = arkime_field_define(&quot;modbus&quot;, &quot;integer&quot;, &quot;modbus.unitId&quot;, &quot;Modbus Unit ID&quot;, &quot;modbus.unitId&quot;, &quot;Modbus Unit ID&quot;, ARKIME_FIELD_TYPE_INT_HASH, 0, NULL); modbus_address_field = arkime_field_define(&quot;modbus&quot;, &quot;integer&quot;, &quot;modbus.address&quot;, &quot;Modbus Address&quot;, &quot;modbus.address&quot;, &quot;Modbus Address&quot;, ARKIME_FIELD_TYPE_INT_HASH, 0, NULL); modbus_quantity_field = arkime_field_define(&quot;modbus&quot;, &quot;integer&quot;, &quot;modbus.quantity&quot;, &quot;Modbus Quantity&quot;, &quot;modbus.quantity&quot;, &quot;Modbus Quantity&quot;, ARKIME_FIELD_TYPE_INT_HASH, 0, NULL); modbus_data_field = arkime_field_define(&quot;modbus&quot;, &quot;string&quot;, &quot;modbus.data&quot;, &quot;Modbus Data&quot;, &quot;modbus.data&quot;, &quot;Modbus Data&quot;, ARKIME_FIELD_TYPE_STR_HASH, 0, NULL); modbus_src_port_field = arkime_field_define(&quot;modbus&quot;, &quot;integer&quot;, &quot;modbus.srcPort&quot;, &quot;Modbus Source Port&quot;, &quot;modbus.srcPort&quot;, &quot;Modbus Source Port&quot;, ARKIME_FIELD_TYPE_INT_HASH, 0, NULL); modbus_dest_port_field = arkime_field_define(&quot;modbus&quot;, &quot;integer&quot;, &quot;modbus.destPort&quot;, &quot;Modbus Destination Port&quot;, &quot;modbus.destPort&quot;, &quot;Modbus Destination Port&quot;, ARKIME_FIELD_TYPE_INT_HASH, 0, NULL); modbus_exc_code_field = arkime_field_define(&quot;modbus&quot;, &quot;integer&quot;, &quot;modbus.exceptionCode&quot;, &quot;Modbus Exception Code&quot;, &quot;modbus.exceptionCode&quot;, &quot;Modbus Exception Code&quot;, ARKIME_FIELD_TYPE_INT_HASH, 0, NULL); // 注册 TCP 端口 502 的流量处理回调函数 arkime_parsers_classifier_register_port(&quot;modbus&quot;, NULL, 502, ARKIME_PARSERS_PORT_TCP, (ArkimeClassifyFunc)modbus_process_tcp_payload); modbus_log(&quot;modbus plugin initialized!&quot;);&#125;/******************************************************************************/// 判断是否是 Modbus 数据 (更严格的检查) (保持不变)int modbus_is_modbus(const uint8_t *payload, int len) &#123; if (len &lt; 7) &#123; modbus_log(&quot;modbus_is_modbus: len &lt; 7, returning FALSE&quot;); return FALSE; &#125; // 检查协议标识符, Modbus TCP 固定为 0 uint16_t protocolId = ntohs(*(uint16_t*)(payload + 2)); if (protocolId != 0) &#123; modbus_log(&quot;modbus_is_modbus: protocolId != 0, returning FALSE&quot;); return FALSE; &#125; // 检查长度字段，确保其值与实际长度匹配 (减去前 6 个字节) uint16_t expectedLength = ntohs(*(uint16_t*)(payload + 4)); if (expectedLength != len - 6) &#123; modbus_log(&quot;modbus_is_modbus: expectedLength != len - 6, returning FALSE&quot;); return FALSE; &#125; modbus_log(&quot;modbus_is_modbus: is Modbus TCP&quot;); return TRUE;&#125;/******************************************************************************/// 处理 TCP 数据包void modbus_process_tcp_payload(ArkimeSession_t *session, const uint8_t *payload, int len) &#123; char sessionString[ARKIME_SESSIONID_LEN]; arkime_session_id_string(session-&gt;sessionId, sessionString); modbus_log(&quot;modbus_process_tcp_payload called, len = %d, session id = %s&quot;, len, sessionString); if (len &lt;= 0) &#123; modbus_log(&quot;modbus_process_tcp_payload: len &lt;= 0, returning&quot;); return; &#125; // 判断是否是 Modbus 数据 if (!modbus_is_modbus(payload, len)) &#123; modbus_log(&quot;modbus_process_tcp_payload: not Modbus traffic, returning&quot;); return; &#125; ModbusData *modbusData = ARKIME_TYPE_ALLOC0(ModbusData); // 使用 Arkime 的内存分配函数 if (!modbusData) &#123; modbus_log(&quot;ERROR - 内存分配失败&quot;); return; &#125; modbus_log(&quot;modbus_process_tcp_payload: Modbus data detected, parsing PDU&quot;); // 解析 Modbus PDU if (modbus_parse_pdu(payload, len, modbusData) == 0) &#123; modbus_log(&quot;modbus_process_tcp_payload: modbus_parse_pdu success, adding fields&quot;); // 添加 Modbus 数据到 Arkime 字段 arkime_field_int_add(modbus_transaction_id_field, session, modbusData-&gt;transactionId); modbus_log(&quot;modbus_process_tcp_payload: added transactionId = %u&quot;, modbusData-&gt;transactionId); arkime_field_int_add(modbus_function_code_field, session, modbusData-&gt;functionCode); modbus_log(&quot;modbus_process_tcp_payload: added functionCode = %u&quot;, modbusData-&gt;functionCode); arkime_field_int_add(modbus_unit_id_field, session, modbusData-&gt;unitId); modbus_log(&quot;modbus_process_tcp_payload: added unitId = %u&quot;, modbusData-&gt;unitId); arkime_field_int_add(modbus_address_field, session, modbusData-&gt;address); modbus_log(&quot;modbus_process_tcp_payload: added address = %u&quot;, modbusData-&gt;address); arkime_field_int_add(modbus_quantity_field, session, modbusData-&gt;quantity); modbus_log(&quot;modbus_process_tcp_payload: added quantity = %u&quot;, modbusData-&gt;quantity); arkime_field_int_add(modbus_src_port_field, session, session-&gt;port1); modbus_log(&quot;modbus_process_tcp_payload: added srcPort = %u&quot;, session-&gt;port1); arkime_field_int_add(modbus_dest_port_field, session, session-&gt;port2); modbus_log(&quot;modbus_process_tcp_payload: added destPort = %u&quot;, session-&gt;port2); if (modbusData-&gt;exceptionCode != 0)&#123; arkime_field_int_add(modbus_exc_code_field, session, modbusData-&gt;exceptionCode); modbus_log(&quot;modbus_process_tcp_payload: added exceptionCode = %u&quot;, modbusData-&gt;exceptionCode); &#125; // 避免 NULL 指针解引用 if (modbusData-&gt;description != NULL) &#123; arkime_field_string_add(modbus_description_field, session, modbusData-&gt;description, -1, TRUE); modbus_log(&quot;modbus_process_tcp_payload: added description = %s&quot;,modbusData-&gt;description); &#125; else &#123; modbus_log(&quot;modbus_process_tcp_payload: description is NULL&quot;); &#125; modbus_free_data(modbusData); &#125; else &#123; modbus_log(&quot;modbus_process_tcp_payload: modbus_parse_pdu failed&quot;); modbus_free_data(modbusData); &#125;&#125;/******************************************************************************/// 解析 Modbus PDU (保持不变)int modbus_parse_pdu(const uint8_t *payload, int len, ModbusData *modbusData) &#123; modbus_log(&quot;modbus_parse_pdu called, len = %d&quot;, len); if (len &lt; 8) &#123; modbus_log(&quot;modbus_parse_pdu: len &lt; 8, returning -1&quot;); return -1; // 至少需要 8 个字节 &#125; modbusData-&gt;transactionId = ntohs(*(uint16_t*)(payload + 0)); modbus_log(&quot;modbus_parse_pdu: transactionId = %u&quot;,modbusData-&gt;transactionId); modbusData-&gt;protocolId = ntohs(*(uint16_t*)(payload + 2)); modbus_log(&quot;modbus_parse_pdu: protocolId = %u&quot;,modbusData-&gt;protocolId); modbusData-&gt;length = ntohs(*(uint16_t*)(payload + 4)); modbus_log(&quot;modbus_parse_pdu: length = %u&quot;,modbusData-&gt;length); modbusData-&gt;unitId = payload[6]; modbus_log(&quot;modbus_parse_pdu: unitId = %u&quot;,modbusData-&gt;unitId); modbusData-&gt;functionCode = payload[7]; modbus_log(&quot;modbus_parse_pdu: functionCode = %u&quot;,modbusData-&gt;functionCode); const uint8_t *pdu = payload + 8; int pdu_len = len - 8; modbusData-&gt;description = &quot;Unknown&quot;; // 设置默认值 switch (modbusData-&gt;functionCode) &#123; case MODBUS_READ_COILS: // 0x01 case MODBUS_READ_DISCRETE_INPUTS: // 0x02 case MODBUS_READ_HOLDING_REGISTERS: // 0x03 case MODBUS_READ_INPUT_REGISTERS: // 0x04 &#123; if (pdu_len &lt; 4) &#123; modbus_log(&quot;modbus_parse_pdu: read function, pdu_len &lt; 4, returning -1&quot;); return -1; &#125; modbusData-&gt;address = ntohs(*(uint16_t*)(pdu + 0)); modbus_log(&quot;modbus_parse_pdu: address = %u&quot;, modbusData-&gt;address); modbusData-&gt;quantity = ntohs(*(uint16_t*)(pdu + 2)); modbus_log(&quot;modbus_parse_pdu: quantity = %u&quot;,modbusData-&gt;quantity); switch (modbusData-&gt;functionCode) &#123; case MODBUS_READ_COILS: modbusData-&gt;description = &quot;Read Coils&quot;; modbus_log(&quot;modbus_parse_pdu: description = Read Coils&quot;); break; case MODBUS_READ_DISCRETE_INPUTS: modbusData-&gt;description = &quot;Read Discrete Inputs&quot;; modbus_log(&quot;modbus_parse_pdu: description = Read Discrete Inputs&quot;); break; case MODBUS_READ_HOLDING_REGISTERS: modbusData-&gt;description = &quot;Read Holding Registers&quot;; modbus_log(&quot;modbus_parse_pdu: description = Read Holding Registers&quot;); break; case MODBUS_READ_INPUT_REGISTERS: modbusData-&gt;description = &quot;Read Input Registers&quot;; modbus_log(&quot;modbus_parse_pdu: description = Read Input Registers&quot;); break; &#125; break; &#125; case MODBUS_WRITE_SINGLE_COIL: // 0x05 case MODBUS_WRITE_SINGLE_REGISTER: // 0x06 &#123; if (pdu_len &lt; 4) &#123; modbus_log(&quot;modbus_parse_pdu: write single function, pdu_len &lt; 4, returning -1&quot;); return -1; &#125; modbusData-&gt;address = ntohs(*(uint16_t*)(pdu + 0)); modbus_log(&quot;modbus_parse_pdu: address = %u&quot;, modbusData-&gt;address); modbusData-&gt;value = ntohs(*(uint16_t*)(pdu + 2)); modbus_log(&quot;modbus_parse_pdu: value = %u&quot;,modbusData-&gt;value); switch (modbusData-&gt;functionCode) &#123; case MODBUS_WRITE_SINGLE_COIL: modbusData-&gt;description = &quot;Write Single Coil&quot;; modbus_log(&quot;modbus_parse_pdu: description = Write Single Coil&quot;); break; case MODBUS_WRITE_SINGLE_REGISTER: modbusData-&gt;description = &quot;Write Single Register&quot;; modbus_log(&quot;modbus_parse_pdu: description = Write Single Register&quot;); break; &#125; break; &#125; case MODBUS_WRITE_MULTIPLE_COILS: // 0x0F case MODBUS_WRITE_MULTIPLE_REGISTERS: // 0x10 &#123; if (pdu_len &lt; 5) &#123; modbus_log(&quot;modbus_parse_pdu: write multiple function, pdu_len &lt; 5, returning -1&quot;); return -1; &#125; modbusData-&gt;address = ntohs(*(uint16_t*)(pdu + 0)); modbus_log(&quot;modbus_parse_pdu: address = %u&quot;,modbusData-&gt;address); modbusData-&gt;quantity = ntohs(*(uint16_t*)(pdu + 2)); modbus_log(&quot;modbus_parse_pdu: quantity = %u&quot;,modbusData-&gt;quantity); modbusData-&gt;dataLength = pdu[4]; modbus_log(&quot;modbus_parse_pdu: dataLength = %u&quot;,modbusData-&gt;dataLength); if (pdu_len &lt; 5 + modbusData-&gt;dataLength) &#123; modbus_log(&quot;modbus_parse_pdu: write multiple function, pdu_len &lt; 5 + dataLength, returning -1&quot;); return -1; &#125; modbusData-&gt;data = ARKIME_SIZE_ALLOC0(modbus_data, modbusData-&gt;dataLength); // 使用 Arkime 的内存分配函数 if (!modbusData-&gt;data) &#123; modbus_log(&quot;ERROR - 内存分配失败&quot;); return -1; &#125; memcpy(modbusData-&gt;data, pdu + 5, modbusData-&gt;dataLength); switch (modbusData-&gt;functionCode) &#123; case MODBUS_WRITE_MULTIPLE_COILS: modbusData-&gt;description = &quot;Write Multiple Coils&quot;; modbus_log(&quot;modbus_parse_pdu: description = Write Multiple Coils&quot;); break; case MODBUS_WRITE_MULTIPLE_REGISTERS: modbusData-&gt;description = &quot;Write Multiple Registers&quot;; modbus_log(&quot;modbus_parse_pdu: description = Write Multiple Registers&quot;); break; &#125; break; &#125; case 0x80 ... 0xFF: // Exception Response &#123; if (pdu_len &lt; 1) &#123; modbus_log(&quot;modbus_parse_pdu: exception response, pdu_len &lt; 1, returning -1&quot;); return -1; &#125; modbusData-&gt;exceptionCode = pdu[0]; modbus_log(&quot;modbus_parse_pdu: exceptionCode = %u&quot;,modbusData-&gt;exceptionCode); switch (modbusData-&gt;exceptionCode) &#123; case MODBUS_EXC_ILLEGAL_FUNCTION: modbusData-&gt;description = &quot;Exception: Illegal Function&quot;; modbus_log(&quot;modbus_parse_pdu: description = Exception: Illegal Function&quot;); break; case MODBUS_EXC_ILLEGAL_DATA_ADDRESS: modbusData-&gt;description = &quot;Exception: Illegal Data Address&quot;; modbus_log(&quot;modbus_parse_pdu: description = Exception: Illegal Data Address&quot;); break; case MODBUS_EXC_ILLEGAL_DATA_VALUE: modbusData-&gt;description = &quot;Exception: Illegal Data Value&quot;; modbus_log(&quot;modbus_parse_pdu: description = Exception: Illegal Data Value&quot;); break; case MODBUS_EXC_SLAVE_DEVICE_FAILURE: modbusData-&gt;description = &quot;Exception: Slave Device Failure&quot;; modbus_log(&quot;modbus_parse_pdu: description = Exception: Slave Device Failure&quot;); break; case MODBUS_EXC_ACKNOWLEDGE: modbusData-&gt;description = &quot;Exception: Acknowledge&quot;; modbus_log(&quot;modbus_parse_pdu: description = Exception: Acknowledge&quot;); break; case MODBUS_EXC_SLAVE_DEVICE_BUSY: modbusData-&gt;description = &quot;Exception: Slave Device Busy&quot;; modbus_log(&quot;modbus_parse_pdu: description = Exception: Slave Device Busy&quot;); break; case MODBUS_EXC_NEGATIVE_ACKNOWLEDGE: modbusData-&gt;description = &quot;Exception: Negative Acknowledge&quot;; modbus_log(&quot;modbus_parse_pdu: description = Exception: Negative Acknowledge&quot;); break; case MODBUS_EXC_MEMORY_PARITY_ERROR: modbusData-&gt;description = &quot;Exception: Memory Parity Error&quot;; modbus_log(&quot;modbus_parse_pdu: description = Exception: Memory Parity Error&quot;); break; default: modbusData-&gt;description = &quot;Exception: Unknown Error&quot;; modbus_log(&quot;modbus_parse_pdu: description = Exception: Unknown Error&quot;); break; &#125; break; &#125; default: modbus_log(&quot;modbus_parse_pdu: unknown function code, returning -1&quot;); return -1; &#125; return 0;&#125;/******************************************************************************/// 释放 ModbusData 结构体内存 (保持不变)void modbus_free_data(ModbusData *data) &#123; if (data) &#123; if (data-&gt;data) &#123; ARKIME_SIZE_FREE(modbus_data, data-&gt;data); // 使用 Arkime 的内存释放函数 &#125; ARKIME_TYPE_FREE(ModbusData, data); // 使用 Arkime 的内存释放函数 &#125;&#125;/******************************************************************************/// 供 Arkime 加载插件的函数#ifndef UNIT_TESTvoid arkime_plugin_load() &#123; #ifdef __linux__ // LOG(&quot;arkime_plugin_load() called, plugin path: %s&quot;, plugin_path); #endif modbus_log(&quot;arkime_plugin_load() called&quot;); arkime_plugin_init();&#125;#endif CMakeLists.txt 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152cmake_minimum_required(VERSION 3.0)project(modbus_plugin)# 设置编译选项set(CMAKE_C_STANDARD 99)set(CMAKE_C_FLAGS &quot;-Wall -fPIC&quot;)# Arkime 安装目录（根据你的实际情况修改）set(ARKIME_PREFIX /opt/arkime)# libmodbus 安装目录（指向你手动编译安装的 Libmodbus 目录）set(LIBMODBUS_PREFIX /opt/libmodbus)# GLib 安装目录# 方法1： 直接指定glibconfig.h所在的目录的上一级#set(GLIB_INCLUDE_DIR /usr/lib/glib-2.0/include) # 假设 glibconfig.h 在 /usr/lib/glib-2.0/include 目录下# 方法2： 更精确地指定所有需要的GLib头文件目录，确保万无一失include_directories( /usr/include/glib-2.0 /usr/lib/x86_64-linux-gnu/glib-2.0/include)# Jansson 安装目录 (根据你的实际情况修改, 如果需要)# 可以在 /usr/include 或 /usr/local/include 中尝试# 如果找不到 jansson.h , 先安装 libjansson-dev# sudo apt-get install libjansson-devset(JANSSON_INCLUDE_DIR /usr/include)# 包含头文件include_directories( $&#123;ARKIME_PREFIX&#125;/include $&#123;LIBMODBUS_PREFIX&#125;/include #$&#123;GLIB_INCLUDE_DIR&#125; # 注释掉，使用更精确的include目录 $&#123;JANSSON_INCLUDE_DIR&#125;)# 源文件set(SOURCE_FILES src/modbus_plugin.c)# 创建共享库add_library(modbus_plugin SHARED $&#123;SOURCE_FILES&#125;)# 设置链接选项，强制静态链接 libmodbustarget_link_libraries(modbus_plugin -L$&#123;LIBMODBUS_PREFIX&#125;/lib -lmodbus -lm -lglib-2.0 -ljansson)# 设置安装目录和目标install(TARGETS modbus_plugin DESTINATION /opt/arkime/plugins) 这段代码是一个 Arkime（Moloch）的插件，用于解析和提取 Modbus TCP 协议的数据。下面是对代码的详细中文解析： 1. 包含头文件和定义: - #include &lt;stdio.h&gt;：标准输入输出库。 #include &lt;string.h&gt;：字符串操作库。 #include &lt;stdlib.h&gt;：标准库，提供内存分配等函数。 #include &lt;stdint.h&gt;：提供固定大小整数类型。 #include &lt;arpa&#x2F;inet.h&gt;：提供网络字节序转换函数（如 ntohs）。 #include &lt;time.h&gt;：时间相关函数。 #include &lt;glib.h&gt;：GLib 库，提供了一些实用工具（虽然代码中没有直接使用）。 #include &lt;dlfcn.h&gt;：动态链接库函数（代码中没有直接使用）。 #include “arkime.h”：Arkime 的头文件，包含了插件开发所需的 API。 #define ARKIME_API_VERSION 542：定义 Arkime API 版本。 如果你的 Arkime 版本与此不匹配，需要更改。 #define ARKIME_SESSIONID_LEN 40：定义会话 ID 的长度。 #define MODBUS_…：定义 Modbus 功能码和异常码的常量。 这些是 Modbus 协议规范中定义的。 2. 数据结构: -- ModbusData：定义了一个结构体来存储解析后的 Modbus 数据。 transactionId：事务标识符。 protocolId：协议标识符（Modbus TCP 通常为 0）。 length：PDU 长度。 unitId：单元标识符。 functionCode：功能码。 address：数据地址。 quantity：数量（例如读取的寄存器数量）。 value：单个寄存器或线圈的值。 data：指向数据的指针（用于写入或读取多个寄存器&#x2F;线圈）。 dataLength：数据的长度。 exceptionCode：异常码。 description：功能的文本描述。 3. 全局变量: - modbus_…_field：一系列整数变量，用于存储 Arkime 字段的 ID。 这些 ID 是在插件初始化时通过 arkime_field_define 函数获取的。 这些变量用于将解析出的 Modbus 数据添加到 Arkime 的会话记录中。 4. 函数声明: - modbus_free_data(ModbusData *data)：释放 ModbusData 结构体占用的内存。 modbus_process_tcp_payload(ArkimeSession_t *session, const uint8_t *payload, int len)：处理 TCP 数据包的主要函数。 modbus_parse_pdu(const uint8_t *payload, int len, ModbusData *modbusData, ArkimeSession_t *session)：解析 Modbus PDU（协议数据单元）。 5. 自定义日志函数 modbus_log: - 这个函数类似于 printf，但它会在输出的消息前加上时间戳和 [modbus_plugin] 标签，并将输出写入到标准错误流 (stderr)。 这对于调试非常有用。使用了线程安全的 localtime_r 函数。 6. arkime_plugin_init() - 插件初始化: -- 这是插件的入口点，当 Arkime 加载插件时会被调用。- arkime_plugins_register_internal(…): 向 Arkime 注册插件。 TRUE 表示此插件会修改数据。- arkime_field_define(…)：定义 Arkime 字段。 每个 arkime_field_define 调用都为 Modbus 协议的一个属性创建一个新的字段。 这些字段将在 Arkime 的 Web 界面中可见。 第一个参数是插件名称 (“modbus”)。 第二个参数是字段类型 (“integer” 或 “string”)。 第三个参数是字段的内部名称 (例如 “modbus.transactionId”)。 第四个参数是字段的简短描述（在 Web 界面中显示）。 第五个参数是字段的长名称。 第六个参数是字段的描述。 第七个参数指定了字段的存储类型和选项. arkime_parsers_classifier_register_port(…)：注册一个分类器函数。 这告诉 Arkime，当它看到目标端口为 502（Modbus 的标准端口）的 TCP 流量时，应该调用 modbus_process_tcp_payload 函数来处理数据。 7. modbus_is_modbus() - 检查是否为 Modbus TCP 数据: -- 检查数据包是否符合 Modbus TCP 格式的基本要求： 长度至少为 7 字节。 协议标识符 (protocolId) 必须为 0。 长度字段必须与实际数据长度匹配。 8. modbus_process_tcp_payload() - 处理 TCP 数据包: -- 这是处理 Modbus 流量的核心函数。- 首先，它检查数据包长度和是否为 Modbus 流量。- 然后，它分配一个 ModbusData 结构体来存储解析后的数据。- 调用 modbus_parse_pdu() 函数来解析 Modbus 应用数据单元 (PDU)。- 如果解析成功，它使用 arkime_field_int_add() 和 arkime_field_string_add() 函数将解析出的 Modbus 数据添加到 Arkime 会话的相应字段中。 会话ID, 源&#x2F;目的端口也都被添加到会话记录中。 使用 arkime_sprint_hex_string 函数将二进制数据转换为十六进制字符串, 方便显示。 最后，它调用 modbus_free_data() 函数来释放 ModbusData 结构体占用的内存。 9. modbus_parse_pdu() - 解析 Modbus PDU: -- 这个函数负责解析 Modbus 应用数据单元 (PDU)。- 它首先提取 Modbus 消息头中的字段（事务 ID、协议 ID、长度、单元 ID、功能码）。- 然后，它根据功能码来解析 PDU 的其余部分： 对于读取类功能（0x01-0x04），它提取地址和数量。 对于单次写入类功能（0x05-0x06），它提取地址和值。 对于多次写入类功能（0x0F-0x10），它提取地址、数量、数据长度和数据。 对于异常响应（0x80-0xFF），它提取异常码。 为每种功能码和异常代码设置了描述性的字符串。 如果解析过程中出现任何错误（例如数据包长度不足），它会返回 -1。 它使用 ARKIME_SIZE_ALLOC0 和ARKIME_SIZE_FREE 确保正确地分配和释放数据缓冲区。 10. modbus_free_data() - 释放内存: - 释放 ModbusData 结构体占用的内存，包括动态分配的 data 缓冲区。 11. arkime_plugin_load() - 加载插件 (仅在非单元测试时): - 这个函数在插件被 Arkime 动态加载时调用。 它通常只是简单地调用 arkime_plugin_init()。 #ifndef UNIT_TEST 预处理指令确保这段代码只在非单元测试环境下编译。 关键改进和更正: - Arkime API 使用: 使用了 Arkime 的内存分配函数 (ARKIME_TYPE_ALLOC0, ARKIME_SIZE_ALLOC0, ARKIME_TYPE_FREE, ARKIME_SIZE_FREE)，以及其他 Arkime API 函数，确保与 Arkime 框架的兼容性。 内存管理: 正确地分配和释放了 ModbusData 结构体以及其中的 data 成员。 错误处理: 在 modbus_parse_pdu 函数中添加了更详细的错误检查，并在内存分配失败时进行了处理。在 modbus_process_tcp_payload 函数中增加了内存分配失败的判断。 日志记录: 添加了 modbus_log 函数，用于记录调试信息和错误信息，并包含时间戳。 字段添加: 在 modbus_process_tcp_payload 函数中，将解析出的 Modbus 数据正确地添加到了 Arkime 会话的字段中，包括源端口和目的端口。 对于字符串类型的字段，使用了 arkime_field_string_add 的安全版本，处理了可能为 NULL 的字符串, 使用-1 让Arkime自动计算字符串的长度。 PDU 解析: 更完整地解析了 Modbus PDU，包括对所有标准功能码和异常码的处理，并根据功能码设置了相应的描述。 Modbus 数据检查: modbus_is_modbus 函数现在进行了更严格的检查，确保数据包符合 Modbus TCP 格式。 会话ID打印: 在 modbus_process_tcp_payload函数的开头打印了会话ID， 方便调试。 异常处理: 对所有异常响应进行了处理，并设置了相应的描述。 默认值: 在modbus_parse_pdu函数的开头部分，对address、quantity 和exceptionCode 设置了默认值(0xFFFF, 0xFFFF, 0x00)。这可以避免在某些情况下，由于这些字段未被赋值而导致的显示问题。 线程安全的时间函数: 使用线程安全的 localtime_r 函数代替 localtime 函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;arkime.h&gt;#include &quot;dave.h&quot; // libnodave 的头文件// 定义 Elasticsearch 索引名称#define ES_INDEX &quot;s7-data&quot;// 插件配置结构体typedef struct &#123; char *es_host; int es_port;&#125; S7Config_t;S7Config_t s7Config;// Elasticsearch 写入函数 (简化版本，实际需要处理错误)void write_to_elasticsearch(const char *json_data) &#123; char url[256]; snprintf(url, sizeof(url), &quot;http://%s:%d/%s/_doc&quot;, s7Config.es_host, s7Config.es_port, ES_INDEX); // 使用 libcurl 或其他 HTTP 库发送 POST 请求到 Elasticsearch // 这里只是一个占位符，你需要实现实际的 HTTP 请求 printf(&quot;Sending to ES: %s &quot;, json_data); // 替换为实际的 HTTP 发送代码&#125;// S7 数据解析函数void parse_s7_data(const unsigned char *data, int len, ArkimeSession_t *session) &#123; // 使用 libnodave 解析 S7 数据包 // 注意：这里只是一个框架，你需要根据 S7 协议规范，编写实际的解析代码。 // S7 协议解析比较复杂，需要深入理解 S7 的 PDU 结构。 // 示例：假设我们提取了变量地址和值 char variable_address[32] = &quot;DB1.DBW0&quot;; int variable_value = 12345; // 构建 JSON 数据 char json_data[512]; snprintf(json_data, sizeof(json_data), &quot;&#123;&quot; &quot;\\&quot;timestamp\\&quot;: \\&quot;%lld\\&quot;,&quot; &quot;\\&quot;srcIp\\&quot;: \\&quot;%s\\&quot;,&quot; &quot;\\&quot;dstIp\\&quot;: \\&quot;%s\\&quot;,&quot; &quot;\\&quot;variableAddress\\&quot;: \\&quot;%s\\&quot;,&quot; &quot;\\&quot;variableValue\\&quot;: %d&quot; &quot;&#125;&quot;, (long long)session-&gt;firstPacket, arkime_session_string(session, &quot;srcIp&quot;), arkime_session_string(session, &quot;dstIp&quot;), variable_address, variable_value); // 将数据写入 Elasticsearch write_to_elasticsearch(json_data); // 添加到 Arkime 会话信息 (可选) // arkime_session_add_tag(session, &quot;s7&quot;);&#125;// 数据包处理函数int s7_plugin_process(ArkimeSession_t *session, ArkimePacket_t *packet) &#123; // 判断是否为 S7 流量 (例如，基于端口号或协议特征) if (packet-&gt;dstPort == 102) &#123; // 假设 S7 流量使用 102 端口 // 调用 S7 数据解析函数 parse_s7_data(packet-&gt;payload, packet-&gt;payloadLen, session); return 1; // 表示已处理 &#125; return 0; // 表示未处理&#125;// 插件初始化函数int s7_plugin_init() &#123; // 读取配置文件 (例如，elasticsearch 地址) g_arkime_config_bool(NULL, &quot;s7:enabled&quot;, TRUE); s7Config.es_host = g_arkime_config_string(NULL, &quot;s7:esHost&quot;, &quot;localhost&quot;); s7Config.es_port = g_arkime_config_int(NULL, &quot;s7:esPort&quot;, 9200); // 注册数据包处理函数 arkime_plugins_register(&quot;s7&quot;, TRUE, s7_plugin_process, NULL); LOG(&quot;S7 Plugin initialized!&quot;); return 0;&#125; 主要思路 1.2. 协议理解： Ethernet&#x2F;IP 是基于 CIP 协议的，它在 TCP&#x2F;UDP 之上封装了 CIP 协议。你需要理解 CIP 的连接建立、对象模型、服务等概念。3. 端口识别： Ethernet&#x2F;IP 通常使用 44818 端口。4. 数据结构： 定义一个合适的数据结构来存储解析出的 CIP 数据。5. 解析流程： 实现 CIP 协议的解析流程，包括连接建立、请求&#x2F;响应处理等。6. Arkime 集成： 将解析出的数据添加到 Arkime 字段中。 ethernetip_plugin.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;time.h&gt;#include &lt;glib.h&gt;#include &lt;dlfcn.h&gt;#include &quot;arkime.h&quot;extern ArkimeConfig_t config;#define ARKIME_API_VERSION 542#define ARKIME_SESSIONID_LEN 40// Ethernet/IP 端口#define ETHERNETIP_PORT 44818// CIP Service Codes (部分示例)#define CIP_SVC_GET_ATTRIB_SINGLE 0x0E#define CIP_SVC_SET_ATTRIB_SINGLE 0x10#define CIP_SVC_UNCONNECTED_SEND 0x52#define CIP_SVC_FORWARD_OPEN 0x54#define CIP_SVC_FORWARD_CLOSE 0x4E// 定义 Ethernet/IP 数据结构 (简化)typedef struct &#123; uint32_t encap_command; // Encap Command uint32_t encap_length; // Encap Length uint32_t encap_session; // Encap Session Handle uint32_t encap_status; // Encap Status uint64_t encap_sender_context; // Encap Sender Context (8 bytes) uint32_t encap_options; // Encap Options uint8_t *cip_data; // CIP Data uint32_t cip_length; // CIP Data Length uint8_t cip_service; // CIP Service Code (来自 CIP 数据) char *description; // 描述信息&#125; EthernetIPData;// 全局变量，存储字段位置static int ethernetip_command_field;static int ethernetip_session_field;static int ethernetip_status_field;static int ethernetip_service_field;static int ethernetip_description_field;static int ethernetip_src_port_field;static int ethernetip_dest_port_field;static int ethernetip_data_field;// 函数声明void ethernetip_free_data(EthernetIPData *data);void ethernetip_process_tcp_payload(ArkimeSession_t *session, const uint8_t *payload, int len);int ethernetip_parse_encap_header(const uint8_t *payload, int len, EthernetIPData *eipData);int ethernetip_parse_cip_data(const uint8_t *cip_data, int cip_len, EthernetIPData *eipData);// 自定义错误打印函数，带时间戳void ethernetip_log(const char *format, ...) &#123; va_list args; va_start(args, format); time_t timer; char buffer[26]; struct tm tm_info; // 声明 struct tm 变量 time(&amp;timer); localtime_r(&amp;timer, &amp;tm_info); // 使用 localtime_r 函数 strftime(buffer, 26, &quot;%Y-%m-%d %H:%M:%S&quot;, &amp;tm_info); // 传递指针 fprintf(stderr, &quot;%s [ethernetip_plugin] &quot;, buffer); vfprintf(stderr, format, args); fprintf(stderr, &quot; &quot;); va_end(args); fflush(stderr);&#125;/******************************************************************************/// 插件初始化函数void arkime_plugin_init() &#123; ethernetip_log(&quot;arkime_plugin_init() called&quot;); // 注册插件 int rc = arkime_plugins_register_internal(&quot;ethernetip&quot;, TRUE, sizeof(ArkimeSession_t), ARKIME_API_VERSION); if (rc == -1) &#123; fprintf(stderr, &quot;ERROR: Couldn&#x27;t register plugin &quot;); exit(1); &#125; // 定义 Arkime 字段 ethernetip_command_field = arkime_field_define(&quot;ethernetip&quot;, &quot;integer&quot;, &quot;ethernetip.command&quot;, &quot;EthernetIP Command&quot;, &quot;ethernetip.command&quot;, &quot;EthernetIP Command&quot;, ARKIME_FIELD_TYPE_INT_HASH, 0, NULL); ethernetip_session_field = arkime_field_define(&quot;ethernetip&quot;, &quot;integer&quot;, &quot;ethernetip.session&quot;, &quot;EthernetIP Session&quot;, &quot;ethernetip.session&quot;, &quot;EthernetIP Session&quot;, ARKIME_FIELD_TYPE_INT_HASH, 0, NULL); ethernetip_status_field = arkime_field_define(&quot;ethernetip&quot;, &quot;integer&quot;, &quot;ethernetip.status&quot;, &quot;EthernetIP Status&quot;, &quot;ethernetip.status&quot;, &quot;EthernetIP Status&quot;, ARKIME_FIELD_TYPE_INT_HASH, 0, NULL); ethernetip_service_field = arkime_field_define(&quot;ethernetip&quot;, &quot;integer&quot;, &quot;ethernetip.service&quot;, &quot;EthernetIP Service&quot;, &quot;ethernetip.service&quot;, &quot;EthernetIP Service&quot;, ARKIME_FIELD_TYPE_INT_HASH, 0, NULL); ethernetip_description_field = arkime_field_define(&quot;ethernetip&quot;, &quot;string&quot;, &quot;ethernetip.description&quot;, &quot;EthernetIP Description&quot;, &quot;ethernetip.description&quot;, &quot;EthernetIP Description&quot;, ARKIME_FIELD_TYPE_STR_HASH, 0, NULL); ethernetip_data_field = arkime_field_define(&quot;ethernetip&quot;, &quot;string&quot;, &quot;ethernetip.data&quot;, &quot;EthernetIP Data&quot;, &quot;ethernetip.data&quot;, &quot;EthernetIP Data&quot;, ARKIME_FIELD_TYPE_STR_HASH, 0, NULL); ethernetip_src_port_field = arkime_field_define(&quot;ethernetip&quot;, &quot;integer&quot;, &quot;ethernetip.srcPort&quot;, &quot;EthernetIP Source Port&quot;, &quot;ethernetip.srcPort&quot;, &quot;EthernetIP Source Port&quot;, ARKIME_FIELD_TYPE_INT_HASH, 0, NULL); ethernetip_dest_port_field = arkime_field_define(&quot;ethernetip&quot;, &quot;integer&quot;, &quot;ethernetip.destPort&quot;, &quot;EthernetIP Destination Port&quot;, &quot;ethernetip.destPort&quot;, &quot;EthernetIP Destination Port&quot;, ARKIME_FIELD_TYPE_INT_HASH, 0, NULL); // 注册 TCP 端口 44818 的流量处理回调函数 arkime_parsers_classifier_register_port(&quot;ethernetip&quot;, NULL, ETHERNETIP_PORT, ARKIME_PARSERS_PORT_TCP, (ArkimeClassifyFunc)ethernetip_process_tcp_payload); ethernetip_log(&quot;ethernetip plugin initialized!&quot;);&#125;/******************************************************************************/// 判断是否是 Ethernet/IP 数据 (基本判断)int ethernetip_is_ethernetip(const uint8_t *payload, int len) &#123; if (len &lt; 24) &#123; // Ethernet/IP Encapsulation Header is 24 bytes return FALSE; &#125; // 可以添加更严格的检查，例如检查 Encap Command 是否是已知的值 return TRUE;&#125;/******************************************************************************/// 处理 TCP 数据包void ethernetip_process_tcp_payload(ArkimeSession_t *session, const uint8_t *payload, int len) &#123; char sessionString[ARKIME_SESSIONID_LEN]; arkime_session_id_string(session-&gt;sessionId, sessionString); ethernetip_log(&quot;ethernetip_process_tcp_payload called, len = %d, session id = %s&quot;, len, sessionString); if (len &lt;= 0) &#123; ethernetip_log(&quot;ethernetip_process_tcp_payload: len &lt;= 0, returning&quot;); return; &#125; // 判断是否是 Ethernet/IP 数据 if (!ethernetip_is_ethernetip(payload, len)) &#123; ethernetip_log(&quot;ethernetip_process_tcp_payload: not Ethernet/IP traffic, returning&quot;); return; &#125; EthernetIPData *eipData = ARKIME_TYPE_ALLOC0(EthernetIPData); if (!eipData) &#123; ethernetip_log(&quot;ERROR - 内存分配失败&quot;); return; &#125; ethernetip_log(&quot;ethernetip_process_tcp_payload: Ethernet/IP data detected, parsing&quot;); // 解析 Ethernet/IP Encapsulation Header if (ethernetip_parse_encap_header(payload, len, eipData) == 0) &#123; ethernetip_log(&quot;ethernetip_process_tcp_payload: ethernetip_parse_encap_header success&quot;); // 解析 CIP 数据 if (eipData-&gt;cip_data != NULL &amp;&amp; eipData-&gt;cip_length &gt; 0) &#123; if (ethernetip_parse_cip_data(eipData-&gt;cip_data, eipData-&gt;cip_length, eipData) == 0) &#123; // 添加 Ethernet/IP 数据到 Arkime 字段 arkime_field_int_add(ethernetip_command_field, session, eipData-&gt;encap_command); arkime_field_int_add(ethernetip_session_field, session, eipData-&gt;encap_session); arkime_field_int_add(ethernetip_status_field, session, eipData-&gt;encap_status); arkime_field_int_add(ethernetip_service_field, session, eipData-&gt;cip_service); arkime_field_int_add(ethernetip_src_port_field, session, session-&gt;port1); arkime_field_int_add(ethernetip_dest_port_field, session, session-&gt;port2); if (eipData-&gt;description != NULL) &#123; arkime_field_string_add(ethernetip_description_field, session, eipData-&gt;description, -1, TRUE); &#125; char data_hex[2 * eipData-&gt;cip_length + 1]; // 2 characters per byte + null terminator for (int i = 0; i &lt; eipData-&gt;cip_length; i++) &#123; sprintf(data_hex + 2 * i, &quot;%02X&quot;, eipData-&gt;cip_data[i]); &#125; data_hex[2 * eipData-&gt;cip_length] = &#x27;\\0&#x27;; // Null terminate the string arkime_field_string_add(ethernetip_data_field, session, data_hex, -1, TRUE); ethernetip_free_data(eipData); &#125; else &#123; ethernetip_log(&quot;ethernetip_process_tcp_payload: ethernetip_parse_cip_data failed&quot;); ethernetip_free_data(eipData); &#125; &#125; else &#123; ethernetip_log(&quot;ethernetip_process_tcp_payload: No CIP data to parse&quot;); ethernetip_free_data(eipData); &#125; &#125; else &#123; ethernetip_log(&quot;ethernetip_process_tcp_payload: ethernetip_parse_encap_header failed&quot;); ethernetip_free_data(eipData); &#125;&#125;/******************************************************************************/// 解析 Ethernet/IP Encapsulation Headerint ethernetip_parse_encap_header(const uint8_t *payload, int len, EthernetIPData *eipData) &#123; if (len &lt; 24) &#123; ethernetip_log(&quot;ethernetip_parse_encap_header: len &lt; 24, returning -1&quot;); return -1; &#125; eipData-&gt;encap_command = ntohl(*(uint32_t*)(payload + 0)); eipData-&gt;encap_length = ntohl(*(uint32_t*)(payload + 4)); eipData-&gt;encap_session = ntohl(*(uint32_t*)(payload + 8)); eipData-&gt;encap_status = ntohl(*(uint32_t*)(payload + 12)); // Sender Context is 8 bytes memcpy(&amp;eipData-&gt;encap_sender_context, payload + 16, 8); eipData-&gt;encap_options = ntohl(*(uint32_t*)(payload + 24)); ethernetip_log(&quot;ethernetip_parse_encap_header: command=0x%X, length=%u, session=0x%X, status=0x%X&quot;, eipData-&gt;encap_command, eipData-&gt;encap_length, eipData-&gt;encap_session, eipData-&gt;encap_status); // 提取 CIP 数据 if (eipData-&gt;encap_length &gt; 0 &amp;&amp; len &gt;= 24 + eipData-&gt;encap_length) &#123; eipData-&gt;cip_length = eipData-&gt;encap_length; eipData-&gt;cip_data = ARKIME_SIZE_ALLOC0(ethernetip_cip_data, eipData-&gt;cip_length); // 使用 Arkime 的内存分配函数 if (!eipData-&gt;cip_data) &#123; ethernetip_log(&quot;ERROR - 内存分配失败&quot;); return -1; &#125; memcpy(eipData-&gt;cip_data, payload + 24, eipData-&gt;cip_length); &#125; else &#123; ethernetip_log(&quot;ethernetip_parse_encap_header: No CIP data or invalid length&quot;); eipData-&gt;cip_data = NULL; eipData-&gt;cip_length = 0; &#125; return 0;&#125;/******************************************************************************/// 解析 CIP 数据 (简化)int ethernetip_parse_cip_data(const uint8_t *cip_data, int cip_len, EthernetIPData *eipData) &#123; if (cip_len &lt; 1) &#123; ethernetip_log(&quot;ethernetip_parse_cip_data: cip_len &lt; 1, returning -1&quot;); return -1; &#125; eipData-&gt;cip_service = cip_data[0]; ethernetip_log(&quot;ethernetip_parse_cip_data: CIP Service Code = 0x%02X&quot;, eipData-&gt;cip_service); eipData-&gt;description = &quot;Unknown CIP Service&quot;; // 默认描述 switch (eipData-&gt;cip_service) &#123; case CIP_SVC_GET_ATTRIB_SINGLE: eipData-&gt;description = &quot;Get Attribute Single&quot;; break; case CIP_SVC_SET_ATTRIB_SINGLE: eipData-&gt;description = &quot;Set Attribute Single&quot;; break; case CIP_SVC_UNCONNECTED_SEND: eipData-&gt;description = &quot;Unconnected Send&quot;; break; case CIP_SVC_FORWARD_OPEN: eipData-&gt;description = &quot;Forward Open&quot;; break; case CIP_SVC_FORWARD_CLOSE: eipData-&gt;description = &quot;Forward Close&quot;; break; default: break; &#125; ethernetip_log(&quot;ethernetip_parse_cip_data: Description = %s&quot;, eipData-&gt;description); return 0;&#125;/******************************************************************************/// 释放 EthernetIPData 结构体内存void ethernetip_free_data(EthernetIPData *data) &#123; if (data) &#123; if (data-&gt;cip_data) &#123; ARKIME_SIZE_FREE(ethernetip_cip_data, data-&gt;cip_data); &#125; ARKIME_TYPE_FREE(EthernetIPData, data); &#125;&#125;/******************************************************************************/// 供 Arkime 加载插件的函数#ifndef UNIT_TESTvoid arkime_plugin_load() &#123; ethernetip_log(&quot;arkime_plugin_load() called&quot;); arkime_plugin_init();&#125;#endif content_copydownload Use code with caution.C 代码解释 1.2. 头文件: 包含了必要的头文件，与 Modbus 插件类似。3. 常量定义: 定义了 Ethernet&#x2F;IP 端口号和一些常用的 CIP Service Codes。4. 数据结构: EthernetIPData 结构体用于存储 Ethernet&#x2F;IP 数据，包括 Encap Header 的字段和 CIP 数据。 这个结构体是简化的，实际应用中需要根据 CIP 协议进行扩展。5. 插件初始化: arkime_plugin_init() 函数注册插件、定义 Arkime 字段，并注册了 TCP 端口 44818 的流量处理回调函数 ethernetip_process_tcp_payload。6. ethernetip_is_ethernetip 函数: 简单的判断，可以根据实际情况增加判断逻辑7. ethernetip_process_tcp_payload 函数: 判断是否为 Ethernet&#x2F;IP 流量。 调用 ethernetip_parse_encap_header() 解析 Ethernet&#x2F;IP Encapsulation Header。 如果存在 CIP 数据，则调用 ethernetip_parse_cip_data() 解析 CIP 数据。 将解析出的数据添加到 Arkime 字段中。 释放内存。 ethernetip_parse_encap_header 函数: 解析 Ethernet&#x2F;IP Encapsulation Header，提取 Command、Length、Session、Status 等字段。 ethernetip_parse_cip_data 函数: 解析 CIP 数据，提取 Service Code，并根据 Service Code 设置描述信息。 这个函数只是一个框架，你需要根据 CIP 协议的规范，实现更详细的解析逻辑。 ethernetip_free_data 函数: 释放 EthernetIPData 结构体占用的内存。 编译和安装 与 Modbus 插件类似，你需要创建一个 Makefile，并使用 gcc 命令编译插件。 然后将编译生成的 ethernetip_plugin.so 文件复制到 Arkime 的插件目录，并在 config.ini 文件中启用插件。 Makefile 示例 123456789101112131415161718192021ARKIME_PREFIX ?= /opt/arkimePLUGIN_NAME = ethernetip_pluginPLUGIN_SO = $(PLUGIN_NAME).soPLUGIN_PATH = $(ARKIME_PREFIX)/pluginsCFLAGS = -g -fPIC -Wall -I$(ARKIME_PREFIX)/includeLDFLAGS = -sharedall: $(PLUGIN_SO)$(PLUGIN_SO): $(PLUGIN_NAME).c\t$(CC) $(CFLAGS) -o $@ $&lt; $(LDFLAGS)install: $(PLUGIN_SO)\tinstall -D $(PLUGIN_SO) $(PLUGIN_PATH)/$(PLUGIN_SO)clean:\trm -f $(PLUGIN_SO).PHONY: all install clean content_copydownload Use code with caution.Makefile 重要提示 - 理解 Ethernet&#x2F;IP 和 CIP 协议: Ethernet&#x2F;IP 和 CIP 协议非常复杂。 你需要仔细阅读相关文档，了解协议的细节。 特别是 CIP 协议的对象模型、服务、类、实例、属性等概念。 CIP 协议解析: ethernetip_parse_cip_data() 函数只是一个框架。 你需要根据 CIP 协议的规范，实现更详细的解析逻辑。 例如，你需要解析 CIP 对象的路径、属性 ID、数据类型等。 错误处理: 示例代码的错误处理比较简单。 在实际项目中，需要添加更完善的错误处理机制。 性能优化: 对于高流量环境，需要对协议解析代码进行性能优化。 扩展方向 1.2. 支持 UDP: Ethernet&#x2F;IP 也可以使用 UDP 协议。 你需要添加对 UDP 协议的支持。3. 解析 CIP 对象路径: CIP 对象路径用于指定要访问的对象。 你需要解析对象路径，并根据对象类型进行相应的处理。4. 解析 CIP 属性: CIP 属性用于读取或写入对象的数据。 你需要解析属性 ID 和数据类型，并将数据存储到 Arkime 字段中。5. 支持 CIP 服务: CIP 协议定义了很多服务，例如 Get Attribute Single、Set Attribute Single、Read Modify Write 等。 你需要支持更多的 CIP 服务。6. 使用开源库: 可以考虑使用开源的 Ethernet&#x2F;IP 或 CIP 协议解析库，例如 cpppo 等。 wireshark捕获S7-1200-Uploading-OB1-TIAV12.pcap后数据Frame 1: 66 bytes on wire (528 bits), 66 bytes captured (528 bits)Ethernet II, Src: ASUSTekCOMPU_84:5e:41 (90:e6:ba:84:5e:41), Dst: SiemensNumer_08:e7:db (00:1c:06:08:e7:db)Internet Protocol Version 4, Src: 192.168.1.10, Dst: 192.168.1.191Transmission Control Protocol, Src Port: 60511, Dst Port: 102, Seq: 0, Len: 0 0000 00 1c 06 08 e7 db 90 e6 ba 84 5e 41 08 00 45 00 ……….^A..E.0010 00 34 1e 18 40 00 80 06 00 00 c0 a8 01 0a c0 a8 .4..@………..0020 01 bf ec 5f 00 66 14 17 dd ec 00 00 00 00 80 02 …_.f……….0030 20 00 84 40 00 00 02 04 05 b4 01 03 03 08 01 01 ..@…………0040 04 02 .. Frame 2: 60 bytes on wire (480 bits), 60 bytes captured (480 bits)Ethernet II, Src: SiemensNumer_08:e7:db (00:1c:06:08:e7:db), Dst: ASUSTekCOMPU_84:5e:41 (90:e6:ba:84:5e:41)Internet Protocol Version 4, Src: 192.168.1.191, Dst: 192.168.1.10Transmission Control Protocol, Src Port: 102, Dst Port: 60511, Seq: 0, Ack: 1, Len: 0 0000 90 e6 ba 84 5e 41 00 1c 06 08 e7 db 08 00 45 00 ….^A……..E.0010 00 2c 01 8f 00 00 1e 06 17 24 c0 a8 01 bf c0 a8 .,…….$……0020 01 0a 00 66 ec 5f 00 02 f9 c8 14 17 dd ed 60 12 …f._……..&#96;.0030 10 00 2b 67 00 00 02 04 05 b4 00 00 ..+g…….. Frame 3: 54 bytes on wire (432 bits), 54 bytes captured (432 bits)Ethernet II, Src: ASUSTekCOMPU_84:5e:41 (90:e6:ba:84:5e:41), Dst: SiemensNumer_08:e7:db (00:1c:06:08:e7:db)Internet Protocol Version 4, Src: 192.168.1.10, Dst: 192.168.1.191Transmission Control Protocol, Src Port: 60511, Dst Port: 102, Seq: 1, Ack: 1, Len: 0 0000 00 1c 06 08 e7 db 90 e6 ba 84 5e 41 08 00 45 00 ……….^A..E.0010 00 28 1e 19 40 00 80 06 00 00 c0 a8 01 0a c0 a8 .(..@………..0020 01 bf ec 5f 00 66 14 17 dd ed 00 02 f9 c9 50 10 …_.f……..P.0030 fa f0 84 34 00 00 …4.. Frame 4: 89 bytes on wire (712 bits), 89 bytes captured (712 bits)Ethernet II, Src: ASUSTekCOMPU_84:5e:41 (90:e6:ba:84:5e:41), Dst: SiemensNumer_08:e7:db (00:1c:06:08:e7:db)Internet Protocol Version 4, Src: 192.168.1.10, Dst: 192.168.1.191Transmission Control Protocol, Src Port: 60511, Dst Port: 102, Seq: 1, Ack: 1, Len: 35TPKT, Version: 3, Length: 35ISO 8073&#x2F;X.224 COTP Connection-Oriented Transport Protocol 0000 00 1c 06 08 e7 db 90 e6 ba 84 5e 41 08 00 45 00 ……….^A..E.0010 00 4b 1e 1a 40 00 80 06 00 00 c0 a8 01 0a c0 a8 .K..@………..0020 01 bf ec 5f 00 66 14 17 dd ed 00 02 f9 c9 50 18 …_.f……..P.0030 fa f0 84 57 00 00 03 00 00 23 1e e0 00 00 00 11 …W…..#……0040 00 c1 02 06 00 c2 0f 53 49 4d 41 54 49 43 2d 52 …….SIMATIC-R0050 4f 4f 54 2d 45 53 c0 01 0a OOT-ES… Frame 5: 89 bytes on wire (712 bits), 89 bytes captured (712 bits)Ethernet II, Src: SiemensNumer_08:e7:db (00:1c:06:08:e7:db), Dst: ASUSTekCOMPU_84:5e:41 (90:e6:ba:84:5e:41)Internet Protocol Version 4, Src: 192.168.1.191, Dst: 192.168.1.10Transmission Control Protocol, Src Port: 102, Dst Port: 60511, Seq: 1, Ack: 36, Len: 35TPKT, Version: 3, Length: 35ISO 8073&#x2F;X.224 COTP Connection-Oriented Transport Protocol 0000 90 e6 ba 84 5e 41 00 1c 06 08 e7 db 08 00 45 00 ….^A……..E.0010 00 4b 01 90 00 00 1e 06 17 04 c0 a8 01 bf c0 a8 .K…………..0020 01 0a 00 66 ec 5f 00 02 f9 c9 14 17 de 10 50 18 …f._……..P.0030 10 00 3c 04 00 00 03 00 00 23 1e d0 00 11 00 07 ..&lt;……#……0040 00 c0 01 0a c1 02 06 00 c2 0f 53 49 4d 41 54 49 ……….SIMATI0050 43 2d 52 4f 4f 54 2d 45 53 C-ROOT-ES Frame 6: 275 bytes on wire (2200 bits), 275 bytes captured (2200 bits)Ethernet II, Src: ASUSTekCOMPU_84:5e:41 (90:e6:ba:84:5e:41), Dst: SiemensNumer_08:e7:db (00:1c:06:08:e7:db)Internet Protocol Version 4, Src: 192.168.1.10, Dst: 192.168.1.191Transmission Control Protocol, Src Port: 60511, Dst Port: 102, Seq: 36, Ack: 36, Len: 221TPKT, Version: 3, Length: 221ISO 8073&#x2F;X.224 COTP Connection-Oriented Transport ProtocolData (214 bytes) 0000 00 1c 06 08 e7 db 90 e6 ba 84 5e 41 08 00 45 00 ……….^A..E.0010 01 05 1e 1b 40 00 80 06 00 00 c0 a8 01 0a c0 a8 ....@………..0020 01 bf ec 5f 00 66 14 17 de 10 00 02 f9 ec 50 18 …_.f……..P.0030 fa cd 85 11 00 00 03 00 00 dd 02 f0 80 72 01 00 ………….r..0040 ce 31 00 00 04 ca 00 00 00 01 00 00 01 20 36 00 .1……….. 6.0050 00 01 1d 00 04 00 00 00 00 00 a1 00 00 00 d3 82 …………….0060 1f 00 00 a3 81 69 00 15 14 53 65 72 76 65 72 53 …..i…ServerS0070 65 73 73 69 6f 6e 5f 32 44 43 36 44 32 a3 82 21 ession_2DC6D2..!0080 00 15 2c 31 3a 3a 3a 36 2e 30 3a 3a 54 43 50 2f ..,1:::6.0::TCP&#x2F;0090 49 50 20 2d 3e 20 41 74 68 65 72 6f 73 20 41 52 IP -&gt; Atheros AR00a0 38 31 32 31 2f 41 52 38 31 31 33 2f 2e 2e 2e a3 8121&#x2F;AR8113&#x2F;….00b0 82 28 00 15 00 a3 82 29 00 15 00 a3 82 2a 00 15 .(…..)…..*..00c0 0f 56 4f 52 54 45 58 5f 32 31 30 33 32 34 39 31 .VORTEX_2103249100d0 a3 82 2b 00 04 01 a3 82 2c 00 12 00 2d c6 d2 a3 ..+…..,…-…00e0 82 2d 00 15 00 a1 00 00 00 d3 81 7f 00 00 a3 81 .-…………..00f0 69 00 15 15 53 75 62 73 63 72 69 70 74 69 6f 6e i…Subscription0100 43 6f 6e 74 61 69 6e 65 72 a2 a2 00 00 00 00 72 Container……r0110 01 00 00 … root@ubuntu:&#x2F;opt&#x2F;arkime&#x2F;bin# .&#x2F;capture -r pcap &#x2F;home&#x2F;kuze&#x2F;Desktop&#x2F;s7包&#x2F;S7-1200-Uploading-OB1-TIAV12.pcapMar 10 15:14:02 main.c:259 parse_args(): WARNING: gethostname doesn’t return a fully qualified name and getdomainname failed, this may cause issues when viewing pcaps, use the –host option - ubuntuMar 10 15:14:02 http.c:318 arkime_http_send_sync(): 1&#x2F;1 SYNC 200 http://localhost:9200/_template/arkime_sessions3_template?filter_path=**._meta 0&#x2F;96 0ms 2msMar 10 15:14:02 http.c:318 arkime_http_send_sync(): 1&#x2F;1 SYNC 200 http://localhost:9200/arkime_sequence/_doc/fn-ubuntu 0&#x2F;123 0ms 1msMar 10 15:14:02 http.c:318 arkime_http_send_sync(): 1&#x2F;1 SYNC 200 http://localhost:9200/arkime_stats/_doc/ubuntu 0&#x2F;948 0ms 1msMar 10 15:14:02 http.c:318 arkime_http_send_sync(): 1&#x2F;1 SYNC 200 http://localhost:9200/arkime_fields/_search?size=3000 0&#x2F;109410 0ms 9msMar 10 15:14:02 db.c:2805 arkime_db_init(): WARNING - No Geo Country file could be loaded, see https://arkime.com/settings#geolite2countryMar 10 15:14:02 db.c:2816 arkime_db_init(): WARNING - No Geo ASN file could be loaded, see https://arkime.com/settings#geolite2asn2025-03-10 15:14:02 [s7_plugin] arkime_plugin_init() called2025-03-10 15:14:02 [s7_protocol] s7_protocol_init called.2025-03-10 15:14:02 [s7_plugin] S7 Plugin initialized successfully!Mar 10 15:14:02 http.c:406 arkime_http_curlm_check_multi_info(): 1&#x2F;1 ASYNC 200 http://localhost:9200/_cat/health?format=json 0&#x2F;197 0ms 2msMar 10 15:14:02 reader-libpcap-file.c:187 reader_libpcapfile_process(): ERROR - pcap open failed - Couldn’t realpath file: ‘pcap’ with No such file or directory (2)Mar 10 15:14:02 packet.c:689 arkime_packet_log(): packets: 0 current sessions: 0&#x2F;0 oldest: 0 - recv: 0 drop: 0 (0.00) queue: 0 disk: 0 packet: 0 close: 0 ns: 0 frags: 0&#x2F;0 pstats: 0&#x2F;0&#x2F;0&#x2F;0&#x2F;0&#x2F;0&#x2F;0 ver: 5.6.1Mar 10 15:14:02 http.c:318 arkime_http_send_sync(): 1&#x2F;1 SYNC 200 http://localhost:9200/_bulk 1796&#x2F;1834 0ms 4msMar 10 15:14:02 http.c:318 arkime_http_send_sync(): 1&#x2F;1 SYNC 200 http://localhost:9200/arkime_stats/_doc/ubuntu 801&#x2F;173 0ms 2msMar 10 15:14:02 http.c:318 arkime_http_send_sync(): 1&#x2F;1 SYNC 200 http://localhost:9200/arkime_*/_refresh 0&#x2F;51 0ms 24ms s7插件显示No data for this fields7-protocol.c :&#x2F;&#x2F; s7-protocol.c#include “s7-protocol.h”#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa&#x2F;inet.h&gt;#include &lt;math.h&gt;#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;#include &lt;time.h&gt; &#x2F;&#x2F; 用于 s7-protocol.c 的日志记录函数static void s7p_log(const char *format, …) {va_list args;va_start(args, format); 1234567891011121314151617181920 time_t timer;char time_buffer[26];struct tm tm_info;time(&amp;timer);if (localtime_r(&amp;timer, &amp;tm_info) == NULL) &#123; perror(&quot;localtime_r&quot;); return;&#125; if (strftime(time_buffer, sizeof(time_buffer), &quot;%Y-%m-%d %H:%M:%S&quot;, &amp;tm_info) == 0) &#123; fprintf(stderr, &quot;strftime failed &quot;); return;&#125;fprintf(stderr, &quot;%s [s7_protocol] &quot;, time_buffer);vfprintf(stderr, format, args);fprintf(stderr, &quot; &quot;);va_end(args);fflush(stderr); } &#x2F;&#x2F; TPKT 头typedef struct {uint8_t version;uint8_t reserved;uint16_t length;} TPKTHeader; &#x2F;&#x2F; COTP 头typedef struct {uint8_t length;uint8_t pduType;union {struct { &#x2F;&#x2F; DT (Data) PDUuint8_t tpduNumber : 7;uint8_t eot : 1;} dt;struct { &#x2F;&#x2F; CR (Connection Request)uint8_t dstRef[2];uint8_t srcRef[2];uint8_t classOption;} cr;} u;} COTPHeader; &#x2F;&#x2F; S7 PDU 头typedef struct {uint8_t protocolId;uint8_t messageType;uint16_t reserved;uint16_t pduReference;uint16_t paramLength;uint16_t dataLength;uint8_t errorClass; &#x2F;&#x2F; Ack-Data 中uint8_t errorCode; &#x2F;&#x2F; Ack-Data 中} S7Header; &#x2F;&#x2F; S7 读&#x2F;写变量参数 (请求)typedef struct {uint8_t functionCode;uint8_t itemCount;} S7ReadWriteVarParam; &#x2F;&#x2F; S7 读&#x2F;写变量项 (请求)typedef struct {uint8_t syntaxId;uint8_t transportSize;uint16_t length;uint8_t area;uint16_t dbNumber;uint32_t startOffset; &#x2F;&#x2F; 字节地址 * 8 + 位偏移} S7ReadWriteVarItemReq; &#x2F;&#x2F; S7 读&#x2F;写变量返回代码 (响应)typedef struct {uint8_t functionCode;uint8_t itemCount;} S7ReadWriteVarResponse; &#x2F;&#x2F; S7 读&#x2F;写变量项 (响应)typedef struct {uint8_t returnCode;uint8_t transportSize;uint16_t length; &#x2F;&#x2F; BOOL 用位, 其他用字节} S7ReadWriteVarItemRes; &#x2F;&#x2F; S7 PLC 控制 (启动&#x2F;停止请求)typedef struct {uint8_t functionCode;uint8_t method; &#x2F;&#x2F; 0x09 表示停止, 0x04&#x2F;0x05 表示启动uint8_t unknown[6]; &#x2F;&#x2F; 固定长度uint16_t paramLength;} S7PLCControlParam; &#x2F;&#x2F; S7 PLC 控制 (响应)typedef struct {uint8_t functionCode;} S7PLCControlResponse; &#x2F;&#x2F; S7 请求下载 (请求)typedef struct {uint8_t functionCode;uint8_t subFunction; &#x2F;&#x2F; 0x01 &#x3D; 请求下载, 0x03 &#x3D; 结束下载uint8_t blockType; &#x2F;&#x2F; ‘B’, ‘F’, ‘O’ 等uint8_t padding[5];uint32_t blockNumber;} S7ReqDownloadParam; &#x2F;&#x2F; S7 下载块&#x2F;上传 (请求)typedef struct {uint8_t functionCode;uint8_t subFunction; &#x2F;&#x2F; 下载: 0x02, 上传: 0x01, 结束上传: 0x02} S7DownloadBlockParam; &#x2F;&#x2F; S7 下载&#x2F;上传 (响应)typedef struct {uint8_t functionCode;uint8_t subFunction; &#x2F;&#x2F; 下载: 0x02, 上传: 0x01, 结束上传&#x3D;0x02uint8_t padding[3]; &#x2F;&#x2F; 通常为 0} S7DownloadUploadResponse; &#x2F;&#x2F; S7 数据类型解码辅助函数 (将 S7 字节数据转换为字符串)char* s7_decode_data(const S7Item *item, char * resultBuf, size_t bufSize){if (!item || !item-&gt;data || item-&gt;dataLengthBytes &#x3D;&#x3D; 0 || !resultBuf || bufSize &#x3D;&#x3D; 0) {s7p_log(“s7_decode_data: Invalid input parameters.”);return NULL; &#x2F;&#x2F; 无效输入} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172 switch (item-&gt;transportSize)&#123; case 0x01: // BOOL (位) snprintf(resultBuf, bufSize, &quot;%s&quot;, (item-&gt;data[0] &amp; (1 &lt;&lt; (item-&gt;startOffset % 8))) ? &quot;true&quot; : &quot;false&quot;); break; case 0x02: // BYTE, WORD, DWORD, INT, DINT if (item-&gt;length == 8) &#123; // BYTE, S7_Char snprintf(resultBuf, bufSize, &quot;0x%02X&quot;, item-&gt;data[0]); &#125; else if (item-&gt;length == 16) &#123; // WORD, INT uint16_t value = ntohs(*(uint16_t *)item-&gt;data); if (item-&gt;area == 0x1E || item-&gt;area == 0x1F) // Counter/Timer &#123; snprintf(resultBuf, bufSize, &quot;%u&quot;, value); &#125; else &#123; snprintf(resultBuf, bufSize, &quot;%d&quot;, (int16_t)value); &#125; &#125; else if (item-&gt;length == 32) &#123; //DWORD, DINT uint32_t value = ntohl(*(uint32_t*)item-&gt;data); if (item-&gt;area == 0x1E || item-&gt;area == 0x1F) &#123; snprintf(resultBuf, bufSize, &quot;%u&quot;, value); &#125; else &#123; snprintf(resultBuf, bufSize, &quot;%d&quot;, (int32_t)value); //DINT &#125; &#125; else&#123; snprintf(resultBuf, bufSize, &quot;UnsupportedLength&quot;); s7p_log(&quot;s7_decode_data: Unsupported length for transport size 0x02: %d&quot;, item-&gt;length); &#125; break; case 0x04: // REAL (浮点数) if (item-&gt;dataLengthBytes == 4) &#123; uint32_t temp = ntohl(*(uint32_t *)item-&gt;data); float f; memcpy(&amp;f, &amp;temp, 4); snprintf(resultBuf, bufSize, &quot;%f&quot;, f); &#125; else &#123; snprintf(resultBuf, bufSize, &quot;InvalidReal&quot;); s7p_log(&quot;s7_decode_data: Invalid data length for REAL: %d&quot;, item-&gt;dataLengthBytes); &#125; break; case 0x09: //Counter, Timer if (item-&gt;length == 16) &#123; //BCD 格式 uint16_t value = ntohs(*(uint16_t *)item-&gt;data); uint16_t bcdValue = ((value &gt;&gt; 12) &amp; 0x000F) * 100 + ((value &gt;&gt; 8) &amp; 0x000F) * 10 + ((value &gt;&gt; 4) &amp; 0x000F); snprintf(resultBuf, bufSize, &quot;%u&quot;, bcdValue); &#125; else&#123; snprintf(resultBuf, bufSize, &quot;UnsupportedLength&quot;); s7p_log(&quot;s7_decode_data: Unsupported length for Counter/Timer: %d&quot;, item-&gt;length); &#125; break; default: snprintf(resultBuf, bufSize, &quot;UnknownType&quot;); s7p_log(&quot;s7_decode_data: Unknown transport size: 0x%02x&quot;, item-&gt;transportSize); break;&#125;return resultBuf; IGNORE_WHEN_COPYING_START content_copy download Use code with caution. IGNORE_WHEN_COPYING_END } &#x2F;&#x2F; 释放 S7Packet 中动态分配的资源void s7_free_packet(S7Packet *packet) {if (packet) {if (packet-&gt;items) {for (int i &#x3D; 0; i &lt; packet-&gt;itemCount; i++) {if (packet-&gt;items[i].data) {free(packet-&gt;items[i].data);packet-&gt;items[i].data &#x3D; NULL;}}free(packet-&gt;items);packet-&gt;items &#x3D; NULL;}if (packet-&gt;blockData){free(packet-&gt;blockData);packet-&gt;blockData &#x3D; NULL;}&#x2F;&#x2F;其他需要释放的内存packet-&gt;messageType &#x3D; 0;packet-&gt;functionCode &#x3D; 0;packet-&gt;itemCount &#x3D; 0;packet-&gt;errorClass &#x3D; 0;packet-&gt;errorCode &#x3D; 0;packet-&gt;pduReference &#x3D; 0;packet-&gt;blockType &#x3D; 0;packet-&gt;blockNumber &#x3D; 0;packet-&gt;blockDataLen &#x3D; 0;packet-&gt;method &#x3D; 0;}} &#x2F;&#x2F; 解析 Read Var 请求 移除staticint parse_s7_read_var_request(const unsigned char *param, int paramLen, S7Packet *packet) {s7p_log(“parse_s7_read_var_request called.”);if (!param || !packet) {s7p_log(“parse_s7_read_var_request: NULL parameter(s) received.”);return -1;}S7ReadWriteVarParam *readVarParam &#x3D; (S7ReadWriteVarParam *)param;packet-&gt;functionCode &#x3D; (S7FunctionCode)readVarParam-&gt;functionCode;packet-&gt;itemCount &#x3D; readVarParam-&gt;itemCount;s7p_log(“parse_s7_read_var_request: functionCode&#x3D;0x%02x, itemCount&#x3D;%d”, packet-&gt;functionCode, packet-&gt;itemCount); 1234567891011121314151617181920212223242526272829303132 packet-&gt;items = (S7Item *)malloc(sizeof(S7Item) * packet-&gt;itemCount);if (!packet-&gt;items)&#123; s7p_log(&quot;parse_s7_read_var_request: Memory allocation failed for items.&quot;); return -1;&#125;memset(packet-&gt;items, 0, sizeof(S7Item) * packet-&gt;itemCount);const unsigned char *itemData = param + sizeof(S7ReadWriteVarParam);for (int i = 0; i &lt; packet-&gt;itemCount; i++) &#123; // 长度检查 if ((size_t)paramLen &lt; sizeof(S7ReadWriteVarParam) + (i+1)*12) &#123; s7p_log(&quot;parse_s7_read_var_request: Parameter length check failed.&quot;); s7_free_packet(packet); return -1; &#125; packet-&gt;items[i].syntaxId = *itemData++; packet-&gt;items[i].transportSize = *itemData++; packet-&gt;items[i].length = ntohs(*(uint16_t *)itemData); itemData += 2; packet-&gt;items[i].area = *itemData++; packet-&gt;items[i].dbNumber = ntohs(*(uint16_t *)itemData); itemData += 2; packet-&gt;items[i].startOffset = ((uint32_t)*itemData &lt;&lt; 16) | ((uint32_t)*(itemData + 1) &lt;&lt; 8) | *(itemData + 2); itemData += 3; s7p_log(&quot;parse_s7_read_var_request: Item %d - syntaxId: 0x%02x, transportSize: 0x%02x, length: %d, area: 0x%02x, dbNumber: %d, startOffset: %u&quot;, i, packet-&gt;items[i].syntaxId, packet-&gt;items[i].transportSize, packet-&gt;items[i].length, packet-&gt;items[i].area, packet-&gt;items[i].dbNumber, packet-&gt;items[i].startOffset);&#125; s7p_log(&quot;parse_s7_read_var_request: Successfully parsed Read Var Request.&quot;);return 0; IGNORE_WHEN_COPYING_START content_copy download Use code with caution. IGNORE_WHEN_COPYING_END } &#x2F;&#x2F; 解析 Read Var 响应 移除staticint parse_s7_read_var_response(const unsigned char *param, int paramLen, const unsigned char *data, int dataLen, S7Packet *packet){s7p_log(“parse_s7_read_var_response called.”);if (!param || !data || !packet) {s7p_log(“parse_s7_read_var_response: NULL parameter(s) received.”);return -1;}(void)paramLen;S7ReadWriteVarResponse *readVarParam &#x3D; (S7ReadWriteVarResponse *)param;packet-&gt;functionCode &#x3D; (S7FunctionCode)readVarParam-&gt;functionCode;packet-&gt;itemCount &#x3D; readVarParam-&gt;itemCount;packet-&gt;errorClass &#x3D; (S7ErrorCode)param[2];packet-&gt;errorCode &#x3D; (S7ErrorCode)param[3];s7p_log(“parse_s7_read_var_response: functionCode&#x3D;0x%02x, itemCount&#x3D;%d, errorClass&#x3D;0x%02x, errorCode&#x3D;0x%02x”,packet-&gt;functionCode, packet-&gt;itemCount, packet-&gt;errorClass, packet-&gt;errorCode);packet-&gt;items &#x3D; (S7Item *)malloc(sizeof(S7Item) * packet-&gt;itemCount);if (!packet-&gt;items){s7p_log(“parse_s7_read_var_response: Memory allocation failed for items.”);return -1;}memset(packet-&gt;items, 0, sizeof(S7Item) * packet-&gt;itemCount); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 // 如果有错误，无需解析 item dataif (packet-&gt;errorClass != S7_ERR_NO_ERROR || packet-&gt;errorCode != S7_ERR_NO_ERROR) &#123; s7p_log(&quot;parse_s7_read_var_response: Error detected. Skipping item data parsing.&quot;); return 0;&#125;const unsigned char *itemData = data;for (int i = 0; i &lt; packet-&gt;itemCount; i++)&#123; packet-&gt;items[i].returnCode = *itemData++; s7p_log(&quot;parse_s7_read_var_response: Item %d - returnCode: 0x%02x&quot;, i, packet-&gt;items[i].returnCode); if (packet-&gt;items[i].returnCode != 0xff) // 0xff == 无错误 &#123; itemData += 2; // 跳过 length 字段 s7p_log(&quot;parse_s7_read_var_response: Item %d - Non-0xff return code. Skipping data.&quot;, i); continue; &#125; packet-&gt;items[i].transportSize = *itemData++; packet-&gt;items[i].length = ntohs(*(uint16_t *)itemData); itemData += 2; packet-&gt;items[i].syntaxId = 0x12; // S7ANY s7p_log(&quot;parse_s7_read_var_response: Item %d - transportSize: 0x%02x, length: %d&quot;, i, packet-&gt;items[i].transportSize, packet-&gt;items[i].length); // 计算 data 长度 (bytes) uint16_t dataLengthBytes; if (packet-&gt;items[i].transportSize == 0x01) &#123; // BOOL dataLengthBytes = (packet-&gt;items[i].length + 7) / 8; &#125; else &#123; dataLengthBytes = packet-&gt;items[i].length; &#125; packet-&gt;items[i].dataLengthBytes = dataLengthBytes; // 分配内存并复制 item data if (dataLengthBytes &gt; 0) &#123; packet-&gt;items[i].data = (uint8_t*)malloc(dataLengthBytes); if (!packet-&gt;items[i].data) &#123; s7p_log(&quot;parse_s7_read_var_response: Memory allocation failed for item data.&quot;); s7_free_packet(packet); return -1; &#125; // data section 长度检查 if ((itemData + dataLengthBytes) &gt; (data + dataLen)) &#123; s7p_log(&quot;parse_s7_read_var_response: Data length check failed. Not enough data in packet.&quot;); s7_free_packet(packet); return -1; &#125; memcpy(packet-&gt;items[i].data, itemData, dataLengthBytes); s7p_log(&quot;parse_s7_read_var_response: Item %d - Copied %d bytes of data.&quot;, i, dataLengthBytes); itemData += dataLengthBytes; &#125;&#125; s7p_log(&quot;parse_s7_read_var_response: Successfully parsed Read Var Response.&quot;);return 0; IGNORE_WHEN_COPYING_START content_copy download Use code with caution. IGNORE_WHEN_COPYING_END } &#x2F;&#x2F; 解析 Write Var 请求 移除staticint parse_s7_write_var_request(const unsigned char *param, int paramLen, S7Packet *packet) {s7p_log(“parse_s7_write_var_request called.”);if (!param || !packet) {s7p_log(“parse_s7_write_var_request: NULL parameter(s) received.”);return -1;}S7ReadWriteVarParam *writeVarParam &#x3D; (S7ReadWriteVarParam *)param;packet-&gt;functionCode &#x3D; (S7FunctionCode)writeVarParam-&gt;functionCode;packet-&gt;itemCount &#x3D; writeVarParam-&gt;itemCount;s7p_log(“parse_s7_write_var_request: functionCode&#x3D;0x%02x, itemCount&#x3D;%d”, packet-&gt;functionCode, packet-&gt;itemCount); 1234567891011121314151617181920212223242526272829303132333435 packet-&gt;items = (S7Item *)malloc(sizeof(S7Item) * packet-&gt;itemCount);if (!packet-&gt;items)&#123; s7p_log(&quot;parse_s7_write_var_request: Memory allocation failed for items.&quot;); return -1;&#125;memset(packet-&gt;items, 0, sizeof(S7Item) * packet-&gt;itemCount);const unsigned char *itemData = param + sizeof(S7ReadWriteVarParam);for (int i = 0; i &lt; packet-&gt;itemCount; i++) &#123; // 长度检查 if ((size_t)paramLen &lt; sizeof(S7ReadWriteVarParam) + (i+1)*12) &#123; s7p_log(&quot;parse_s7_write_var_request: Parameter length check failed.&quot;); s7_free_packet(packet); return -1; &#125; packet-&gt;items[i].syntaxId = *itemData++; packet-&gt;items[i].transportSize = *itemData++; packet-&gt;items[i].length = ntohs(*(uint16_t *)itemData); itemData += 2; packet-&gt;items[i].area = *itemData++; packet-&gt;items[i].dbNumber = ntohs(*(uint16_t *)itemData); itemData += 2; packet-&gt;items[i].startOffset = ((uint32_t)*itemData &lt;&lt; 16) | ((uint32_t)*(itemData + 1) &lt;&lt; 8) | *(itemData + 2); itemData += 3; s7p_log(&quot;parse_s7_write_var_request: Item %d - syntaxId: 0x%02x, transportSize: 0x%02x, length: %d, area: 0x%02x, dbNumber: %d, startOffset: %u&quot;, i, packet-&gt;items[i].syntaxId, packet-&gt;items[i].transportSize, packet-&gt;items[i].length, packet-&gt;items[i].area, packet-&gt;items[i].dbNumber, packet-&gt;items[i].startOffset);&#125;s7p_log(&quot;parse_s7_write_var_request: Successfully parsed Write Var Request.&quot;);return 0; IGNORE_WHEN_COPYING_START content_copy download Use code with caution. IGNORE_WHEN_COPYING_END } &#x2F;&#x2F; 解析 Write Var 响应 移除staticint parse_s7_write_var_response(const unsigned char* param, int paramLen, const unsigned char* data, int dataLen, S7Packet* packet){s7p_log(“parse_s7_write_var_response called.”);if (!param || !packet) {s7p_log(“parse_s7_write_var_response: NULL parameter(s) received.”);return -1;}(void)data;(void)dataLen;(void)paramLen; 12345678910111213141516171819202122232425262728293031 S7ReadWriteVarResponse* writeResp = (S7ReadWriteVarResponse*)param;packet-&gt;functionCode = (S7FunctionCode)writeResp-&gt;functionCode;packet-&gt;itemCount = writeResp-&gt;itemCount; s7p_log(&quot;parse_s7_write_var_response: functionCode=0x%02x, itemCount=%d&quot;, packet-&gt;functionCode, packet-&gt;itemCount);packet-&gt;errorClass = (S7ErrorCode)param[2];packet-&gt;errorCode = (S7ErrorCode)param[3];s7p_log(&quot;parse_s7_write_var_response: errorClass=0x%02x, errorCode=0x%02x&quot;, packet-&gt;errorClass, packet-&gt;errorCode);packet-&gt;items = (S7Item*)malloc(sizeof(S7Item) * packet-&gt;itemCount);if (!packet-&gt;items) &#123; s7p_log(&quot;parse_s7_write_var_response: Memory allocation failed for items.&quot;); return -1;&#125;memset(packet-&gt;items, 0, sizeof(S7Item) * packet-&gt;itemCount);const unsigned char* itemData = param + sizeof(S7ReadWriteVarResponse);for (int i = 0; i &lt; packet-&gt;itemCount; i++) &#123; // 长度检查 (return code 是 1 byte) if ((size_t)paramLen &lt; sizeof(S7ReadWriteVarResponse) + (i + 1) * sizeof(uint8_t)) &#123; s7p_log(&quot;parse_s7_write_var_response: Parameter length check failed.&quot;); s7_free_packet(packet); return -1; &#125; packet-&gt;items[i].returnCode = *itemData++; s7p_log(&quot;parse_s7_write_var_response: Item %d - returnCode: 0x%02x&quot;, i, packet-&gt;items[i].returnCode);&#125;s7p_log(&quot;parse_s7_write_var_response: Successfully parsed Write Var Response.&quot;);return 0; IGNORE_WHEN_COPYING_START content_copy download Use code with caution. IGNORE_WHEN_COPYING_END } &#x2F;&#x2F; 解析 PLC Control (Start&#x2F;Stop) 请求 移除staticint parse_s7_plc_control_request(const unsigned char *param, int paramLen, S7Packet *packet){s7p_log(“parse_s7_plc_control_request called.”);if (!param || !packet) {s7p_log(“parse_s7_plc_control_request: NULL parameter(s) received.”);return -1;}S7PLCControlParam *plcControlParam &#x3D; (S7PLCControlParam *)param;&#x2F;&#x2F; 长度检查if ((size_t)paramLen &lt; sizeof(S7PLCControlParam)) {s7p_log(“parse_s7_plc_control_request: Parameter length check failed.”);return -1;}packet-&gt;functionCode &#x3D; (S7FunctionCode)plcControlParam-&gt;functionCode;packet-&gt;method &#x3D; plcControlParam-&gt;method;s7p_log(“parse_s7_plc_control_request: functionCode&#x3D;0x%02x, method&#x3D;0x%02x”, packet-&gt;functionCode, packet-&gt;method);s7p_log(“parse_s7_plc_control_request: Successfully parsed PLC Control Request.”);return 0;} &#x2F;&#x2F; 解析 PLC Control 响应 移除staticint parse_s7_plc_control_response(const unsigned char* param, int paramLen, S7Packet* packet) {s7p_log(“parse_s7_plc_control_response called.”);if (!param || !packet) {s7p_log(“parse_s7_plc_control_response: NULL parameter(s) received.”);return -1;}(void)paramLen;S7PLCControlResponse* plcControlResp &#x3D; (S7PLCControlResponse*)param;packet-&gt;functionCode &#x3D; (S7FunctionCode)plcControlResp-&gt;functionCode;s7p_log(“parse_s7_plc_control_response: functionCode&#x3D;0x%02x”, packet-&gt;functionCode);s7p_log(“parse_s7_plc_control_response: Successfully parsed PLC Control Response”);return 0;} &#x2F;&#x2F; 解析 S7 Request Download 请求 移除staticint parse_s7_req_download_request(const unsigned char param, int paramLen, S7Packet *packet){s7p_log(“parse_s7_req_download_request called.”);if (!param || !packet) {s7p_log(“parse_s7_req_download_request: NULL parameter(s) received.”);return -1;}S7ReqDownloadParam* reqDownloadParam &#x3D; (S7ReqDownloadParam)param;&#x2F;&#x2F; 长度检查if ((size_t)paramLen &lt; sizeof(S7ReqDownloadParam)) {s7p_log(“parse_s7_req_download_request: Parameter length check failed.”);return -1;}packet-&gt;functionCode &#x3D; (S7FunctionCode)reqDownloadParam-&gt;functionCode; &#x2F;&#x2F; 使用枚举packet-&gt;blockType &#x3D; reqDownloadParam-&gt;blockType;packet-&gt;blockNumber &#x3D; ntohl(reqDownloadParam-&gt;blockNumber);s7p_log(“parse_s7_req_download_request: functionCode&#x3D;0x%02x, blockType&#x3D;%c, blockNumber&#x3D;%u”,packet-&gt;functionCode, packet-&gt;blockType, packet-&gt;blockNumber);s7p_log(“parse_s7_req_download_request: Successfully parsed Request Download Request.”);return 0;} &#x2F;&#x2F; 解析 S7 Download Block 请求 移除staticint parse_s7_download_block_request(const unsigned char param, int paramLen, S7Packet packet){s7p_log(“parse_s7_download_block_request called.”);if (!param || !packet) {s7p_log(“parse_s7_download_block_request: NULL parameter(s) received.”);return -1;}(void)paramLen; &#x2F;&#x2F;避免未使用参数警告S7DownloadBlockParam* downloadBlockParam &#x3D; (S7DownloadBlockParam*)param;packet-&gt;functionCode &#x3D; (S7FunctionCode)downloadBlockParam-&gt;functionCode; &#x2F;&#x2F; 使用枚举s7p_log(“parse_s7_download_block_request: functionCode&#x3D;0x%02x”, packet-&gt;functionCode);s7p_log(“parse_s7_download_block_request: Successfully parsed Download Block Request.”);return 0;} &#x2F;&#x2F; 解析 S7 Upload 请求 移除staticint parse_s7_upload_request(const unsigned char* param, int paramLen, S7Packet* packet){s7p_log(“parse_s7_upload_request called.”);if (!param || !packet) {s7p_log(“parse_s7_upload_request: NULL parameter(s) received.”);return -1;}(void)paramLen; &#x2F;&#x2F;避免未使用参数警告S7DownloadBlockParam* uploadBlockParam &#x3D; (S7DownloadBlockParam*)param; &#x2F;&#x2F; Re-use structurepacket-&gt;functionCode &#x3D; (S7FunctionCode)uploadBlockParam-&gt;functionCode; &#x2F;&#x2F; 使用枚举s7p_log(“parse_s7_upload_request: functionCode&#x3D;0x%02x”, packet-&gt;functionCode);s7p_log(“parse_s7_upload_request: Successfully parsed Upload Request.”);return 0;} &#x2F;&#x2F; 解析 S7 Download&#x2F;Upload 响应 移除staticint parse_s7_download_upload_response(const unsigned char param, int paramLen, S7Packet *packet){s7p_log(“parse_s7_download_upload_response called.”);if (!param || !packet) {s7p_log(“parse_s7_download_upload_response: NULL parameter(s) received.”);return -1;}(void)paramLen; &#x2F;&#x2F; 避免未使用参数警告S7DownloadUploadResponse* downloadUploadResp &#x3D; (S7DownloadUploadResponse)param;packet-&gt;functionCode &#x3D; (S7FunctionCode)downloadUploadResp-&gt;functionCode; &#x2F;&#x2F; 使用枚举s7p_log(“parse_s7_download_upload_response: functionCode&#x3D;0x%02x”, packet-&gt;functionCode);s7p_log(“parse_s7_download_upload_response: Successfully parsed Download&#x2F;Upload Response.”);return 0;} &#x2F;&#x2F; 辅助函数：查找解析函数 (请求)S7ParamParserReq find_parser_req(uint8_t functionCode) {for (int i &#x3D; 0; s7_param_parsers_req[i].parser !&#x3D; NULL; i++) {if (s7_param_parsers_req[i].functionCode &#x3D;&#x3D; functionCode) {return s7_param_parsers_req[i].parser;}}s7p_log(“find_parser_req: No parser found for function code 0x%02x”, functionCode);return NULL;} &#x2F;&#x2F; 辅助函数：查找解析函数 (响应)void *find_parser_res(uint8_t functionCode, int *type) {for (int i &#x3D; 0; s7_param_parsers_res[i].parser !&#x3D; NULL; i++) {if (s7_param_parsers_res[i].functionCode &#x3D;&#x3D; functionCode) {*type &#x3D; s7_param_parsers_res[i].type;return s7_param_parsers_res[i].parser;}}*type &#x3D; -1;s7p_log(“find_parser_res: No parser found for function code 0x%02x”, functionCode);return NULL;} &#x2F;&#x2F;S7 协议解析的入口函数int s7_protocol_parse(const unsigned char *data, int len, S7Packet *packet) {s7p_log(“s7_protocol_parse called. Data length: %d”, len);if (!data || !packet) {s7p_log(“s7_protocol_parse: NULL parameter(s) received.”);return -1;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137 // 1. 解析 TPKT 头if ((size_t)len &lt; sizeof(TPKTHeader)) &#123; s7p_log(&quot;s7_protocol_parse: Packet too short for TPKT header.&quot;); return -1;&#125;TPKTHeader *tpkt = (TPKTHeader *)data;if (tpkt-&gt;version != 3) &#123; s7p_log(&quot;s7_protocol_parse: Invalid TPKT version: %d&quot;, tpkt-&gt;version); return -1;&#125;s7p_log(&quot;s7_protocol_parse: TPKT Version: %d&quot;, tpkt-&gt;version);int tpktLength = ntohs(tpkt-&gt;length);s7p_log(&quot;s7_protocol_parse: TPKT Length (packet length): %d&quot;, tpktLength);if (len &lt; tpktLength) &#123; s7p_log(&quot;s7_protocol_parse: Packet length (%d) less than TPKT length (%d).&quot;, len, tpktLength); return -1;&#125;// 2. 解析 COTP 头const unsigned char *cotpData = data + sizeof(TPKTHeader);COTPHeader *cotp = (COTPHeader *)cotpData;int cotpLength = cotp-&gt;length + 1; // COTP 长度字段不包括自身s7p_log(&quot;s7_protocol_parse: COTP Length: %d, COTP PDU Type: 0x%02x&quot;, cotpLength, cotp-&gt;pduType);if (cotp-&gt;pduType != 0xF0 &amp;&amp; cotp-&gt;pduType != 0xE0) &#123; // 0xF0: DT, 0xE0: CR s7p_log(&quot;s7_protocol_parse: Unsupported COTP PDU type: 0x%02x&quot;, cotp-&gt;pduType); return -1; // 不是支持的 COTP PDU 类型&#125;if (cotp-&gt;pduType == 0xE0) &#123; s7p_log(&quot;s7_protocol_parse: COTP CR (Connection Request) detected. Returning.&quot;); packet-&gt;functionCode = S7_FUNCTION_SETUP_COMM; // COTP CR (Setup Communication) return 0; // COTP CR 是连接请求，所以我们在这里停止解析。&#125;// 3. 解析 S7 头const unsigned char *s7Data = cotpData + cotpLength;int s7DataLength = tpktLength - sizeof(TPKTHeader) - cotpLength;s7p_log(&quot;s7_protocol_parse: S7 Data Length: %d&quot;, s7DataLength);if ((size_t)s7DataLength &lt; sizeof(S7Header))&#123; s7p_log(&quot;s7_protocol_parse: Remaining data too short for S7 header.&quot;); return -1;&#125;S7Header *s7Header = (S7Header *)s7Data;if (s7Header-&gt;protocolId != 0x32)&#123; s7p_log(&quot;s7_protocol_parse: Invalid S7 protocol ID: 0x%02x&quot;, s7Header-&gt;protocolId); return -1;&#125;packet-&gt;messageType = (S7MessageType)s7Header-&gt;messageType; // 使用枚举packet-&gt;pduReference = ntohs(s7Header-&gt;pduReference);packet-&gt;errorClass = (S7ErrorCode)s7Header-&gt;errorClass; // 使用枚举packet-&gt;errorCode = (S7ErrorCode)s7Header-&gt;errorCode; // 使用枚举s7p_log(&quot;s7_protocol_parse: S7 Protocol ID: 0x%02x, Message Type: 0x%02x, PDU Ref: %d, Error Class: 0x%02x, Error Code: 0x%02x&quot;, s7Header-&gt;protocolId, packet-&gt;messageType, packet-&gt;pduReference, packet-&gt;errorClass, packet-&gt;errorCode);const unsigned char *s7Param = s7Data + sizeof(S7Header);int s7ParamLength = ntohs(s7Header-&gt;paramLength);const unsigned char *s7DataItem = s7Data + sizeof(S7Header) + s7ParamLength;int s7DataLen = ntohs(s7Header-&gt;dataLength);s7p_log(&quot;s7_protocol_parse: S7 Param Length: %d, S7 Data Length: %d&quot;, s7ParamLength, s7DataLen);// 4. 解析 S7 Parameter 和 Data (使用查找表)if (s7Header-&gt;messageType == S7_MESSAGE_TYPE_JOB) &#123; // Job s7p_log(&quot;s7_protocol_parse: Message Type: Job Request&quot;); S7ParamParserReq parser = find_parser_req(s7Param[0]); // param 的第一个字节是 functionCode if (parser) &#123; if (parser(s7Param, s7ParamLength, packet) != 0) &#123; s7p_log(&quot;s7_protocol_parse: S7 parameter parsing failed (Job Request).&quot;); s7_free_packet(packet); return -1; &#125; &#125; else &#123; s7p_log(&quot;s7_protocol_parse: Unknown S7 function code in Job Request: 0x%02x&quot;, s7Param[0]); return -1; // 未知 function code &#125;&#125;else if (s7Header-&gt;messageType == S7_MESSAGE_TYPE_ACK_DATA) &#123; // Ack-Data s7p_log(&quot;s7_protocol_parse: Message Type: Ack-Data Response&quot;); int parserType; void *parser = find_parser_res(s7Param[0], &amp;parserType); //param的第一个字节是functionCode if(parser) &#123; if (parserType == 0) &#123; // S7ParamParserRes (有 data) s7p_log(&quot;s7_protocol_parse: Calling Ack-Data response parser (with data).&quot;); S7ParamParserRes resParser = (S7ParamParserRes)parser; if (resParser(s7Param, s7ParamLength, s7DataItem, s7DataLen, packet) != 0) &#123; s7p_log(&quot;s7_protocol_parse: S7 parameter parsing failed (Ack-Data response).&quot;); s7_free_packet(packet); return -1; &#125; &#125; else if (parserType == 1) &#123; // S7ParamParserSimpleRes (无 data) s7p_log(&quot;s7_protocol_parse: Calling Ack-Data response parser (no data).&quot;); S7ParamParserSimpleRes simpleParser = (S7ParamParserSimpleRes)parser; if (simpleParser(s7Param, s7ParamLength, packet) != 0) &#123; s7p_log(&quot;s7_protocol_parse: S7 parameter parsing failed (Ack-Data response).&quot;); s7_free_packet(packet); return -1; &#125; &#125; else &#123; s7p_log(&quot;s7_protocol_parse: Invalid parser type for Ack-Data response: %d&quot;, parserType); s7_free_packet(packet); return -1; // 无效 parser 类型 &#125; &#125; else &#123; s7p_log(&quot;s7_protocol_parse: Unknown S7 function code in Ack-Data response: 0x%02x&quot;, s7Param[0]); return -1; // 未知 function code &#125;&#125;else &#123; s7p_log(&quot;s7_protocol_parse: Unsupported S7 message type: 0x%02x&quot;, s7Header-&gt;messageType); return -1; // 不是 Job 或 Ack-Data&#125;// 如果 dataLen &gt; 0 且是 Download Block 请求, 保存 block 数据if (s7DataLen &gt; 0 &amp;&amp; packet-&gt;functionCode == S7_FUNCTION_DOWNLOAD_BLOCK)&#123; s7p_log(&quot;s7_protocol_parse: Downloading block data. Length: %d&quot;, s7DataLen); packet-&gt;blockData = (uint8_t*)malloc(s7DataLen); if (!packet-&gt;blockData) &#123; s7p_log(&quot;s7_protocol_parse: Memory allocation failed for block data.&quot;); s7_free_packet(packet); return -1; &#125; memcpy(packet-&gt;blockData, s7DataItem, s7DataLen); packet-&gt;blockDataLen = s7DataLen; s7p_log(&quot;s7_protocol_parse: Copied %d bytes of block data.&quot;, s7DataLen);&#125; s7p_log(&quot;s7_protocol_parse: S7 parsing complete.&quot;);return 0; // 成功 IGNORE_WHEN_COPYING_START content_copy download Use code with caution. IGNORE_WHEN_COPYING_END } void s7_protocol_cleanup() {&#x2F;&#x2F; 清理逻辑 (如果有的话)s7p_log(“s7_protocol_cleanup called.”);} int s7_protocol_init() {&#x2F;&#x2F; 初始化逻辑 (如果有的话)s7p_log(“s7_protocol_init called.”);return 0;} s7-protocol.h:&#x2F;&#x2F;s7-protocol.h#ifndef S7_PROTOCOL_H#define S7_PROTOCOL_H #include &lt;stdint.h&gt;#include &lt;stdbool.h&gt;#include &lt;stddef.h&gt; &#x2F;&#x2F; 包含 size_t 的定义 &#x2F;&#x2F; S7 错误代码枚举typedef enum {S7_ERR_NO_ERROR &#x3D; 0x00,&#x2F;&#x2F; … (其他错误代码)S7_ERR_WRONG_PDU &#x3D; 0x07,S7_ERR_INVALID_BLOCK_LENGTH&#x3D;0x0a,S7_ERR_INVALID_DATA_SIZE&#x3D;0xd4,S7_ERR_FUNCTION_NOT_AVAIL&#x3D;0xd6,S7_ERR_INSUFFICIENT_RESOURCES&#x3D;0xd8} S7ErrorCode; &#x2F;&#x2F; S7 消息类型枚举typedef enum {S7_MESSAGE_TYPE_JOB &#x3D; 0x01,S7_MESSAGE_TYPE_ACK &#x3D; 0x02,S7_MESSAGE_TYPE_ACK_DATA &#x3D; 0x03,S7_MESSAGE_TYPE_USERDATA &#x3D; 0x07} S7MessageType; &#x2F;&#x2F; S7 功能码枚举typedef enum {S7_FUNCTION_READ_VAR &#x3D; 0x04,S7_FUNCTION_WRITE_VAR &#x3D; 0x05,S7_FUNCTION_REQ_DOWNLOAD &#x3D; 0x1A,S7_FUNCTION_DOWNLOAD_BLOCK &#x3D; 0x1B,S7_FUNCTION_DOWNLOAD_ENDED &#x3D; 0x1C,S7_FUNCTION_START_UPLOAD &#x3D; 0x1D,S7_FUNCTION_UPLOAD &#x3D; 0x1E,S7_FUNCTION_END_UPLOAD &#x3D; 0x1F,S7_FUNCTION_PLC_STOP &#x3D; 0x29,S7_FUNCTION_PLC_START &#x3D; 0x28,S7_FUNCTION_SETUP_COMM &#x3D; 0xF0 &#x2F;&#x2F; 特殊情况：COTP 连接请求} S7FunctionCode; &#x2F;&#x2F; 表示单个 S7 项的结构体 (用于读&#x2F;写操作)typedef struct {uint8_t syntaxId; &#x2F;&#x2F; 0x10 (S7ANY) 或 0x12 (用于响应)uint8_t transportSize; &#x2F;&#x2F; 数据类型 (例如，BOOL, BYTE, WORD, REAL)uint16_t length; &#x2F;&#x2F; 长度，以位 (BOOL) 或字节为单位uint8_t area; &#x2F;&#x2F; 内存区域 (例如，I, Q, M, DB, CT, TM)uint16_t dbNumber; &#x2F;&#x2F; 数据块编号 (如果适用)uint32_t startOffset; &#x2F;&#x2F; 字节地址 * 8 + 位偏移uint8_t returnCode; &#x2F;&#x2F; 0xFF 表示成功 (仅限响应)uint8_t *data; &#x2F;&#x2F; 指向数据缓冲区的指针uint16_t dataLengthBytes;&#x2F;&#x2F; 数据的实际长度（以字节为单位）} S7Item; &#x2F;&#x2F; 表示已解析的 S7 数据包的结构体typedef struct {S7MessageType messageType; &#x2F;&#x2F; Job, Ack, Ack-Data, UserDataS7FunctionCode functionCode; &#x2F;&#x2F; ReadVar, WriteVar, PLCStop 等int itemCount; &#x2F;&#x2F; 读&#x2F;写变量请求&#x2F;响应中的项数S7Item *items; &#x2F;&#x2F; S7 项的数组 (用于读&#x2F;写请求&#x2F;响应) 123456789101112 uint8_t blockType; // &#x27;B&#x27;, &#x27;F&#x27;, &#x27;O&#x27; 等 (用于块操作)uint32_t blockNumber; // 下载/上传的块编号uint8_t *blockData; // 指向块数据的指针 (下载块请求)size_t blockDataLen; // blockData 的长度S7ErrorCode errorClass; // S7 错误类S7ErrorCode errorCode; // S7 错误代码uint16_t pduReference;uint8_t method; //0x09 停止; 0x04/0x05 启动// ... 其他相关字段 IGNORE_WHEN_COPYING_START content_copy download Use code with caution. IGNORE_WHEN_COPYING_END } S7Packet; &#x2F;&#x2F; 函数原型int s7_protocol_init();int s7_protocol_parse(const unsigned char *data, int len, S7Packet *packet);void s7_protocol_cleanup();void s7_free_packet(S7Packet packet);char s7_decode_data(const S7Item *item, char * resultBuf, size_t bufSize); #include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa&#x2F;inet.h&gt;#include &lt;math.h&gt;#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;#include &lt;time.h&gt; &#x2F;&#x2F; 函数指针类型 (请求)：参数为 param, paramLen, packettypedef int (*S7ParamParserReq)(const unsigned char *param, int paramLen, S7Packet *packet); &#x2F;&#x2F; 函数指针类型 (响应)：参数为 param, paramLen, data, dataLen, packettypedef int (*S7ParamParserRes)(const unsigned char *param, int paramLen, const unsigned char *data, int dataLen, S7Packet *packet); &#x2F;&#x2F; 函数指针类型 (无 data 的响应): param, paramLen, packettypedef int (*S7ParamParserSimpleRes)(const unsigned char *param, int paramLen, S7Packet *packet); &#x2F;&#x2F; 前向声明解析函数int parse_s7_read_var_request(const unsigned char *param, int paramLen, S7Packet *packet);int parse_s7_read_var_response(const unsigned char *param, int paramLen, const unsigned char *data, int dataLen, S7Packet packet);int parse_s7_write_var_request(const unsigned char *param, int paramLen, S7Packet *packet);int parse_s7_write_var_response(const unsigned char* param, int paramLen, const unsigned char* data, int dataLen, S7Packet packet);int parse_s7_plc_control_request(const unsigned char param, int paramLen, S7Packet *packet);int parse_s7_plc_control_response(const unsigned char* param, int paramLen, S7Packet packet);int parse_s7_req_download_request(const unsigned char param, int paramLen, S7Packet *packet);int parse_s7_download_block_request(const unsigned char *param, int paramLen, S7Packet* packet);int parse_s7_upload_request(const unsigned char* param, int paramLen, S7Packet packet);int parse_s7_download_upload_response(const unsigned char *param, int paramLen, S7Packet *packet); &#x2F;&#x2F; S7 参数解析函数查找表 (Job Requests)static const struct {uint8_t functionCode;S7ParamParserReq parser;} s7_param_parsers_req[] &#x3D; {{S7_FUNCTION_READ_VAR, parse_s7_read_var_request},{S7_FUNCTION_WRITE_VAR, parse_s7_write_var_request},{S7_FUNCTION_PLC_STOP, parse_s7_plc_control_request},{S7_FUNCTION_PLC_START, parse_s7_plc_control_request},{S7_FUNCTION_REQ_DOWNLOAD, parse_s7_req_download_request},{S7_FUNCTION_DOWNLOAD_BLOCK, parse_s7_download_block_request},{S7_FUNCTION_START_UPLOAD, parse_s7_upload_request},{0, NULL} &#x2F;&#x2F; 结束标记}; &#x2F;&#x2F; S7 参数解析函数查找表 (Ack-Data Responses)static const struct {uint8_t functionCode;void parser;int type; &#x2F;&#x2F; 0 for S7ParamParserRes, 1 for S7ParamParserSimpleRes} s7_param_parsers_res[] &#x3D; {{S7_FUNCTION_READ_VAR, parse_s7_read_var_response, 0}, &#x2F;&#x2F; 有 data{S7_FUNCTION_WRITE_VAR, (void)parse_s7_write_var_response, 0}, &#x2F;&#x2F; 有 data{S7_FUNCTION_PLC_STOP, (void*)parse_s7_plc_control_response, 1}, &#x2F;&#x2F; 无 data{S7_FUNCTION_PLC_START, (void*)parse_s7_plc_control_response, 1}, &#x2F;&#x2F; 无 data{S7_FUNCTION_DOWNLOAD_BLOCK, (void*)parse_s7_download_upload_response, 1}, &#x2F;&#x2F; 无 data{S7_FUNCTION_DOWNLOAD_ENDED, (void*)parse_s7_download_upload_response, 1}, &#x2F;&#x2F; 无 data{S7_FUNCTION_UPLOAD, (void*)parse_s7_download_upload_response, 1}, &#x2F;&#x2F; 无 data{S7_FUNCTION_END_UPLOAD, (void*)parse_s7_download_upload_response, 1}, &#x2F;&#x2F; 无 data{0, NULL, 0} &#x2F;&#x2F; 结束标记};#endif &#x2F;&#x2F; S7_PROTOCOL_H s7.c:&#x2F;&#x2F;s7.c#include “arkime.h”#include “s7-protocol.h”#include &lt;string.h&gt;#include &lt;arpa&#x2F;inet.h&gt; &#x2F;&#x2F; For htonl, ntohs#include &lt;time.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt; &#x2F;&#x2F; For va_list, etc.#include &lt;glib.h&gt;#include &lt;netinet&#x2F;ip.h&gt; &#x2F;&#x2F; For struct ip#include &lt;netinet&#x2F;tcp.h&gt; &#x2F;&#x2F; For struct tcphdr &#x2F;&#x2F; Arkime 字段定义 (全局变量)static int s7FunctionCodeField;static int s7DataBlockIdField; &#x2F;&#x2F; Deprecatedstatic int s7ItemCountField;static int s7TransportSizeField;static int s7DataLengthField;static int s7AreaField;static int s7DBNumberField;static int s7StartOffsetField;static int s7ErrorClassField;static int s7ErrorCodeField;static int s7ReturnCodeField;static int s7DataField;static int s7PDUReferenceField;static int s7MessageTypeField;static int s7BlockTypeField;static int s7BlockNumberField;static int s7BlockDataField;static int s7MethodField; &#x2F;&#x2F; 日志函数 (使用 fprintf)void s7_log(const char *format, …) {va_list args;va_start(args, format); 123456789101112131415161718192021 time_t timer;char time_buffer[26];struct tm tm_info;time(&amp;timer);if (localtime_r(&amp;timer, &amp;tm_info) == NULL) &#123; perror(&quot;localtime_r&quot;); // 处理错误 return;&#125;if (strftime(time_buffer, sizeof(time_buffer), &quot;%Y-%m-%d %H:%M:%S&quot;, &amp;tm_info) == 0) &#123; fprintf(stderr, &quot;strftime failed &quot;); return;&#125;fprintf(stderr, &quot;%s [s7_plugin] &quot;, time_buffer);vfprintf(stderr, format, args); // 直接输出到 stderrfprintf(stderr, &quot; &quot;);va_end(args);fflush(stderr); // 确保立即输出 IGNORE_WHEN_COPYING_START content_copy download Use code with caution. IGNORE_WHEN_COPYING_END } &#x2F;&#x2F; 分类器函数void s7_classify(ArkimeSession_t *session, const uint8_t *data, int remaining, int UNUSED(which), void *UNUSED(uw)){s7_log(“s7_classify: Called. remaining&#x3D;%d, srcPort&#x3D;%d, dstPort&#x3D;%d”, remaining, session-&gt;port1, session-&gt;port2); 123456789101112131415 // 打印数据包的前 20 个字节 (用于调试)fprintf(stderr, &quot;s7_classify: Data: &quot;);for (int i = 0; i &lt; 20 &amp;&amp; i &lt; remaining; i++) &#123; fprintf(stderr, &quot;%02x &quot;, data[i]);&#125;fprintf(stderr, &quot; &quot;);// 1. 检查是否是TCP,且端口为102if (session-&gt;port1 != 102 &amp;&amp; session-&gt;port2 != 102) &#123; s7_log(&quot;s7_classify: Not port 102&quot;); return; // 不是 102 端口，直接返回&#125;// 2.ARKIME 会在TCP连接建立后自动调用parser,以及三次握手期间的SYN, ACK包,如果数据包长度足够，我们再尝试进一步分类 IGNORE_WHEN_COPYING_START content_copy download Use code with caution. IGNORE_WHEN_COPYING_END if (remaining &gt;&#x3D; 6 &amp;&amp; data[0] &#x3D;&#x3D; 0x03) {s7_log(“s7_classify: TPKT version check passed.”);&#x2F;&#x2F; 检查 COTP PDU 类型 (DT Data 或 Connection Request)if (data[1] !&#x3D; 0){ &#x2F;&#x2F;COTP 长度不为0int cotp_len &#x3D; data[4] + 1;if (remaining &gt;&#x3D; 4 + cotp_len &amp;&amp; (data[4+1] &#x3D;&#x3D; 0xf0 || data[4 + 1] &#x3D;&#x3D; 0xe0)){s7_log(“s7_classify: Looks like S7 traffic. Returning.”);arkime_session_add_protocol(session, “s7”); &#x2F;&#x2F; 在classify里打标签return;}else{s7_log(“s7_classify: COTP PDU type check failed.”);}}else{s7_log(“s7_classify: COTP length is zero”);} 1234567 &#125;else&#123; s7_log(&quot;s7_classify: Basic checks failed.&quot;);&#125;s7_log(&quot;s7_classify: S7 connection establishment or non-S7, returning.&quot;);return ; // 即使没有 S7 数据，也要返回，让 Arkime 继续处理 TCP 连接 IGNORE_WHEN_COPYING_START content_copy download Use code with caution. IGNORE_WHEN_COPYING_END } &#x2F;&#x2F; 数据包解析函数int s7_plugin_parser(ArkimeSession_t *session, void *UNUSED(uw), const unsigned char *data, int len, int UNUSED(which)) {if (session &#x3D;&#x3D; NULL) {s7_log(“ERROR: s7_plugin_parser called with NULL session”);return 0;}s7_log(“s7_plugin_parser: Parser called!”); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160 if (session-&gt;port1 == 102 || session-&gt;port2 == 102)&#123; //arkime_session_add_protocol(session, &quot;s7&quot;); //在classify里打标签 s7_log(&quot;S7 Plugin: parser called for session %p, srcPort: %d, dstPort: %d&quot;, session, session-&gt;port1, session-&gt;port2); // 检查是否是 TCP SYN/ACK (连接建立阶段) if (len &lt; 7) &#123; s7_log(&quot;s7_plugin_parser: Likely a TCP SYN/ACK packet. No S7 data to parse.&quot;); return 0; &#125; S7Packet s7packet; memset(&amp;s7packet, 0, sizeof(s7packet)); int result = s7_protocol_parse(data, len, &amp;s7packet); if (result == 0) &#123; s7_log(&quot;s7_plugin_parser: s7_protocol_parse successful&quot;); if (s7packet.functionCode != 0) &#123; arkime_field_int_add(s7FunctionCodeField, session, s7packet.functionCode); s7_log(&quot;s7_plugin_parser: Added s7FunctionCodeField: %d&quot;, s7packet.functionCode); &#125; if (s7packet.itemCount != 0) &#123; arkime_field_int_add(s7ItemCountField, session, s7packet.itemCount); s7_log(&quot;s7_plugin_parser: Added s7ItemCountField: %d&quot;, s7packet.itemCount); &#125; if (s7packet.messageType !=0) &#123; arkime_field_int_add(s7MessageTypeField, session, s7packet.messageType); s7_log(&quot;s7_plugin_parser: Added s7MessageTypeField: %d&quot;, s7packet.messageType); &#125; if (s7packet.pduReference != 0) &#123; arkime_field_int_add(s7PDUReferenceField, session, s7packet.pduReference); s7_log(&quot;s7_plugin_parser: Added s7PDUReferenceField: %d&quot;, s7packet.pduReference); &#125; if(s7packet.method != 0)&#123; arkime_field_int_add(s7MethodField, session, s7packet.method); s7_log(&quot;s7_plugin_parser: Added s7MethodField: %d&quot;, s7packet.method); &#125; if (s7packet.functionCode == S7_FUNCTION_REQ_DOWNLOAD || s7packet.functionCode == S7_FUNCTION_DOWNLOAD_BLOCK || s7packet.functionCode == S7_FUNCTION_START_UPLOAD || s7packet.functionCode == S7_FUNCTION_UPLOAD) &#123; if (s7packet.blockType != 0) &#123; char blockTypeStr[2] = &#123;s7packet.blockType, 0&#125;; arkime_field_string_add(s7BlockTypeField, session, blockTypeStr, 1, TRUE); s7_log(&quot;s7_plugin_parser: Added s7BlockTypeField: %s&quot;, blockTypeStr); &#125; if(s7packet.blockNumber != 0)&#123; arkime_field_int_add(s7BlockNumberField, session, s7packet.blockNumber); s7_log(&quot;s7_plugin_parser: Added s7BlockNumberField: %d&quot;, s7packet.blockNumber); &#125; if (s7packet.blockData &amp;&amp; s7packet.blockDataLen &gt; 0) &#123; char *encodedData = g_base64_encode(s7packet.blockData, s7packet.blockDataLen); arkime_field_string_add(s7BlockDataField, session, encodedData, strlen(encodedData), TRUE); s7_log(&quot;s7_plugin_parser: Added s7BlockDataField: %s&quot;, encodedData); g_free(encodedData); &#125; &#125; if (s7packet.items) &#123; for (int i = 0; i &lt; s7packet.itemCount; i++) &#123; S7Item *item = &amp;s7packet.items[i]; if(item) &#123; if (item-&gt;transportSize != 0) &#123; arkime_field_int_add(s7TransportSizeField, session, item-&gt;transportSize); s7_log(&quot;s7_plugin_parser: Added s7TransportSizeField: %d&quot;, item-&gt;transportSize); &#125; if (item-&gt;length != 0) &#123; arkime_field_int_add(s7DataLengthField, session, item-&gt;length); s7_log(&quot;s7_plugin_parser: Added s7DataLengthField: %d&quot;, item-&gt;length); &#125; if (item-&gt;returnCode != 0) &#123; arkime_field_int_add(s7ReturnCodeField, session, item-&gt;returnCode); s7_log(&quot;s7_plugin_parser: Added s7ReturnCodeField: %d&quot;, item-&gt;returnCode); &#125; switch (item-&gt;area) &#123; case 0x81: arkime_field_string_add(s7AreaField, session, &quot;PA&quot;, 2, TRUE); s7_log(&quot;s7_plugin_parser: Added s7AreaField: PA&quot;); break; // Process Image Input case 0x82: arkime_field_string_add(s7AreaField, session, &quot;PB&quot;, 2, TRUE); s7_log(&quot;s7_plugin_parser: Added s7AreaField: PB&quot;); break; // Process Image Output case 0x83: arkime_field_string_add(s7AreaField, session, &quot;M&quot;, 1, TRUE); s7_log(&quot;s7_plugin_parser: Added s7AreaField: M&quot;); break; // Merkers case 0x84: arkime_field_string_add(s7AreaField, session, &quot;DB&quot;, 2, TRUE); s7_log(&quot;s7_plugin_parser: Added s7AreaField: DB&quot;); break; // Data Blocks case 0x1C: arkime_field_string_add(s7AreaField, session, &quot;CT&quot;, 2, TRUE); s7_log(&quot;s7_plugin_parser: Added s7AreaField: CT&quot;); break; //S7 Counters case 0x1D: arkime_field_string_add(s7AreaField, session, &quot;TM&quot;, 2, TRUE); s7_log(&quot;s7_plugin_parser: Added s7AreaField: TM&quot;); break; // S7 Timers default: arkime_field_string_add(s7AreaField, session, &quot;UNKNOWN&quot;, 7, TRUE); s7_log(&quot;s7_plugin_parser: Added s7AreaField: UNKNOWN&quot;); break; &#125; if (item-&gt;dbNumber != 0) &#123; arkime_field_int_add(s7DBNumberField, session, item-&gt;dbNumber); s7_log(&quot;s7_plugin_parser: Added s7DBNumberField: %d&quot;, item-&gt;dbNumber); &#125; if (item-&gt;startOffset != 0) &#123; arkime_field_int_add(s7StartOffsetField, session, item-&gt;startOffset); s7_log(&quot;s7_plugin_parser: Added s7StartOffsetField: %d&quot;, item-&gt;startOffset); &#125; if (item-&gt;data &amp;&amp; item-&gt;dataLengthBytes &gt; 0) &#123; char resultBuf[256]; if (s7_decode_data(item, resultBuf, sizeof(resultBuf))) &#123; arkime_field_string_add(s7DataField, session, resultBuf, strlen(resultBuf), TRUE); s7_log(&quot;s7_plugin_parser: Added s7DataField: %s&quot;, resultBuf); &#125; &#125; &#125; &#125; &#125; if (s7packet.errorClass != 0 || s7packet.errorCode != 0) &#123; arkime_field_int_add(s7ErrorClassField, session, s7packet.errorClass); s7_log(&quot;s7_plugin_parser: Added s7ErrorClassField: %d&quot;, s7packet.errorClass); arkime_field_int_add(s7ErrorCodeField, session, s7packet.errorCode); s7_log(&quot;s7_plugin_parser: Added s7ErrorCodeField: %d&quot;, s7packet.errorCode); &#125; s7_free_packet(&amp;s7packet); &#125; else &#123; s7_log(&quot;S7 parsing failed for session %p&quot;, session); return 1; &#125;&#125;else &#123; return 0;&#125;return 0; IGNORE_WHEN_COPYING_START content_copy download Use code with caution. IGNORE_WHEN_COPYING_END } &#x2F;&#x2F; 插件初始化, 程序启动时定义字段void arkime_plugin_init(){s7_log(“arkime_plugin_init() called”); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134 s7FunctionCodeField = arkime_field_define(&quot;s7&quot;, &quot;integer&quot;, &quot;s7.functionCode&quot;, &quot;S7 Function Code&quot;, &quot;s7.fc&quot;, &quot;S7 function code&quot;, ARKIME_FIELD_TYPE_INT_GHASH, ARKIME_FIELD_FLAG_CNT, &quot;category&quot;, &quot;s7&quot;, NULL);s7ItemCountField = arkime_field_define(&quot;s7&quot;, &quot;integer&quot;, &quot;s7.itemCount&quot;, &quot;S7 Item Count&quot;, &quot;s7.items&quot;, &quot;S7 item count&quot;, ARKIME_FIELD_TYPE_INT_GHASH, ARKIME_FIELD_FLAG_CNT, &quot;category&quot;, &quot;s7&quot;, NULL);s7TransportSizeField = arkime_field_define(&quot;s7&quot;, &quot;integer&quot;, &quot;s7.transportSize&quot;, &quot;S7 Transport Size&quot;, &quot;s7.tsize&quot;, &quot;S7 transport size&quot;, ARKIME_FIELD_TYPE_INT_GHASH, ARKIME_FIELD_FLAG_CNT, &quot;category&quot;, &quot;s7&quot;, &quot;help&quot;, &quot;BIT=1, BYTE/WORD/DWORD=2, COUNTER/TIMER=9, REAL=4&quot;, NULL);s7DataLengthField = arkime_field_define(&quot;s7&quot;, &quot;integer&quot;, &quot;s7.dataLength&quot;, &quot;S7 Data Length&quot;, &quot;s7.dlen&quot;, &quot;S7 data length in bits&quot;, ARKIME_FIELD_TYPE_INT_GHASH, ARKIME_FIELD_FLAG_CNT, &quot;category&quot;, &quot;s7&quot;, NULL);s7AreaField = arkime_field_define(&quot;s7&quot;, &quot;lotext&quot;, &quot;s7.area&quot;, &quot;S7 Area&quot;, &quot;s7.area&quot;, &quot;S7 memory area&quot;, ARKIME_FIELD_TYPE_STR_HASH, ARKIME_FIELD_FLAG_CNT, &quot;category&quot;, &quot;s7&quot;, &quot;help&quot;, &quot;PA=ProcessImageInput, PB=ProcessImageOutput, M=Merkers, DB=DataBlocks, CT=Counters, TM=Timers&quot;, NULL); s7DBNumberField = arkime_field_define(&quot;s7&quot;, &quot;integer&quot;, &quot;s7.dbNumber&quot;, &quot;S7 DB Number&quot;, &quot;s7.db&quot;, &quot;S7 data block number&quot;, ARKIME_FIELD_TYPE_INT_GHASH, ARKIME_FIELD_FLAG_CNT, &quot;category&quot;, &quot;s7&quot;, NULL);s7StartOffsetField = arkime_field_define(&quot;s7&quot;, &quot;integer&quot;, &quot;s7.startOffset&quot;, &quot;S7 Start Offset&quot;, &quot;s7.offset&quot;, &quot;S7 start offset in bits&quot;, ARKIME_FIELD_TYPE_INT_GHASH, ARKIME_FIELD_FLAG_CNT, &quot;category&quot;, &quot;s7&quot;, NULL);s7ErrorClassField = arkime_field_define(&quot;s7&quot;, &quot;integer&quot;, &quot;s7.errorClass&quot;, &quot;S7 Error Class&quot;, &quot;s7.eclass&quot;, &quot;S7 error class&quot;, ARKIME_FIELD_TYPE_INT_GHASH, ARKIME_FIELD_FLAG_CNT, &quot;category&quot;, &quot;s7&quot;, NULL); s7ErrorCodeField = arkime_field_define(&quot;s7&quot;, &quot;integer&quot;, &quot;s7.errorCode&quot;, &quot;S7 Error Code&quot;, &quot;s7.ecode&quot;, &quot;S7 error code&quot;, ARKIME_FIELD_TYPE_INT_GHASH, ARKIME_FIELD_FLAG_CNT, &quot;category&quot;, &quot;s7&quot;, NULL); s7ReturnCodeField = arkime_field_define(&quot;s7&quot;, &quot;integer&quot;, &quot;s7.returnCode&quot;, &quot;S7 Return Code&quot;, &quot;s7.rcode&quot;, &quot;S7 return code for each item&quot;, ARKIME_FIELD_TYPE_INT_GHASH, ARKIME_FIELD_FLAG_CNT, &quot;category&quot;, &quot;s7&quot;, NULL);s7DataField = arkime_field_define(&quot;s7&quot;, &quot;string&quot;, &quot;s7.data&quot;, &quot;S7 Data&quot;, &quot;s7.data&quot;, &quot;S7 data value&quot;, ARKIME_FIELD_TYPE_STR_HASH, 0, &quot;category&quot;, &quot;s7&quot;, NULL);s7PDUReferenceField = arkime_field_define(&quot;s7&quot;, &quot;integer&quot;, &quot;s7.pduReference&quot;, &quot;S7 PDU Reference&quot;, &quot;s7.pduref&quot;, &quot;S7 PDU reference&quot;, ARKIME_FIELD_TYPE_INT_GHASH, ARKIME_FIELD_FLAG_CNT, &quot;category&quot;, &quot;s7&quot;, NULL);s7MessageTypeField = arkime_field_define(&quot;s7&quot;, &quot;integer&quot;, &quot;s7.messageType&quot;, &quot;S7 Message Type&quot;, &quot;s7.mtype&quot;, &quot;S7 message type&quot;, ARKIME_FIELD_TYPE_INT_GHASH, ARKIME_FIELD_FLAG_CNT, &quot;category&quot;, &quot;s7&quot;, &quot;help&quot;, &quot;1=Job, 2=Ack, 3=Ack-Data, 7=UserData&quot;, NULL);s7BlockTypeField = arkime_field_define(&quot;s7&quot;, &quot;lotext&quot;, &quot;s7.blockType&quot;, &quot;S7 Block Type&quot;, &quot;s7.btype&quot;, &quot;S7 Block Type&quot;, ARKIME_FIELD_TYPE_STR, ARKIME_FIELD_FLAG_CNT, &quot;category&quot;, &quot;s7&quot;, &quot;help&quot;, &quot;B=Program, F=Data, O=Organization&quot;, NULL);s7BlockNumberField = arkime_field_define(&quot;s7&quot;, &quot;integer&quot;, &quot;s7.blockNumber&quot;, &quot;S7 Block Number&quot;, &quot;s7.bnum&quot;, &quot;S7 Block Number&quot;, ARKIME_FIELD_TYPE_INT_GHASH, ARKIME_FIELD_FLAG_CNT, &quot;category&quot;, &quot;s7&quot;, NULL);s7BlockDataField = arkime_field_define(&quot;s7&quot;, &quot;string&quot;, &quot;s7.blockData&quot;, &quot;S7 Block Data&quot;, &quot;s7.bdata&quot;, &quot;S7 Block Data&quot;, ARKIME_FIELD_TYPE_STR, 0, &quot;category&quot;, &quot;s7&quot;, NULL);s7DataBlockIdField = arkime_field_define(&quot;s7&quot;, &quot;integer&quot;, // Deprecated &quot;s7.dataBlockId&quot;, &quot;S7 Data Block ID&quot;, &quot;s7dbid&quot;, &quot;S7 data block ID (Deprecated)&quot;, ARKIME_FIELD_TYPE_INT_GHASH, ARKIME_FIELD_FLAG_CNT | ARKIME_FIELD_FLAG_DISABLED, &quot;category&quot;, &quot;s7&quot;, NULL);s7MethodField = arkime_field_define(&quot;s7&quot;, &quot;integer&quot;, &quot;s7.method&quot;, &quot;S7 Method&quot;, &quot;s7.method&quot;, &quot;S7 Method (PLC Start/Stop)&quot;, ARKIME_FIELD_TYPE_INT_GHASH, 0, &quot;category&quot;, &quot;s7&quot;, NULL);// 初始化 S7 解析库s7_protocol_init();s7_log(&quot;S7 Plugin initialized successfully!&quot;); IGNORE_WHEN_COPYING_START content_copy download Use code with caution. IGNORE_WHEN_COPYING_END } &#x2F;&#x2F; 插件退出 (可选)void s7_plugin_exit(){s7_protocol_cleanup(); &#x2F;&#x2F; 清理 s7-protocol 库} &#x2F;&#x2F; Arkime 插件入口点, 程序加载时注册解析函数#ifndef UNIT_TESTvoid arkime_plugin_load() {s7_log(“arkime_plugin_load() called”);&#x2F;&#x2F; 注册 TCP 端口 102 的分类器，将流量定向到 s7_plugin_parser, 匹配TPKT头部的版本号0x03arkime_parsers_classifier_register_tcp(“s7”, NULL, 0, (unsigned char *)”\\x03”, 1, s7_classify);arkime_plugin_init(); &#x2F;&#x2F; 初始化插件}#endif wireshark捕获S7-1511-opc-request-all-types.pcap的数据为Frame 1: 66 bytes on wire (528 bits), 66 bytes captured (528 bits)Ethernet II, Src: VMware_34:60:5d (00:50:56:34:60:5d), Dst: Siemens_13:41:73 (00:1b:1b:13:41:73)Internet Protocol Version 4, Src: 192.168.25.146, Dst: 192.168.25.139Transmission Control Protocol, Src Port: 55863, Dst Port: 102, Seq: 0, Len: 0 0000 00 1b 1b 13 41 73 00 50 56 34 60 5d 08 00 45 00 ….As.PV4&#96;]..E.0010 00 34 43 6c 40 00 80 06 02 ea c0 a8 19 92 c0 a8 .4Cl@………..0020 19 8b da 37 00 66 a0 f0 b7 38 00 00 00 00 80 02 …7.f…8……0030 20 00 67 e1 00 00 02 04 05 b4 01 03 03 02 01 01 .g………….0040 04 02 .. Frame 2: 66 bytes on wire (528 bits), 66 bytes captured (528 bits)Ethernet II, Src: VMware_34:60:5d (00:50:56:34:60:5d), Dst: Siemens_13:41:73 (00:1b:1b:13:41:73)Internet Protocol Version 4, Src: 192.168.25.146, Dst: 192.168.25.139Transmission Control Protocol, Src Port: 55863, Dst Port: 102, Seq: 0, Len: 0 0000 00 1b 1b 13 41 73 00 50 56 34 60 5d 08 00 45 00 ….As.PV4&#96;]..E.0010 00 34 43 6c 40 00 80 06 02 ea c0 a8 19 92 c0 a8 .4Cl@………..0020 19 8b da 37 00 66 a0 f0 b7 38 00 00 00 00 80 02 …7.f…8……0030 20 00 67 e1 00 00 02 04 05 b4 01 03 03 02 01 01 .g………….0040 04 02 .. Frame 3: 60 bytes on wire (480 bits), 60 bytes captured (480 bits)Ethernet II, Src: Siemens_13:41:73 (00:1b:1b:13:41:73), Dst: VMware_34:60:5d (00:50:56:34:60:5d)Internet Protocol Version 4, Src: 192.168.25.139, Dst: 192.168.25.146Transmission Control Protocol, Src Port: 102, Dst Port: 55863, Seq: 0, Ack: 1, Len: 0 0000 00 50 56 34 60 5d 00 1b 1b 13 41 73 08 00 45 00 .PV4]….As..E. 0010 00 2c 02 f7 00 00 1e 06 e5 67 c0 a8 19 8b c0 a8 .,…….g…… 0020 19 92 00 66 da 37 00 04 be 88 a0 f0 b7 39 60 12 …f.7…….9.0030 10 00 e2 53 00 00 02 04 05 b4 02 f0 …S…….. Frame 4: 54 bytes on wire (432 bits), 54 bytes captured (432 bits)Ethernet II, Src: VMware_34:60:5d (00:50:56:34:60:5d), Dst: Siemens_13:41:73 (00:1b:1b:13:41:73)Internet Protocol Version 4, Src: 192.168.25.146, Dst: 192.168.25.139Transmission Control Protocol, Src Port: 55863, Dst Port: 102, Seq: 1, Ack: 1, Len: 0 0000 00 1b 1b 13 41 73 00 50 56 34 60 5d 08 00 45 00 ….As.PV4&#96;]..E.0010 00 28 43 6d 40 00 80 06 02 f5 c0 a8 19 92 c0 a8 .(Cm@………..0020 19 8b da 37 00 66 a0 f0 b7 39 00 04 be 89 50 10 …7.f…9….P.0030 fa f0 0f 20 00 00 … .. Frame 5: 54 bytes on wire (432 bits), 54 bytes captured (432 bits)Ethernet II, Src: VMware_34:60:5d (00:50:56:34:60:5d), Dst: Siemens_13:41:73 (00:1b:1b:13:41:73)Internet Protocol Version 4, Src: 192.168.25.146, Dst: 192.168.25.139Transmission Control Protocol, Src Port: 55863, Dst Port: 102, Seq: 1, Ack: 1, Len: 0 0000 00 1b 1b 13 41 73 00 50 56 34 60 5d 08 00 45 00 ….As.PV4&#96;]..E.0010 00 28 43 6d 40 00 80 06 02 f5 c0 a8 19 92 c0 a8 .(Cm@………..0020 19 8b da 37 00 66 a0 f0 b7 39 00 04 be 89 50 10 …7.f…9….P.0030 fa f0 0f 20 00 00 … .. Frame 6: 104 bytes on wire (832 bits), 104 bytes captured (832 bits)Ethernet II, Src: VMware_34:60:5d (00:50:56:34:60:5d), Dst: Siemens_13:41:73 (00:1b:1b:13:41:73)Internet Protocol Version 4, Src: 192.168.25.146, Dst: 192.168.25.139Transmission Control Protocol, Src Port: 55863, Dst Port: 102, Seq: 1, Ack: 1, Len: 50TPKT, Version: 3, Length: 50ISO 8073&#x2F;X.224 COTP Connection-Oriented Transport Protocol 0000 00 1b 1b 13 41 73 00 50 56 34 60 5d 08 00 45 00 ….As.PV4&#96;]..E.0010 00 5a 43 6e 40 00 80 06 02 c2 c0 a8 19 92 c0 a8 .ZCn@………..0020 19 8b da 37 00 66 a0 f0 b7 39 00 04 be 89 50 18 …7.f…9….P.0030 fa f0 a8 2c 00 00 03 00 00 32 2d e0 00 00 00 28 …,…..2-….(0040 00 c1 10 53 4e 4f 50 43 43 30 30 30 32 30 30 30 …SNOPCC00020000050 30 30 31 c2 10 53 49 4d 41 54 49 43 2d 52 4f 4f 001..SIMATIC-ROO0060 54 2d 4f 54 48 c0 01 0a T-OTH… 更改代码，from scapy.all import * — 配置 (根据你的虚拟机配置) —dst_mac &#x3D; “00:0c:29:70:3a:0a” # 虚拟机网卡 MAC 地址src_mac &#x3D; “00:0c:29:70:3a:0a” # 虚拟机网卡 MAC 地址 (通常与 dst_mac 相同)dst_ip &#x3D; “192.168.52.142” # 虚拟机 IP 地址src_ip &#x3D; “192.168.52.142” # 虚拟机 IP 地址 (通常与 dst_ip 相同)dst_port &#x3D; 44818 # Ethernet&#x2F;IP 端口src_port &#x3D; 54321 # 随机源端口iface &#x3D; “ens33” # 网络接口名称 print(“— 开始构建 Ethernet&#x2F;IP 数据包 —“) — 构建数据包 —1. Ethernet 层ether &#x3D; Ether(src&#x3D;src_mac, dst&#x3D;dst_mac) 2. IP 层ip &#x3D; IP(src&#x3D;src_ip, dst&#x3D;dst_ip) 3. TCP 层 (Ethernet&#x2F;IP 通常基于 TCP)tcp &#x3D; TCP(sport&#x3D;src_port, dport&#x3D;dst_port, flags&#x3D;”PA”) # PSH+ACK 4. ENIP&#x2F;CIP 数据 (手动构建) - NOP (No Operation) 命令enip_cip_data &#x3D; b”\\x00\\x00” # NOP command (两个字节的 0x00) — 组合数据包 (使用 Scapy 的 Raw 层) —packet &#x3D; ether &#x2F; ip &#x2F; tcp &#x2F; Raw(load&#x3D;enip_cip_data) print(“数据包构建完成。”) — 发送数据包 —try:print(f”正在通过接口 {iface} 发送数据包…”)sent_count &#x3D; sendp(packet, iface&#x3D;iface, verbose&#x3D;0) # 使用 sendp, 指定接口 12345 if sent_count == 1: print(f&quot;成功发送 &#123;sent_count&#125; 个数据包！&quot;)else: print(f&quot;发送数据包数量异常：&#123;sent_count&#125;&quot;) except OSError as e:print(f”发送数据包时发生错误: {e}”)if “No such device” in str(e):print(“ 请检查网络接口名称 (iface) 是否正确。”)elif “Network is down” in str(e):print(“ 网络已关闭。请检查网络连接。”)else:print(“ 其他网络错误。”) except Exception as e:print(f”发生其他异常: {e}”) finally:print(“— 数据包发送操作完成 —“) 运行该代码后，ethernetip插件无法捕获到数据，要求模仿modbus插件代码，使其输出结果可以返回#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;arpa&#x2F;inet.h&gt;#include &lt;time.h&gt;#include &lt;glib.h&gt; &#x2F;&#x2F; 包含 glib.h 头文件#include &lt;dlfcn.h&gt; &#x2F;&#x2F; 包含 dlfcn.h 头文件#include “arkime.h” extern ArkimeConfig_t config; #define ARKIME_API_VERSION 542#define ARKIME_SESSIONID_LEN 40 &#x2F;&#x2F; Modbus 功能码定义#define MODBUS_READ_COILS 0x01#define MODBUS_READ_DISCRETE_INPUTS 0x02#define MODBUS_READ_HOLDING_REGISTERS 0x03#define MODBUS_READ_INPUT_REGISTERS 0x04#define MODBUS_WRITE_SINGLE_COIL 0x05#define MODBUS_WRITE_SINGLE_REGISTER 0x06#define MODBUS_WRITE_MULTIPLE_COILS 0x0F#define MODBUS_WRITE_MULTIPLE_REGISTERS 0x10 &#x2F;&#x2F; Modbus 异常码定义#define MODBUS_EXC_ILLEGAL_FUNCTION 0x01#define MODBUS_EXC_ILLEGAL_DATA_ADDRESS 0x02#define MODBUS_EXC_ILLEGAL_DATA_VALUE 0x03#define MODBUS_EXC_SLAVE_DEVICE_FAILURE 0x04#define MODBUS_EXC_ACKNOWLEDGE 0x05#define MODBUS_EXC_SLAVE_DEVICE_BUSY 0x06#define MODBUS_EXC_NEGATIVE_ACKNOWLEDGE 0x07#define MODBUS_EXC_MEMORY_PARITY_ERROR 0x08 &#x2F;&#x2F; 定义 Modbus 数据结构typedef struct {uint16_t transactionId;uint16_t protocolId;uint16_t length;uint8_t unitId;uint8_t functionCode;uint16_t address; &#x2F;&#x2F; 数据地址uint16_t quantity; &#x2F;&#x2F; 读取或者写入的数量uint16_t value; &#x2F;&#x2F; 单个寄存器或线圈的值uint8_t *data; &#x2F;&#x2F; 写入或读取的数据uint16_t dataLength; &#x2F;&#x2F; 数据长度uint8_t exceptionCode; &#x2F;&#x2F; 异常码char *description; &#x2F;&#x2F; 描述信息} ModbusData; &#x2F;&#x2F; 全局变量，存储字段位置static int modbus_transaction_id_field;static int modbus_function_code_field;static int modbus_description_field;static int modbus_unit_id_field;static int modbus_address_field;static int modbus_quantity_field;static int modbus_data_field;static int modbus_src_port_field;static int modbus_dest_port_field;static int modbus_exc_code_field; &#x2F;&#x2F; 函数声明 (保持不变)void modbus_free_data(ModbusData *data);void modbus_process_tcp_payload(ArkimeSession_t *session, const uint8_t *payload, int len);int modbus_parse_pdu(const uint8_t *payload, int len, ModbusData *modbusData, ArkimeSession_t *session); &#x2F;&#x2F; 自定义错误打印函数，带时间戳void modbus_log(const char *format, …) {va_list args;va_start(args, format); 123456789101112131415 time_t timer;char buffer[26];struct tm tm_info; // 声明 struct tm 变量time(&amp;timer);localtime_r(&amp;timer, &amp;tm_info); // 使用 localtime_r 函数strftime(buffer, 26, &quot;%Y-%m-%d %H:%M:%S&quot;, &amp;tm_info); // 传递指针fprintf(stderr, &quot;%s [modbus_plugin] &quot;, buffer);vfprintf(stderr, format, args);fprintf(stderr, &quot; &quot;);va_end(args);fflush(stderr); IGNORE_WHEN_COPYING_START content_copy download Use code with caution. IGNORE_WHEN_COPYING_END } &#x2F;******************************************************************************&#x2F;&#x2F;&#x2F; 插件初始化函数void arkime_plugin_init() {modbus_log(“arkime_plugin_init() called”); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 // 注册插件int rc = arkime_plugins_register_internal(&quot;modbus&quot;, TRUE, sizeof(ArkimeSession_t), ARKIME_API_VERSION);if (rc == -1) &#123; fprintf(stderr, &quot;ERROR: Couldn&#x27;t register plugin &quot;); exit(1);&#125;// 定义 Arkime 字段modbus_transaction_id_field = arkime_field_define(&quot;modbus&quot;, &quot;integer&quot;, &quot;modbus.transactionId&quot;, &quot;Modbus Transaction ID&quot;, &quot;modbus.transactionId&quot;, &quot;Modbus Transaction ID&quot;, ARKIME_FIELD_TYPE_INT_HASH, 0, NULL);modbus_function_code_field = arkime_field_define(&quot;modbus&quot;, &quot;integer&quot;, &quot;modbus.functionCode&quot;, &quot;Modbus Function Code&quot;, &quot;modbus.functionCode&quot;, &quot;Modbus Function Code&quot;, ARKIME_FIELD_TYPE_INT_HASH, 0, NULL);modbus_description_field = arkime_field_define(&quot;modbus&quot;, &quot;string&quot;, &quot;modbus.description&quot;, &quot;Modbus Description&quot;, &quot;modbus.description&quot;, &quot;Modbus Description&quot;, ARKIME_FIELD_TYPE_STR_HASH, 0, NULL);modbus_unit_id_field = arkime_field_define(&quot;modbus&quot;, &quot;integer&quot;, &quot;modbus.unitId&quot;, &quot;Modbus Unit ID&quot;, &quot;modbus.unitId&quot;, &quot;Modbus Unit ID&quot;, ARKIME_FIELD_TYPE_INT_HASH, 0, NULL);modbus_address_field = arkime_field_define(&quot;modbus&quot;, &quot;integer&quot;, &quot;modbus.address&quot;, &quot;Modbus Address&quot;, &quot;modbus.address&quot;, &quot;Modbus Address&quot;, ARKIME_FIELD_TYPE_INT_HASH, 0, NULL);modbus_quantity_field = arkime_field_define(&quot;modbus&quot;, &quot;integer&quot;, &quot;modbus.quantity&quot;, &quot;Modbus Quantity&quot;, &quot;modbus.quantity&quot;, &quot;Modbus Quantity&quot;, ARKIME_FIELD_TYPE_INT_HASH, 0, NULL);modbus_data_field = arkime_field_define(&quot;modbus&quot;, &quot;string&quot;, &quot;modbus.data&quot;, &quot;Modbus Data&quot;, &quot;modbus.data&quot;, &quot;Modbus Data&quot;, ARKIME_FIELD_TYPE_STR_HASH, 0, NULL);modbus_src_port_field = arkime_field_define(&quot;modbus&quot;, &quot;integer&quot;, &quot;modbus.srcPort&quot;, &quot;Modbus Source Port&quot;, &quot;modbus.srcPort&quot;, &quot;Modbus Source Port&quot;, ARKIME_FIELD_TYPE_INT_HASH, 0, NULL);modbus_dest_port_field = arkime_field_define(&quot;modbus&quot;, &quot;integer&quot;, &quot;modbus.destPort&quot;, &quot;Modbus Destination Port&quot;, &quot;modbus.destPort&quot;, &quot;Modbus Destination Port&quot;, ARKIME_FIELD_TYPE_INT_HASH, 0, NULL);modbus_exc_code_field = arkime_field_define(&quot;modbus&quot;, &quot;integer&quot;, &quot;modbus.exceptionCode&quot;, &quot;Modbus Exception Code&quot;, &quot;modbus.exceptionCode&quot;, &quot;Modbus Exception Code&quot;, ARKIME_FIELD_TYPE_INT_HASH, 0, NULL);// 注册 TCP 端口 502 的流量处理回调函数arkime_parsers_classifier_register_port(&quot;modbus&quot;, NULL, 502, ARKIME_PARSERS_PORT_TCP, (ArkimeClassifyFunc)modbus_process_tcp_payload);modbus_log(&quot;modbus plugin initialized!&quot;); IGNORE_WHEN_COPYING_START content_copy download Use code with caution. IGNORE_WHEN_COPYING_END } &#x2F;******************************************************************************&#x2F;&#x2F;&#x2F; 判断是否是 Modbus 数据 (更严格的检查) (保持不变)int modbus_is_modbus(const uint8_t *payload, int len) {if (len &lt; 7) {modbus_log(“modbus_is_modbus: len &lt; 7, returning FALSE”);return FALSE;} 1234567891011121314151617 // 检查协议标识符, Modbus TCP 固定为 0uint16_t protocolId = ntohs(*(uint16_t*)(payload + 2));if (protocolId != 0) &#123; modbus_log(&quot;modbus_is_modbus: protocolId != 0, returning FALSE&quot;); return FALSE;&#125;// 检查长度字段，确保其值与实际长度匹配 (减去前 6 个字节)uint16_t expectedLength = ntohs(*(uint16_t*)(payload + 4));if (expectedLength != len - 6) &#123; modbus_log(&quot;modbus_is_modbus: expectedLength != len - 6, returning FALSE&quot;); return FALSE;&#125;modbus_log(&quot;modbus_is_modbus: is Modbus TCP&quot;);return TRUE; IGNORE_WHEN_COPYING_START content_copy download Use code with caution. IGNORE_WHEN_COPYING_END } &#x2F;******************************************************************************&#x2F;&#x2F;&#x2F; 处理 TCP 数据包void modbus_process_tcp_payload(ArkimeSession_t *session, const uint8_t *payload, int len) {char sessionString[ARKIME_SESSIONID_LEN];arkime_session_id_string(session-&gt;sessionId, sessionString);modbus_log(“modbus_process_tcp_payload called, len &#x3D; %d, session id &#x3D; %s”, len, sessionString); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677 if (len &lt;= 0) &#123; modbus_log(&quot;modbus_process_tcp_payload: len &lt;= 0, returning&quot;); return;&#125;// 判断是否是 Modbus 数据if (!modbus_is_modbus(payload, len)) &#123; modbus_log(&quot;modbus_process_tcp_payload: not Modbus traffic, returning&quot;); return;&#125;ModbusData *modbusData = ARKIME_TYPE_ALLOC0(ModbusData); // 使用 Arkime 的内存分配函数if (!modbusData) &#123; modbus_log(&quot;ERROR - 内存分配失败&quot;); return;&#125;modbus_log(&quot;modbus_process_tcp_payload: Modbus data detected, parsing PDU&quot;);// 解析 Modbus PDUif (modbus_parse_pdu(payload, len, modbusData, session) == 0) &#123; // 传递 session 指针 modbus_log(&quot;modbus_process_tcp_payload: modbus_parse_pdu success, adding fields&quot;); // 添加 Modbus 数据到 Arkime 字段 arkime_field_int_add(modbus_transaction_id_field, session, modbusData-&gt;transactionId); modbus_log(&quot;modbus_process_tcp_payload: added transactionId = %u&quot;, modbusData-&gt;transactionId); arkime_field_int_add(modbus_function_code_field, session, modbusData-&gt;functionCode); modbus_log(&quot;modbus_process_tcp_payload: added functionCode = %u&quot;, modbusData-&gt;functionCode); arkime_field_int_add(modbus_unit_id_field, session, modbusData-&gt;unitId); modbus_log(&quot;modbus_process_tcp_payload: added unitId = %u&quot;, modbusData-&gt;unitId); arkime_field_int_add(modbus_src_port_field, session, session-&gt;port1); modbus_log(&quot;modbus_process_tcp_payload: added srcPort = %u&quot;, session-&gt;port1); arkime_field_int_add(modbus_dest_port_field, session, session-&gt;port2); modbus_log(&quot;modbus_process_tcp_payload: added destPort = %u&quot;, session-&gt;port2); if (modbusData-&gt;exceptionCode != 0)&#123; arkime_field_int_add(modbus_exc_code_field, session, modbusData-&gt;exceptionCode); modbus_log(&quot;modbus_process_tcp_payload: added exceptionCode = %u&quot;, modbusData-&gt;exceptionCode); &#125; if (modbusData-&gt;address != 0xFFFF)&#123; arkime_field_int_add(modbus_address_field, session, modbusData-&gt;address); modbus_log(&quot;modbus_process_tcp_payload: added address = %u&quot;, modbusData-&gt;address); &#125; if (modbusData-&gt;quantity != 0xFFFF)&#123; arkime_field_int_add(modbus_quantity_field, session, modbusData-&gt;quantity); modbus_log(&quot;modbus_process_tcp_payload: added quantity = %u&quot;, modbusData-&gt;quantity); &#125; // 避免 NULL 指针解引用 if (modbusData-&gt;description != NULL) &#123; arkime_field_string_add(modbus_description_field, session, modbusData-&gt;description, -1, TRUE); modbus_log(&quot;modbus_process_tcp_payload: added description = %s&quot;,modbusData-&gt;description); &#125; else &#123; modbus_log(&quot;modbus_process_tcp_payload: description is NULL&quot;); &#125; if (modbusData-&gt;dataLength &gt; 0 &amp;&amp; modbusData-&gt;data != NULL) &#123; char hex_string[1024]; arkime_sprint_hex_string(hex_string, modbusData-&gt;data, modbusData-&gt;dataLength); arkime_field_string_add(modbus_data_field, session, hex_string, -1, TRUE); modbus_log(&quot;modbus_process_tcp_payload: added data: %s&quot;, hex_string); // 打印实际数据 ARKIME_SIZE_FREE(modbus_data, modbusData-&gt;data); modbusData-&gt;data = NULL; modbusData-&gt;dataLength=0; &#125; modbus_free_data(modbusData);&#125; else &#123; modbus_log(&quot;modbus_process_tcp_payload: modbus_parse_pdu failed&quot;); modbus_free_data(modbusData);&#125; IGNORE_WHEN_COPYING_START content_copy download Use code with caution. IGNORE_WHEN_COPYING_END } &#x2F;******************************************************************************&#x2F;&#x2F;&#x2F; 解析 Modbus PDU (保持不变)int modbus_parse_pdu(const uint8_t *payload, int len, ModbusData *modbusData, ArkimeSession_t *session) {modbus_log(“modbus_parse_pdu called, len &#x3D; %d,functionCode&#x3D;%d”, len,payload[7]);if (len &lt; 8) {modbus_log(“modbus_parse_pdu: len &lt; 8, returning -1”);return -1; &#x2F;&#x2F; 至少需要 8 个字节} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179 modbusData-&gt;transactionId = ntohs(*(uint16_t*)(payload + 0));modbus_log(&quot;modbus_parse_pdu: transactionId = %u&quot;,modbusData-&gt;transactionId);modbusData-&gt;protocolId = ntohs(*(uint16_t*)(payload + 2));modbus_log(&quot;modbus_parse_pdu: protocolId = %u&quot;,modbusData-&gt;protocolId);modbusData-&gt;length = ntohs(*(uint16_t*)(payload + 4));modbus_log(&quot;modbus_parse_pdu: length = %u&quot;,modbusData-&gt;length);modbusData-&gt;unitId = payload[6];modbus_log(&quot;modbus_parse_pdu: unitId = %u&quot;,modbusData-&gt;unitId);modbusData-&gt;functionCode = payload[7];modbus_log(&quot;modbus_parse_pdu: functionCode = %u&quot;,modbusData-&gt;functionCode);const uint8_t *pdu = payload + 8;int pdu_len = len - 8;modbusData-&gt;description = &quot;Unknown&quot;; // 设置默认值//设置默认值，避免显示异常modbusData-&gt;address = 0xFFFF;modbusData-&gt;quantity = 0xFFFF;modbusData-&gt;exceptionCode = 0x00;switch (modbusData-&gt;functionCode) &#123; case MODBUS_READ_COILS: // 0x01 case MODBUS_READ_DISCRETE_INPUTS: // 0x02 case MODBUS_READ_HOLDING_REGISTERS: // 0x03 case MODBUS_READ_INPUT_REGISTERS: // 0x04 &#123; if (pdu_len &lt; 4) &#123; modbus_log(&quot;modbus_parse_pdu: read function, pdu_len &lt; 4, returning -1&quot;); return -1; &#125; modbusData-&gt;address = ntohs(*(uint16_t*)(pdu + 0)); modbus_log(&quot;modbus_parse_pdu: address = %u&quot;, modbusData-&gt;address); modbusData-&gt;quantity = ntohs(*(uint16_t*)(pdu + 2)); modbus_log(&quot;modbus_parse_pdu: quantity = %u&quot;,modbusData-&gt;quantity); switch (modbusData-&gt;functionCode) &#123; case MODBUS_READ_COILS: modbusData-&gt;description = &quot;Read Coils&quot;; modbus_log(&quot;modbus_parse_pdu: description = Read Coils&quot;); break; case MODBUS_READ_DISCRETE_INPUTS: modbusData-&gt;description = &quot;Read Discrete Inputs&quot;; modbus_log(&quot;modbus_parse_pdu: description = Read Discrete Inputs&quot;); break; case MODBUS_READ_HOLDING_REGISTERS: modbusData-&gt;description = &quot;Read Holding Registers&quot;; modbus_log(&quot;modbus_parse_pdu: description = Read Holding Registers&quot;); break; case MODBUS_READ_INPUT_REGISTERS: modbusData-&gt;description = &quot;Read Input Registers&quot;; modbus_log(&quot;modbus_parse_pdu: description = Read Input Registers&quot;); break; &#125; break; &#125; case MODBUS_WRITE_SINGLE_COIL: // 0x05 case MODBUS_WRITE_SINGLE_REGISTER: // 0x06 &#123; if (pdu_len &lt; 4) &#123; modbus_log(&quot;modbus_parse_pdu: write single function, pdu_len &lt; 4, returning -1&quot;); return -1; &#125; modbusData-&gt;address = ntohs(*(uint16_t*)(pdu + 0)); modbus_log(&quot;modbus_parse_pdu: address = %u&quot;, modbusData-&gt;address); modbusData-&gt;value = ntohs(*(uint16_t*)(pdu + 2)); modbus_log(&quot;modbus_parse_pdu: value = %u&quot;,modbusData-&gt;value); switch (modbusData-&gt;functionCode) &#123; case MODBUS_WRITE_SINGLE_COIL: modbusData-&gt;description = &quot;Write Single Coil&quot;; modbus_log(&quot;modbus_parse_pdu: description = Write Single Coil&quot;); break; case MODBUS_WRITE_SINGLE_REGISTER: modbusData-&gt;description = &quot;Write Single Register&quot;; modbus_log(&quot;modbus_parse_pdu: description = Write Single Register&quot;); break; &#125; break; &#125; case MODBUS_WRITE_MULTIPLE_COILS: // 0x0F case MODBUS_WRITE_MULTIPLE_REGISTERS: // 0x10 &#123; if (pdu_len &lt; 5) &#123; modbus_log(&quot;modbus_parse_pdu: write multiple function, pdu_len &lt; 5, returning -1&quot;); return -1; &#125; modbusData-&gt;address = ntohs(*(uint16_t*)(pdu + 0)); modbus_log(&quot;modbus_parse_pdu: address = %u&quot;,modbusData-&gt;address); modbusData-&gt;quantity = ntohs(*(uint16_t*)(pdu + 2)); modbus_log(&quot;modbus_parse_pdu: quantity = %u&quot;,modbusData-&gt;quantity); modbusData-&gt;dataLength = pdu[4]; modbus_log(&quot;modbus_parse_pdu: dataLength = %u&quot;,modbusData-&gt;dataLength); if (pdu_len &lt; 5 + modbusData-&gt;dataLength) &#123; modbus_log(&quot;modbus_parse_pdu: write multiple function, pdu_len &lt; 5 + dataLength, returning -1&quot;); return -1; &#125; modbusData-&gt;data = ARKIME_SIZE_ALLOC0(modbus_data, modbusData-&gt;dataLength); // 使用 Arkime 的内存分配函数 if (!modbusData-&gt;data) &#123; modbus_log(&quot;ERROR - 内存分配失败&quot;); return -1; &#125; memcpy(modbusData-&gt;data, pdu + 5, modbusData-&gt;dataLength); switch (modbusData-&gt;functionCode) &#123; case MODBUS_WRITE_MULTIPLE_COILS: modbusData-&gt;description = &quot;Write Multiple Coils&quot;; modbus_log(&quot;modbus_parse_pdu: description = Write Multiple Coils&quot;); break; case MODBUS_WRITE_MULTIPLE_REGISTERS: modbusData-&gt;description = &quot;Write Multiple Registers&quot;; modbus_log(&quot;modbus_parse_pdu: description = Write Multiple Registers&quot;); break; &#125; break; &#125; case 0x80 ... 0xFF: // Exception Response &#123; if (pdu_len &lt; 1) &#123; modbus_log(&quot;modbus_parse_pdu: exception response, pdu_len &lt; 1, returning -1&quot;); return -1; &#125; modbusData-&gt;exceptionCode = pdu[0]; modbus_log(&quot;modbus_parse_pdu: exceptionCode = %u&quot;,modbusData-&gt;exceptionCode); switch (modbusData-&gt;exceptionCode) &#123; case MODBUS_EXC_ILLEGAL_FUNCTION: modbusData-&gt;description = &quot;Exception: Illegal Function&quot;; modbus_log(&quot;modbus_parse_pdu: description = Exception: Illegal Function&quot;); break; case MODBUS_EXC_ILLEGAL_DATA_ADDRESS: modbusData-&gt;description = &quot;Exception: Illegal Data Address&quot;; modbus_log(&quot;modbus_parse_pdu: description = Exception: Illegal Data Address&quot;); break; case MODBUS_EXC_ILLEGAL_DATA_VALUE: modbusData-&gt;description = &quot;Exception: Illegal Data Value&quot;; modbus_log(&quot;modbus_parse_pdu: description = Exception: Illegal Data Value&quot;); break; case MODBUS_EXC_SLAVE_DEVICE_FAILURE: modbusData-&gt;description = &quot;Exception: Slave Device Failure&quot;; modbus_log(&quot;modbus_parse_pdu: description = Exception: Slave Device Failure&quot;); break; case MODBUS_EXC_ACKNOWLEDGE: modbusData-&gt;description = &quot;Exception: Acknowledge&quot;; modbus_log(&quot;modbus_parse_pdu: description = Exception: Acknowledge&quot;); break; case MODBUS_EXC_SLAVE_DEVICE_BUSY: modbusData-&gt;description = &quot;Exception: Slave Device Busy&quot;; modbus_log(&quot;modbus_parse_pdu: description = Exception: Slave Device Busy&quot;); break; case MODBUS_EXC_NEGATIVE_ACKNOWLEDGE: modbusData-&gt;description = &quot;Exception: Negative Acknowledge&quot;; modbus_log(&quot;modbus_parse_pdu: description = Exception: Negative Acknowledge&quot;); break; case MODBUS_EXC_MEMORY_PARITY_ERROR: modbusData-&gt;description = &quot;Exception: Memory Parity Error&quot;; modbus_log(&quot;modbus_parse_pdu: description = Exception: Memory Parity Error&quot;); break; default: modbusData-&gt;description = &quot;Exception: Unknown Error&quot;; modbus_log(&quot;modbus_parse_pdu: description = Exception: Unknown Error&quot;); break; &#125; break; &#125; default: modbus_log(&quot;modbus_parse_pdu: unknown function code, returning -1&quot;); return -1;&#125;return 0; IGNORE_WHEN_COPYING_START content_copy download Use code with caution. IGNORE_WHEN_COPYING_END } &#x2F;******************************************************************************&#x2F;&#x2F;&#x2F; 释放 ModbusData 结构体内存 (保持不变)void modbus_free_data(ModbusData *data) {if (data) {if (data-&gt;data) {ARKIME_SIZE_FREE(modbus_data, data-&gt;data); &#x2F;&#x2F; 使用 Arkime 的内存释放函数}ARKIME_TYPE_FREE(ModbusData, data); &#x2F;&#x2F; 使用 Arkime 的内存释放函数}} &#x2F;******************************************************************************&#x2F;&#x2F;&#x2F; 供 Arkime 加载插件的函数#ifndef UNIT_TESTvoid arkime_plugin_load() { 123 modbus_log(&quot;arkime_plugin_load() called&quot;);arkime_plugin_init(); IGNORE_WHEN_COPYING_START content_copy download Use code with caution. IGNORE_WHEN_COPYING_END }#endif 输出结果：2025-03-13 15:26:34 [modbus_plugin] modbus_is_modbus: is Modbus TCP2025-03-13 15:26:34 [modbus_plugin] modbus_process_tcp_payload: Modbus data detected, parsing PDU2025-03-13 15:26:34 [modbus_plugin] modbus_parse_pdu called, len &#x3D; 12,functionCode&#x3D;32025-03-13 15:26:34 [modbus_plugin] modbus_parse_pdu: transactionId &#x3D; 12025-03-13 15:26:34 [modbus_plugin] modbus_parse_pdu: protocolId &#x3D; 02025-03-13 15:26:34 [modbus_plugin] modbus_parse_pdu: length &#x3D; 62025-03-13 15:26:34 [modbus_plugin] modbus_parse_pdu: unitId &#x3D; 12025-03-13 15:26:34 [modbus_plugin] modbus_parse_pdu: functionCode &#x3D; 32025-03-13 15:26:34 [modbus_plugin] modbus_parse_pdu: address &#x3D; 02025-03-13 15:26:34 [modbus_plugin] modbus_parse_pdu: quantity &#x3D; 22025-03-13 15:26:34 [modbus_plugin] modbus_parse_pdu: description &#x3D; Read Holding Registers2025-03-13 15:26:34 [modbus_plugin] modbus_process_tcp_payload: modbus_parse_pdu success, adding fields2025-03-13 15:26:34 [modbus_plugin] modbus_process_tcp_payload: added transactionId &#x3D; 12025-03-13 15:26:34 [modbus_plugin] modbus_process_tcp_payload: added functionCode &#x3D; 32025-03-13 15:26:34 [modbus_plugin] modbus_process_tcp_payload: added unitId &#x3D; 12025-03-13 15:26:34 [modbus_plugin] modbus_process_tcp_payload: added srcPort &#x3D; 543212025-03-13 15:26:34 [modbus_plugin] modbus_process_tcp_payload: added destPort &#x3D; 5022025-03-13 15:26:34 [modbus_plugin] modbus_process_tcp_payload: added address &#x3D; 02025-03-13 15:26:34 [modbus_plugin] modbus_process_tcp_payload: added quantity &#x3D; 22025-03-13 15:26:34 [modbus_plugin] modbus_process_tcp_payload: added description &#x3D; Read Holding Registers sudo tcpdump -i ens33 -w ethernetip_test.pcap port 44818 sudo &#x2F;opt&#x2F;arkime&#x2F;bin&#x2F;capture -c &#x2F;opt&#x2F;arkime&#x2F;etc&#x2F;config.ini -r ethernetip_test.pcap"},{"title":"英语写作和翻译","path":"/2024/12/08/英语写作和翻译/","content":"写作翻译的保底原则： 1.用该单词的上位词来代替该单词； 2.用我们会的单词把这个单词的意思解释出 3.区分大小词 写作翻译高分原则 一、被动 二、非谓语动词 三、并列句 1. 表示原因 because，as ,since, in that because of&#x3D;be responsible for&#x3D;due to&#x3D;owing to&#x3D;thanks to 2. 表示结果 so&#x3D;hence&#x3D;therefore&#x3D;thereby&#x3D;thus&#x3D;consequently&#x3D;in consequence&#x3D;as a result∕consequence 3. 表示并列 and likewise &#x3D;similarly &#x3D; equally&#x3D; simultaneously &#x3D;at the same time&#x3D; in the meanwhile 4. 表示转折 but, by contrast &#x3D; conversely &#x3D; alternatively &#x3D; on the contrary &#x3D; on the other hand &#x3D; otherwise &#x3D; while &#x3D; whereas 5. 表示递进 besides &#x3D; also &#x3D; in addition &#x3D; moreover &#x3D; furthermore &#x3D; apart ∕ aside from this to put it another way &#x3D; in other words 6. 表示引出新对象 ① About &#x3D; concerning &#x3D; regarding &#x3D; with regard to &#x3D; as for ∕ to &#x3D; in respect of 关于 ② in terms of 就……而论，在……方面 ③ when it comes to … 当提到……时 **7.**表示总结 ① On the whole &#x3D; all in all &#x3D;overall &#x3D; in conclusion ∕ summary ∕ general &#x3D; generally （speaking） &#x3D; as a whole &#x3D;mainly &#x3D; substantially &#x3D; to sum up &#x3D; conclude &#x3D; come to the conclusion 总的来说 ② in short ∕ brief &#x3D; in a word 简而言之 ③ in any case &#x3D; at any rate &#x3D; anyway 总之，无论如何 四、复合句 1. 主语从句 学习的动机比学习本身更重要是显而易见的。 It is beyond dispute that the motivation of learning is more important than learning itself. 主语从句 （1） It is … that ① It is common knowledge that… …… ② It is my belief that… ③ It is self-evident that… …… ④ It has been found that… ⑤ It is beyond dispute that… …… ⑥ It is universally acknowledged that… ⑦ It has been widely accepted that… ⑧ It is generally agreed that… 2. 定语和定语从句 I love this kind girl. I love the girl of kindness. I love the girl as kind as an angel. I love the girl being as kind as an angel. I love the girl who keeps so kind. 我是一个美女，喜欢读书和运动。 I am a beauty, and enjoy reading and doing sports. I am a beauty, enjoying reading and doing sports. I am a beauty , who enjoys reading and doing sports. 3. 状语和状语从句 I am listening to the teacher Keeping pets can cultivate the kindness of children although they sometimes bring much trouble for their owners. or because taking care of those little animals needs patience and care. or when there exists only a child in one family. or by taking a shower or talking with those little animals 4. 两大经典句型： （1) 强调句型 It is…that… 很多的因素可以解释我的观点。 Quite a few grounds could account for my argument. 就是基础知识培养了我们解决问题的能力。 It is the basic knowledge that develops our ability to solve problems. 良好的心态能让我们在这个竞争的社会中更平和地生活。 A good attitude can help us live a more peaceful life in this competitive society. （2）倒装 ① 否定词位于句首时 我从来没有这样开心过 i have never been so happy. Never have I been so happy. 在任何情况下我们绝不能忽略…的重要性&#x2F;严重性； we can ignore the gravity&#x2F; severity of sth Under no circumstances. Under no circumstances can we ignore the gravity&#x2F; severity of sth ② 含有 so…that…结构的句子，将 so 引导的部分位于句首时 这个问题是如此重要以至于我们要给与足够的重视。 The issue is so grave&#x2F;severe that we have to pour attention into it. So grave&#x2F;severe is the issue that we have to pour attention into it. ③ only 引出的状语位于句首时 只有以这种方式，我们才能解决这个问题。 Only in this way can we relieve the current situation. 只有拼劲努力，我们才知道自己是不是一匹黑马。 Only by working hard can we know whether we are dark horses. **5.**句子的改写和扩写 ① 我绝不嫁给你。 I will never marry you. (初二水平） You are the man who I will never marry.（定语从句） Never will I marry you.（倒装） It is beyond dipute that I will never marry you. It is you that I will never marry. If I marry you，the sun will rise in the west . ② 读书很重要 Reading books is important. Reading books is believed to be essential. It is widely accepted that reading books is vital. It is with the rapid development of Chinese economy that reading books Is significant. So important is reading books that more time should be spared to appreciate masterpieces. 句子扩写： I love Dayan. Since i saw her for the first time, I have loved dayan who is the most graceful and elegant English teacher 第一段：引出主题的句子： ① Recently the issue &#x2F;problem of…has been in the limelight （处于关注的中心）&#x2F; brought into focus&#x2F; brought to public attentive concern ② Recently, with the development &#x2F;advance&#x2F;progress of science and technology, the phenomenon of … has aroused wide concern. ③Nowadays, it is undeniable that……has almost become the biggest concern of the present-day world. ④What is your idea as to …? There exist a variety of points concerning it. ⑤with respect to&#x2F; with regard to&#x2F; when it comes to&#x2F;…..People’s arguments vary from person to person&#x2F;People may have diverse perspectives on it. ⑥There are different opinions among people as to … 第一段表示个人观点的表达:In my opinion&#x2F;as far as I am concerned&#x2F; for my part&#x2F; from my perspective&#x2F; it keeps my perspective that 第二段分析原因的总起句: ① The majority of people would agree that sth has its deep roots. ② It is superficially a simple phenomenon, but when subjected to analysis, it has its fundamental reasons. ③ There stand at least two reasons, from my perspective, for the present phenomenon . ④ As we know, recognizing a problem is the first step in finding a solution. ⑤ There exist numerous elements being responsible for the issue. ⑥ The reason for this is not far to seek. 第三段总结措施段: 第一句：表示总结的逻辑关系词+ 总结句 第三段首句一定是表示总结性的词: ①On the whole &#x3D; all in all &#x3D;overall &#x3D; in conclusion ∕ summary ∕ general &#x3D; generally （speaking） &#x3D; as a whole &#x3D;mainly &#x3D; substantially &#x3D; to sum up &#x3D; conclude &#x3D; come to the conclusion 总的来说 ② in short ∕ brief &#x3D; in a word 简而言之 把文章中心再说一遍； 推荐： 1.under no circumstances can we ignore the importance&#x2F;severity of sth. what could be done to promote sth&#x2F; to ban sth? so crucial &#x2F;grave is sth that enough attention should have paid to the issue recently. 第二三句话 措施 我们**&#x2F;政府&#x2F;家长&#x2F;**学校 举例：Students, from their early age, could be educated to cultivate the awareness that ….. it is high time for the young to do sth. it is urgent that colleges&#x2F;parents&#x2F;we should do sth. college students cannot fail to do sth. 最后一句：结尾句 ①Only by taking certain steps can people make full use of ____ ②So shouldn’t human beings pay much attention to the meaningful saying &#x2F;problem? ③So under no account could people divert attention from sth. ④The more actively people face the problem, the more happily they will lead their life. ⑤It is high time that the subject about ____ became a focus among youngsters. 模板： 1. 表示原因 be responsible fo 2. 表示结果 in consequence 因此 3. 表示并列 and likewise 4. 表示转折 on the contrary 恰恰相反 5. 表示递进 furthermore 此外; 而且; 与此同时; 再者 6. 表示引出新对象 ③ when it comes to … 当提到……时 **7.**表示总结 in conclusion ∕总的来说 写作时 第一段 Nowadays, it is undeniable that……has almost become the biggest concern of the present-day world.如今，不可否认的是，这几乎已经成为当今世界最关心的问题 it keeps my perspective that 这让我的观点 第二段 It is superficially a simple phenomenon, but when subjected to analysis, it has its fundamental reasons. 从表面上看，这是一个简单的现象，但经过分析，它有其根本原因。 第三段 come to the conclusion 总的来说 under no circumstances can we ignore the importance of sth. it is high time for the young to do sth. 结尾段 i hold the firm belief that the more actively people face the problem, the more happily they will lead their life. 4 翻译步骤 ①以意群为单位读句子， 确定句子的时态和语态 ②确定句子的主干，非主干部分用定语或状语来翻译 ③每句话翻译完之后都要看该句话和下句话的逻辑关系，加逻辑关系词"},{"title":"2024年6月英语六级真题(第3套)生词","path":"/2024/11/25/2024年6月英语六级真题(第3套)生词/","content":"第一篇阅读理解individual &#x2F;ˌɪn.dɪˈvɪdʒ.u.əl&#x2F; noun 个人，个体 （思想或行为）与众不同的人，有个性的人 adjective 个体的，个人的 单个的 独特的，特有的 economic &#x2F;iː.kəˈnɒm.ɪkek.əˈnɒm.ɪk&#x2F; adjective 经济的；经济上的 产生经济效益的；有利可图的；能赚钱的 ladder &#x2F;ˈlæd.ər&#x2F; noun 梯子 （职位晋升的）阶梯；（发展的）阶段 （紧身裤袜或长筒袜的）抽丝，滑丝 （某项体育比赛采用的）阶梯晋级赛 verb （紧身衣、袜子）抽丝；被刮破 prosper &#x2F;ˈprɒs.pər&#x2F; verb （人或企业）成功；（尤指经济上）繁荣，昌盛 mobility &#x2F;məʊˈbɪl.ə.timoʊˈbɪl.ə.t̬i&#x2F; noun 活动性；流动性 可在移动设备上提供服务的能力 industrialize &#x2F;ɪnˈdʌs.tri.ə.laɪz&#x2F; verb （使）工业化 unfavourably &#x2F;ʌnˈfeɪvrəblɪ&#x2F; adverb 不适宜地; 不利地; 反对地; 令人不快地 persist &#x2F;pəˈsɪst&#x2F; verb 持续；存留 坚持不懈；执意 dominate &#x2F;ˈdɒm.ɪ.neɪt&#x2F; verb 统治；控制 在…中占首要地位；拥有优势；最明显的 overwhelming &#x2F;ˌəʊ.vəˈwel.mɪŋˌoʊ.vɚ-&#x2F; adjective 难以抵挡的；无法抗拒的 巨大的，极大的 rag &#x2F;ræɡ&#x2F; noun 旧布，破布 破旧衣服 质量低劣的报纸（或杂志）；低俗小报；粗制滥造的杂志 （英国大学生每年组织的）慈善募捐活动 （一首）雷格泰姆乐曲 verb 戏弄；嘲笑；对…搞恶作剧 feature &#x2F;ˈfiː.tʃər&#x2F; noun 特色，特征，特点 （建筑物的）外部特征；地形 面容的一部分；面貌 （报纸或杂志的）特写；（电视或广播的）专题节目 （电影）故事片，正片 verb 以…为特色；给…以显著的地位 broadcast &#x2F;ˈbrɔːd.kɑːst&#x2F; verb 播送（电视或无线电节目）；广播 noun 电视节目；广播节目 adjective 无线电（或电视）广播的 proportion &#x2F;prəˈpɔː.ʃən&#x2F; noun 部分；份额 比率，比例 （某物各个组成部分或一物与另一物之间的）相称，协调，均衡，匀称 尺寸；大小；形状；程度 重要性，严重性 ubiquitous &#x2F;juːˈbɪk.wɪ.təs&#x2F; adjective 普遍存在的，似乎无处不在的 convince &#x2F;kənˈvɪns&#x2F; verb 说服；使相信；使信服 attainable &#x2F;əˈteɪ.nə.bəl&#x2F; adjective 可以达到的；可以获得的 clip &#x2F;klɪp&#x2F; noun 夹子；别针；回形针 （电影或电视节目的）剪辑，片断 快速，迅速 弹夹，弹匣 修剪 一记耳光 verb 剪，修剪 减少；缩小；缩短 （快速地）碰撞；猛击 （用夹子）夹上，别住，固定住 statement &#x2F;ˈsteɪt.mənt&#x2F; noun （正式的）说明；声明；表态 （银行）对账单 adjective （服饰、珠宝等）吸睛的，时尚的 separate &#x2F;ˈsep.ər.ət&#x2F; adjective 各自的；单独的，不同的 verb （使）分离；（使）分开 （使）分开；（使）分散 分开考虑；认为（两者）不相关 （液体）分离 （夫妻）分居 affiliation &#x2F;əˌfɪl.iˈeɪ.ʃən&#x2F; noun 隶属（关系）；从属关系；联系 republican &#x2F;rɪˈpʌb.lɪ.kən&#x2F; noun 拥护共和政体者；共和主义者 adjective 共和国的；共和政体的 noun 美国共和党党员 北爱尔兰共和主义者 democrat &#x2F;ˈdem.ə.kræt&#x2F; noun 民主主义者，民主派 noun （美国）民主党党员；民主党支持者 implicit &#x2F;ɪmˈplɪs.ɪt&#x2F; adjective 不明言的，含蓄的 无疑问的；无保留的 existing &#x2F;ɪɡˈzɪs.tɪŋ&#x2F; adjective 存在的；现存的 conduct &#x2F;kənˈdʌkt&#x2F; verb 组织；实施；进行；处理 （尤指在公共或正式场合中）举止，表现；为人 引导；带领；指引；给…带路 为…导游，带（游客）游览 指挥（合唱团、乐队等） 传导（电或热） noun 行为，举止；表现；为人 组织方式；实施方式 resident &#x2F;ˈrez.ɪ.dənt&#x2F; noun 居民；住户 （美国的）高级专科住院实习医生 adjective 居住的；定居的；居留的 （有特殊技能或品质者）常驻的 extent &#x2F;ɪkˈstent&#x2F; noun 面积，范围；长度；数量 （某事可能发生的）程度 到达…的程度；到…地步 到…程度；到…地步；以至于 在同样的程度上；同样，一样 在某种程度上 到如此地步 在多大程度上? internal &#x2F;ɪnˈtɜː.nəl&#x2F; adjective 体内的；内部的；国内的 external &#x2F;ɪkˈstɜː.nəl&#x2F; adjective 外面的；外表的；来自外部的 indicate &#x2F;ˈɪn.dɪ.keɪt&#x2F; verb 标示；表明；显示；暗示 打转向灯指示（车行方向） 标示，显示 被建议；有必要 frequent &#x2F;ˈfriː.kwənt&#x2F; adjective 频繁发生的；常见的 verb 常去，常到 conclude &#x2F;kənˈkluːd&#x2F; verb （以…）结束（讲话、会议、文章等） 缔结；达成；议定 断定；决定；推断出；作出（结论） perpetuate &#x2F;pəˈpetʃ.u.eɪt&#x2F; verb 使持续；使长存，使永恒 policy &#x2F;ˈpɒl.ə.si&#x2F; noun 政策，方针，策略 保险单 combat &#x2F;ˈkɒm.bæt&#x2F; noun （尤指战争中的）战斗，搏斗 打斗；斗争；格斗 verb 与…战斗；与…作斗争；打击；制止 capture &#x2F;ˈkæp.tʃər&#x2F; verb 俘虏；俘获；（尤指用武力）夺取 赢得；获得，取得 （用文字或图象）表现，描绘，刻画 拍摄，摄制 （计算机等）采集，储存（信息） 唤起（想象）；引起（关注） trivial &#x2F;ˈtrɪv.i.əl&#x2F; adjective 微不足道的，琐碎的；没有价值的 容易解决的，不费吹灰之力的 consequence &#x2F;ˈkɒn.sɪ.kwəns&#x2F; noun （常指不好或不利的）结果，后果 不重要的；无足轻重的；无关紧要的 reinterpret &#x2F;ˌri:ɪn’tɜ:prɪt&#x2F; verb 重新解释；重新诠释 web 重新解读；重释；再解释 essence &#x2F;ˈesəns&#x2F; noun 本质；实质；要素 本质上；实质上 极其重要；必不可少 （通常取自植物或花的）香精，香料，精油 striking &#x2F;ˈstraɪkɪŋ&#x2F; adjective 异乎寻常的，惊人的；引人注目的 妩媚动人的；很有魅力的 contrast &#x2F;ˈkɒntrɑːst&#x2F; noun 差别，差异；对照，对比 verb 对照，对比 形成对照；显出明显的差异 plight &#x2F;plaɪt&#x2F; noun 困境，窘境 verb 答应结婚，订婚；结婚 第二篇阅读理解occupation &#x2F;ˌɒkjəˈpeɪʃən&#x2F; noun 职业；工作 日常活动；消遣 （军队或一伙人）占领，占据 utter &#x2F;ˈʌtər&#x2F; verb 说；讲；出声 adjective 完全的；十足的；极度的 occasion &#x2F;əˈkeɪʒən&#x2F; noun （尤指某事发生的）时刻，时候 特殊场合；重大活动；盛会 时机，机会；原因，理由 有时；偶尔，间或 verb 造成，引起；惹起 client &#x2F;ˈklaɪənt&#x2F; noun 客户；顾客，主顾；委托人 （连接在服务器上的）客户机 provoke &#x2F;prəˈvəʊk&#x2F; verb 激起，引起（尤指负面反应） 激怒，挑衅 religious &#x2F;rɪˈlɪdʒəs&#x2F; adjective 宗教的；宗教上的 笃信宗教的；虔诚的 clinical &#x2F;ˈklɪnɪkəl&#x2F; adjective 门诊的，临床的 冷漠的；无动于衷的；无感情的 无特色的；冷冰冰的；朴素的 crucial &#x2F;ˈkruːʃəl&#x2F; adjective 至关重要的；关键的；决定性的 eliminate &#x2F;iˈlɪmɪneɪt&#x2F; verb 排除；消除；清除 （比赛中）淘汰 消灭；干掉 volatile &#x2F;ˈvɒlətaɪl&#x2F; adjective 不稳定的；易变的；易怒的，喜怒无常的 （液体或固体）易挥发的，易气化的 central &#x2F;ˈsentrəl&#x2F; adjective 中心的，中央的；中部的；靠近中心的；核心的 主要的；重要的 中央的；中心的 noun （苏格兰）中央区（原为九个地方行政区之一，1996年撤销） grounded &#x2F;ˈɡraʊndɪd&#x2F; adjective 明智的，理智的 （船）搁浅的；（飞机）停飞的 （孩子）受罚不许出门的 conscious &#x2F;ˈkɒnʃəs&#x2F; adjective 意识到；察觉到；感觉到 有意识的；神志清醒的；有知觉的 故意的，存心的；刻意的 suffix （用于名词或副词后）有…意识的，看重…的 sector &#x2F;ˈsektər&#x2F; noun （一国经济活动的）部门，领域，行业 （特定国家的）控制区 ultimately &#x2F;ˈʌltɪmətli&#x2F; adverb 最终，最后 终归，终究 render &#x2F;ˈrendər&#x2F; verb 使成为；使变得；使处于某种状态 翻译；把…译成 给予，提供；表达；表演 粉刷；给（墙壁）抹灰（或水泥） complicated &#x2F;ˈkɒmplɪkeɪtɪd&#x2F; adjective 复杂的；麻烦的；费解的 overrule &#x2F;ˌəʊvəˈruːl&#x2F; verb （指有权威的人）否决，驳回，宣布…无效 assertive &#x2F;əˈsɜːtɪv&#x2F; adjective 坚定自信的；果敢的 perception &#x2F;pəˈsepʃənpɚ-&#x2F; noun 认识，观念，看法 感觉，知觉；感知 感知能力；认识能力；洞察力 emerging &#x2F;ɪˈmɜːdʒɪŋ&#x2F; adjective 新兴的，发展初期的 Fans have been cherished by Chinese people since ancient times, Nowadays,they are not just too;s for cooling off from the summer heat but are more often appreciated as artworks.Many fans are elegantly designed,meticulouslycrafted,"},{"title":"数据库十三周作业","path":"/2024/11/18/数据库十三周作业/","content":"12345678910111213141516171819202122232425262728293031-- 在 student 表中添加“密码”列ALTER TABLE studentADD password varbinary(500);GO-- 创建对称密钥用于加密和解密CREATE SYMMETRIC KEY SymKey_TeachingWITH ALGORITHM = AES_256ENCRYPTION BY PASSWORD = &#x27;YourStrongPassword123&#x27;;GO-- 打开对称密钥以进行数据加密OPEN SYMMETRIC KEY SymKey_TeachingDECRYPTION BY PASSWORD = &#x27;YourStrongPassword123&#x27;;GO-- 更新“密码”列数据，假设添加一个示例密码 &#x27;MyPassword&#x27;（加密后存储）UPDATE studentSET password = ENCRYPTBYKEY(KEY_GUID(&#x27;SymKey_Teaching&#x27;), &#x27;MyPassword&#x27;)WHERE sno = &#x27;SAMPLE001&#x27;;GO-- 解密并显示“密码”列数据SELECT sno, sname, CONVERT(varchar, DECRYPTBYKEY(password)) AS decrypted_passwordFROM studentWHERE sno = &#x27;SAMPLE001&#x27;;GO-- 关闭对称密钥CLOSE SYMMETRIC KEY SymKey_Teaching;GO 12345678910111213141516171819202122232425262728293031323334353637383940414243444546-- 在 student 表中添加“密码”列ALTER TABLE studentADD password varbinary(500);GO-- 创建对称密钥用于加密和解密CREATE SYMMETRIC KEY SymKey_TeachingWITH ALGORITHM = AES_256ENCRYPTION BY PASSWORD = &#x27;YourStrongPassword123&#x27;;GO-- 打开对称密钥以进行数据加密OPEN SYMMETRIC KEY SymKey_TeachingDECRYPTION BY PASSWORD = &#x27;YourStrongPassword123&#x27;;GO-- 更新“密码”列数据，假设添加一个示例密码 &#x27;MyPassword&#x27;（加密后存储）UPDATE studentSET password = ENCRYPTBYKEY(KEY_GUID(&#x27;SymKey_Teaching&#x27;), &#x27;MyPassword&#x27;)WHERE sno = &#x27;SAMPLE001&#x27;;GO-- 解密并显示“密码”列数据SELECT sno, sname, CONVERT(varchar, DECRYPTBYKEY(password)) AS decrypted_passwordFROM studentWHERE sno = &#x27;SAMPLE001&#x27;;GO-- 验证用户身份并显示姓名DECLARE @sno_input CHAR(9) = &#x27;SAMPLE001&#x27;;DECLARE @password_input VARCHAR(500) = &#x27;MyPassword&#x27;;-- 打开对称密钥以进行身份验证OPEN SYMMETRIC KEY SymKey_TeachingDECRYPTION BY PASSWORD = &#x27;YourStrongPassword123&#x27;;GOSELECT sno, snameFROM studentWHERE sno = @sno_input AND CONVERT(VARCHAR, DECRYPTBYKEY(password)) = @password_input;GO-- 关闭对称密钥CLOSE SYMMETRIC KEY SymKey_Teaching;GO"},{"title":"数据库b","path":"/2024/11/18/数据库b/","content":"创建视图，查询所有VIP储户的账户信息（账号，身份证号，密码，开户日期，卡类型，币种，余额，有效期)，要求用子查询完成。然后，分析此视图用户会如何使用，并举出用户使用此视图的例子。上交内容包含创建语句，分析文字以及所有举例语句。 创建视图1234567891011121314151617181920sql复制代码-- 创建视图，用于查询所有VIP储户的账户信息CREATE VIEW View_VIPAccounts ASSELECT a.AccNO, a.IDNO, a.Password, a.OpenDate, a.CardType, a.MoneyType, a.Balance, a.ExpiryDateFROM account aWHERE a.IDNO IN ( SELECT d.IDNO FROM depositor d WHERE d.VIP = &#x27;是&#x27; );GO 视图分析此视图 View_VIPAccounts 提供了所有VIP储户的详细账户信息。用户可以利用此视图方便地查看VIP客户的账户相关数据，有助于优化VIP客户服务、账户管理和风控审查。 用户使用视图的例子 例子 1：查询所有VIP储户的账户详细信息 12345sql复制代码SELECT * FROM View_VIPAccounts; 用途说明: 银行客户经理或系统管理员可以使用此查询查看所有VIP储户的账户信息，以提供个性化服务或进行账户维护。 例子 2：查询VIP储户的账户余额超过一定金额的信息 123sql复制代码SELECT AccNO, IDNO, BalanceFROM View_VIPAccountsWHERE Balance &gt; 50000; 用途说明: 银行风险管理人员可以使用此查询查找余额较高的VIP账户，以进行资金流动性监控和资产配置分析。 创建视图，查询卡中单笔收入超过10000元的储户的姓名、电话和卡号。然后，分析此视图用户会如何使用，并举出用户使用此视图的例子。上交内容包含创建语句，分析文字以及所有举例语句。 创建视图123456789101112131415sql复制代码-- 创建视图，用于查询单笔收入超过10000元的储户信息CREATE VIEW View_HighIncomeDepositors ASSELECT d.Dname, d.Telephone, a.AccNOFROM depositor dJOIN account a ON d.IDNO = a.IDNOJOIN Trecord t ON a.AccNO = t.AccNOWHERE t.Income &gt; 10000;GO 视图分析此视图 View_HighIncomeDepositors 提供了单笔收入超过 10000 元的储户的姓名、电话和卡号信息。用户可以利用此视图快速查看大额收入相关的储户，便于金融风险评估、潜在高净值客户分析、客户关怀策略制定等。 用户使用视图的例子 例子 1：查询所有高收入储户的信息 12345sql复制代码SELECT * FROM View_HighIncomeDepositors; 用途说明: 银行客户经理可以使用此查询获取最近单笔收入超过 10000 元的客户名单，以便进行后续跟进和服务。 例子 2：统计高收入储户的数量 12sql复制代码SELECT COUNT(*) AS HighIncomeDepositorsCountFROM View_HighIncomeDepositors; 用途说明: 银行数据分析员可以使用此查询统计拥有单笔大额收入的储户数量，以了解该群体的规模和分布情况。 创建函数，查询某储户某个月的支出总额，然后调用此函数。上交内容包含创建语句和调用语句 ChatGPT 说：ChatGPT 创建函数12345678910111213141516171819202122sql复制代码-- 创建用于查询某储户在指定月份的支出总额的函数CREATE FUNCTION GetTotalExpenseForDepositor ( @IDNO CHAR(18), -- 储户身份证号 @Year INT, -- 查询年份 @Month INT -- 查询月份)RETURNS MONEYASBEGIN DECLARE @TotalExpense MONEY; -- 计算指定储户在指定月份的支出总额 SELECT @TotalExpense = SUM(Expense) FROM Trecord WHERE AccNO IN (SELECT AccNO FROM account WHERE IDNO = @IDNO) AND YEAR(TDate) = @Year AND MONTH(TDate) = @Month; -- 返回总支出，如果没有记录则返回 0 RETURN ISNULL(@TotalExpense, 0);END;GO 调用函数12345678sql复制代码-- 调用函数查询身份证号为 &#x27;123456789012345678&#x27; 的储户在 2024 年 5 月的支出总额DECLARE @TotalExpense MONEY;SELECT @TotalExpense = dbo.GetTotalExpenseForDepositor(&#x27;123456789012345678&#x27;, 2024, 5);-- 输出结果PRINT &#x27;The total expense for the depositor in May 2024 is: &#x27; + CAST(@TotalExpense AS NVARCHAR(20));GO 说明 函数 GetTotalExpenseForDepositor 会查询 Trecord 表，结合 account 表，获取指定储户在特定年份和月份的支出总额。 如果没有找到匹配的记录，总支出将返回 0。 调用例子展示了如何使用此函数，并将查询结果打印出来。 按交易表的账号和对方账号升序创建普通索引，然后举两个能利用此索引加快查询速度的例子。上交内容包含创建语句以及两个例子。 创建索引1234sql复制代码-- 在交易记录表 (Trecord) 上创建普通索引，按账号 (AccNO) 和对方账号 (OppAccNO) 列升序排列CREATE INDEX idx_AccNO_OppAccNOON Trecord (AccNO ASC, OppAccNO ASC);GO 使用此索引的查询示例 查询特定账号与指定对方账号的交易记录 12345sql复制代码-- 查询账号为 &#x27;12345678901234567890&#x27; 且对方账号为 &#x27;09876543210987654321&#x27; 的所有交易记录SELECT *FROM TrecordWHERE AccNO = &#x27;12345678901234567890&#x27; AND OppAccNO = &#x27;09876543210987654321&#x27;ORDER BY AccNO ASC, OppAccNO ASC; 此查询利用索引加快了同时按 AccNO 和 OppAccNO 进行筛选和排序的操作。 查询所有交易记录，按账号和对方账号排序 1234sql复制代码-- 查询所有交易记录，并按账号和对方账号升序排列SELECT *FROM TrecordORDER BY AccNO ASC, OppAccNO ASC; 此查询利用索引加快了大数据集上按 AccNO 和 OppAccNO 排序的操作。 说明： 创建的索引 idx_AccNO_OppAccNO 能有效加快涉及 AccNO 和 OppAccNO 列的查询速度，特别是在需要按这些列进行联合过滤和排序时。 示例查询展示了如何利用索引来提高性能。第一个示例展示了查询某个账号和对方账号组合的交易记录，第二个示例展示了全表按这两个字段排序的查询。 建一个修改某学生某门课成绩的存储过程，即将某学生某门课成绩加上一个输入的数值，然后调用此存储过程。上交内容包含创建语句和调用语句 好的，下面是创建一个存储过程来修改某学生某门课程的成绩，并将该成绩增加指定数值的 SQL 语句： 1. 创建存储过程1234567891011121314sql复制代码CREATE PROCEDURE UpdateScore @sno CHAR(9), -- 学号 @cno CHAR(4), -- 课程号 @scoreIncrement INT -- 增加的成绩数值ASBEGIN -- 更新成绩，将成绩增加指定的数值 UPDATE sc SET score = score + @scoreIncrement WHERE sno = @sno AND cno = @cno; -- 可以加入返回信息或者检查数据是否更新成功 PRINT &#x27;成绩更新成功&#x27;;END; 2. 调用存储过程12345sql复制代码EXEC UpdateScore @sno = &#x27;202201010&#x27;, @cno = &#x27;CS101&#x27;, @scoreIncrement = 5; 在这个例子中，UpdateScore 存储过程接受三个参数： @sno：学生的学号。 @cno：课程的课程号。 @scoreIncrement：要增加的成绩数值。 存储过程会将指定学生在指定课程上的成绩增加一个数值。 调用存储过程时，可以传入具体的学号、课程号和成绩增量值，例如将学号为 &#39;202201010&#39; 的学生在课程 &#39;CS101&#39; 上的成绩增加 5 分。"},{"title":"数据库A 2","path":"/2024/11/18/数据库A-2/","content":"– 创建视图，查询所有信用卡账户的储户信息CREATE VIEW CreditCardCustomerInfo ASSELECT D.IDNO, D.Dname, D.Telephone, D.VIPFROM depositor DWHERE D.IDNO IN ( SELECT A.IDNO FROM account A WHERE A.CardType &#x3D; ‘信用卡’);GO 创建视图的 SQL 语句：首先，使用子查询来查询所有信用卡账户的储户信息，包括身份证号、姓名、电话和VIP状态。 12345678910sql复制代码-- 创建视图，查询所有信用卡账户的储户信息CREATE VIEW CreditCardCustomerInfo ASSELECT D.IDNO, D.Dname, D.Telephone, D.VIPFROM depositor DWHERE D.IDNO IN ( SELECT A.IDNO FROM account A WHERE A.CardType = &#x27;信用卡&#x27;);GO 分析：此视图 CreditCardCustomerInfo 会返回所有拥有信用卡账户的储户的基本信息（身份证号、姓名、电话、VIP状态）。通过使用子查询，我们能够筛选出所有信用卡账户的储户信息。主查询从 depositor 表中提取相应的储户信息，并通过子查询从 account 表中获取持有信用卡账户的储户的 IDNO。 用户如何使用此视图：此视图的使用场景主要是银行、信用卡公司或其他金融机构需要快速查看所有持有信用卡账户的储户信息。通过此视图，用户可以直接获取这些储户的基本信息，无需每次都编写复杂的查询。 使用示例： 查询所有信用卡储户的基本信息： 如果银行客服或金融机构工作人员需要查看所有信用卡持卡人的基本信息（例如，身份证号、姓名、电话和VIP状态），可以直接使用此视图。 12sql复制代码-- 查询所有信用卡储户的基本信息SELECT * FROM CreditCardCustomerInfo; 查询某个特定储户的信用卡信息： 如果某个客户服务代表需要查询特定身份证号的储户是否持有信用卡，可以使用此视图来检索该储户的基本信息。 12sql复制代码-- 查询身份证号为 &#x27;123456789012345678&#x27; 的储户信息SELECT * FROM CreditCardCustomerInfo WHERE IDNO = &#x27;123456789012345678&#x27;; 查看所有VIP储户的信用卡账户信息： 如果银行想要根据VIP状态筛选持卡人，可以通过查询视图来获取所有VIP信用卡客户的信息。 12sql复制代码-- 查询所有VIP储户的信用卡账户信息SELECT * FROM CreditCardCustomerInfo WHERE VIP = &#x27;是&#x27;; 3– 创建存储过程来修改某账户的余额 12345678910111213141516171819202122CREATE PROCEDURE UpdateAccountBalance @AccNO CHAR(20), -- 输入的账户号 @Amount MONEY -- 要加上的数值，可以为正数（存入）或负数（取出）ASBEGIN -- 检查账户是否存在 IF EXISTS (SELECT 1 FROM account WHERE AccNO = @AccNO) BEGIN -- 更新账户余额 UPDATE account SET Balance = Balance + @Amount WHERE AccNO = @AccNO; PRINT &#x27;账户余额已成功更新。&#x27;; END ELSE BEGIN PRINT &#x27;错误：账户不存在。&#x27;; ENDEND;GO 调用存储过程的语句：12345sql复制代码-- 调用存储过程，将账户号为 &#x27;12345678901234567890&#x27; 的账户余额增加 500.00EXEC UpdateAccountBalance @AccNO = &#x27;12345678901234567890&#x27;, @Amount = 500.00;-- 调用存储过程，将账户号为 &#x27;12345678901234567890&#x27; 的账户余额减少 200.00EXEC UpdateAccountBalance @AccNO = &#x27;12345678901234567890&#x27;, @Amount = -200.00; 4创建函数，查询某储户某个月每张卡的收入明细，然后调用此函数。上交内容包含创建语句和调用语句。（15分） 1234567891011121314151617181920212223242526-- 创建函数，查询某储户某个月每张卡的收入明细CREATE FUNCTION GetIncomeDetailsForDepositor( @IDNO CHAR(18), -- 输入的储户身份证号 @Year INT, -- 输入的年份 @Month INT -- 输入的月份)RETURNS TABLEASRETURN( SELECT T.AccNO, A.CardType, T.TDate, T.Income, T.Place, T.Abstract FROM Trecord T INNER JOIN account A ON T.AccNO = A.AccNO WHERE A.IDNO = @IDNO AND YEAR(T.TDate) = @Year AND MONTH(T.TDate) = @Month AND T.Income IS NOT NULL)GO 调用函数的语句123sql复制代码-- 调用函数并查询指定储户身份证号为 &#x27;123456789012345678&#x27; 在 2024 年 5 月的每张卡的收入明细SELECT * FROM GetIncomeDetailsForDepositor(&#x27;123456789012345678&#x27;, 2024, 5); 5 1234567891011121314151617181920212223-- 创建触发器，限制在储户表上只能在每年6月20日和12月20日修改VIP的值CREATE TRIGGER trg_LimitVIPUpdateON depositorAFTER UPDATEASBEGIN DECLARE @CurrentDate DATE; SET @CurrentDate = CAST(GETDATE() AS DATE); -- 检查是否更新了VIP列，并验证日期 IF UPDATE(VIP) BEGIN IF @CurrentDate NOT IN (&#x27;2024-06-20&#x27;, &#x27;2024-12-20&#x27;) BEGIN ROLLBACK TRANSACTION; RAISERROR(&#x27;VIP字段只能在每年6月20日和12月20日修改。&#x27;, 16, 1); END ENDEND;GO 创建触发器1234567891011121314151617181920sql复制代码-- 创建触发器，限制在储户表上只能在每年6月20日和12月20日修改VIP的值CREATE TRIGGER trg_LimitVIPUpdateON depositorAFTER UPDATEASBEGIN DECLARE @CurrentDate DATE; SET @CurrentDate = CAST(GETDATE() AS DATE); -- 检查是否更新了VIP列，并验证日期 IF UPDATE(VIP) BEGIN IF @CurrentDate NOT IN (&#x27;2024-06-20&#x27;, &#x27;2024-12-20&#x27;) BEGIN ROLLBACK TRANSACTION; RAISERROR(&#x27;VIP字段只能在每年6月20日和12月20日修改。&#x27;, 16, 1); END ENDEND;GO 触发触发器的示例1234sql复制代码-- 示例：尝试在不允许的日期更新VIP字段以触发触发器UPDATE depositorSET VIP = &#x27;是&#x27;WHERE IDNO = &#x27;123456789012345678&#x27;; -- 假设此身份证号存在于表中 6 1234-- 在交易记录表 (Trecord) 上创建普通索引，按账号 (AccNO) 和交易时间 (TDate) 列升序排列CREATE INDEX idx_AccNO_TDateON Trecord (AccNO ASC, TDate ASC);GO 使用此索引的查询示例 查询特定账号的交易记录，按交易时间升序排列 12345sql复制代码-- 查询账号为 &#x27;12345678901234567890&#x27; 的所有交易记录，按交易时间升序排列SELECT *FROM TrecordWHERE AccNO = &#x27;12345678901234567890&#x27;ORDER BY TDate ASC; 此查询利用索引加快了根据 AccNO 筛选并按 TDate 排序的操作。 查询指定时间范围内的所有交易记录，按账号和交易时间升序排列 12345sql复制代码-- 查询从 &#x27;2024-01-01&#x27; 到 &#x27;2024-12-31&#x27; 之间的所有交易记录，并按账号和交易时间升序排列SELECT *FROM TrecordWHERE TDate BETWEEN &#x27;2024-01-01&#x27; AND &#x27;2024-12-31&#x27;ORDER BY AccNO ASC, TDate ASC;"},{"title":"数据库A","path":"/2024/11/18/数据库A/","content":"*第二次平时测验：**A**卷**（**11**月**18**日，**14**：**00**-**15**：**2**0）* *可以直接提交答案，也可以提交**word**文档，注明**A**卷。* 1、创建视图，查询选修学时为4学时、学分为4分的课程的学号、姓名、所选课程号、课程名和成绩。然后，分析此视图用户会如何使用，并举出用户使用此视图的例子。上交内容包含创建语句，分析文字以及所有举例语句。（20分） 2、 – 创建视图，查询选修学时为4学时、学分为4分的课程的学号、姓名、所选课程号、课程名和成绩 CREATE VIEW v_student_course AS SELECT s.sno, s.sname, sc.cno, c.cname, sc.score FROM student s JOIN sc ON s.sno &#x3D; sc.sno JOIN course c ON sc.cno &#x3D; c.cno WHERE c.classhour &#x3D; 4 AND c.credit &#x3D; 4; – 分析此视图用户会如何使用： – 此视图可以用于快速查找满足特定条件的课程及选课学生的信息。教务人员可以利用该视图统计哪些学生在选修4学时且学分为4的课程时的成绩表现。此外，学生可以查询自己的成绩记录来了解选修这些特定课程的成绩。 – 用户使用此视图的例子： – 1. 查询视图中所有记录 SELECT * FROM v_student_course; – 2. 查询某个特定学生在此类课程中的成绩 SELECT * FROM v_student_course WHERE sno &#x3D; ‘202310001’; – 3. 按照成绩排序查看选修这些课程的学生信息 SELECT * FROM v_student_course ORDER BY score DESC; – 4. 查询平均成绩，用于分析学生整体表现 SELECT AVG(score) AS AverageScore FROM v_student_course; 2、创建视图，查询所有信用卡账户的储户信息（身份证号，姓名，电话，VIP)，要求用子查询完成。然后，分析此视图用户会如何使用，并举出用户使用此视图的例子。上交内容包含创建语句，分析文字以及所有举例语句。（20分） – 创建视图，用子查询查询所有信用卡账户的储户信息 CREATE VIEW CreditCardHolders AS SELECT d.IDNO, d.Dname, d.Telephone, d.VIP FROM depositor d WHERE d.IDNO IN ( ​ SELECT a.IDNO ​ FROM account a ​ WHERE a.CardType &#x3D; ‘信用卡’ ); GO – 分析： – 此视图 “CreditCardHolders” 将用于获取所有持有信用卡账户的储户信息，包括身份证号、姓名、电话和VIP状态。 – 用户可以使用该视图来进行快速查询，简化数据获取和报告生成。例如，银行的客户服务部门可以使用此视图来确认信用卡客户的信息， – 或者市场部门可以筛选出信用卡VIP客户以进行精准的营销活动。 – 使用示例： – 1. 查询所有信用卡储户信息 SELECT * FROM CreditCardHolders; – 2. 筛选VIP客户的信用卡信息 SELECT * FROM CreditCardHolders WHERE VIP &#x3D; ‘是’; – 3. 根据电话号码查找特定客户的信息 SELECT * FROM CreditCardHolders WHERE Telephone &#x3D; ‘13812345678’; 3、创建一个修改某账户余额的存储过程，即将某账户的余额加上一个输入的数值，然后调用此存储过程。上交内容包含创建语句和调用语句。（15分） – 创建修改账户余额的存储过程 CREATE PROCEDURE UpdateAccountBalance @AccNO CHAR(20), @Amount MONEY AS BEGIN – 检查账户是否存在 IF EXISTS (SELECT 1 FROM account WHERE AccNO &#x3D; @AccNO) BEGIN ​ – 更新账户余额 ​ UPDATE account ​ SET Balance &#x3D; Balance + @Amount ​ WHERE AccNO &#x3D; @AccNO; ​ PRINT ‘账户余额已成功更新。’; END ELSE BEGIN ​ PRINT ‘错误：未找到指定的账户。’; END END; GO – 调用存储过程示例 DECLARE @AccountNumber CHAR(20) &#x3D; ‘12345678901234567890’; DECLARE @AmountToAdd MONEY &#x3D; 500.00; EXEC UpdateAccountBalance @AccNO &#x3D; @AccountNumber, @Amount &#x3D; @AmountToAdd; 4、创建函数，查询某储户某个月每张卡的收入明细，然后调用此函数。上交内容包含创建语句和调用语句。（15分） – 创建修改账户余额的存储过程 CREATE PROCEDURE UpdateAccountBalance @AccNO CHAR(20), @Amount MONEY AS BEGIN – 检查账户是否存在 IF EXISTS (SELECT 1 FROM account WHERE AccNO &#x3D; @AccNO) BEGIN ​ – 更新账户余额 ​ UPDATE account ​ SET Balance &#x3D; Balance + @Amount ​ WHERE AccNO &#x3D; @AccNO; ​ PRINT ‘账户余额已成功更新。’; END ELSE BEGIN ​ PRINT ‘错误：未找到指定的账户。’; END END; GO – 调用存储过程示例 DECLARE @AccountNumber CHAR(20) &#x3D; ‘12345678901234567890’; DECLARE @AmountToAdd MONEY &#x3D; 500.00; EXEC UpdateAccountBalance @AccNO &#x3D; @AccountNumber, @Amount &#x3D; @AmountToAdd; – 创建查询某储户某个月每张卡的收入明细的函数 CREATE FUNCTION GetIncomeDetails ( @IDNO CHAR(18), @Month INT, @Year INT ) RETURNS TABLE AS RETURN ( SELECT ​ t.AccNO, ​ t.Income, ​ t.TDate, ​ t.Place, ​ t.Abstract FROM Trecord t JOIN account a ON t.AccNO &#x3D; a.AccNO WHERE a.IDNO &#x3D; @IDNO AND MONTH(t.TDate) &#x3D; @Month AND YEAR(t.TDate) &#x3D; @Year AND t.Income IS NOT NULL ); GO – 调用函数示例 SELECT * FROM GetIncomeDetails(‘123456789012345678’, 5, 2024); 5、在储户表上创建触发器，限定只能在每年6月20日和12月20日修改VIP的值，然后触发此触发器。上交内容包含创建语句和一个触发的例子。（15分） – 创建修改账户余额的存储过程 CREATE PROCEDURE UpdateAccountBalance @AccNO CHAR(20), @Amount MONEY AS BEGIN – 检查账户是否存在 IF EXISTS (SELECT 1 FROM account WHERE AccNO &#x3D; @AccNO) BEGIN ​ – 更新账户余额 ​ UPDATE account ​ SET Balance &#x3D; Balance + @Amount ​ WHERE AccNO &#x3D; @AccNO; ​ PRINT ‘账户余额已成功更新。’; END ELSE BEGIN ​ PRINT ‘错误：未找到指定的账户。’; END END; GO – 调用存储过程示例 DECLARE @AccountNumber CHAR(20) &#x3D; ‘12345678901234567890’; DECLARE @AmountToAdd MONEY &#x3D; 500.00; EXEC UpdateAccountBalance @AccNO &#x3D; @AccountNumber, @Amount &#x3D; @AmountToAdd; – 创建查询某储户某个月每张卡的收入明细的函数 CREATE FUNCTION GetIncomeDetails ( @IDNO CHAR(18), @Month INT, @Year INT ) RETURNS TABLE AS RETURN ( SELECT ​ t.AccNO, ​ t.Income, ​ t.TDate, ​ t.Place, ​ t.Abstract FROM Trecord t JOIN account a ON t.AccNO &#x3D; a.AccNO WHERE a.IDNO &#x3D; @IDNO AND MONTH(t.TDate) &#x3D; @Month AND YEAR(t.TDate) &#x3D; @Year AND t.Income IS NOT NULL ); GO – 调用函数示例 SELECT * FROM GetIncomeDetails(‘123456789012345678’, 5, 2024); – 在储户表上创建触发器，限定只能在每年6月20日和12月20日修改VIP的值 CREATE TRIGGER trg_UpdateVIP ON depositor AFTER UPDATE AS BEGIN DECLARE @CurrentDate DATE &#x3D; CAST(GETDATE() AS DATE); – 检查当前日期是否为6月20日或12月20日 IF @CurrentDate NOT IN (‘2024-06-20’, ‘2024-12-20’) BEGIN ​ RAISERROR (‘只能在每年6月20日和12月20日修改VIP的值。’, 16, 1); ​ ROLLBACK TRANSACTION; END END; GO – 触发触发器的示例 UPDATE depositor SET VIP &#x3D; ‘是’ WHERE IDNO &#x3D; ‘123456789012345678’; 6、按交易表的账号和交易时间列升序创建普通索引，然后举两个能利用此索引加快查询速度的例子。上交内容包含创建语句以及两个例子。（15分） 7、– 创建修改账户余额的存储过程 8、CREATE PROCEDURE UpdateAccountBalance 9、 @AccNO CHAR(20), 10、 @Amount MONEY 11、AS 12、BEGIN 13、 – 检查账户是否存在 14、 IF EXISTS (SELECT 1 FROM account WHERE AccNO &#x3D; @AccNO) 15、 BEGIN 16、 – 更新账户余额 17、 UPDATE account 18、 SET Balance &#x3D; Balance + @Amount 19、 WHERE AccNO &#x3D; @AccNO; 20、 21、 PRINT ‘账户余额已成功更新。’; 22、 END 23、 ELSE 24、 BEGIN 25、 PRINT ‘错误：未找到指定的账户。’; 26、 END 27、END; 28、GO 29、 30、– 调用存储过程示例 31、DECLARE @AccountNumber CHAR(20) &#x3D; ‘12345678901234567890’; 32、DECLARE @AmountToAdd MONEY &#x3D; 500.00; 33、 34、EXEC UpdateAccountBalance @AccNO &#x3D; @AccountNumber, @Amount &#x3D; @AmountToAdd; 35、 36、– 创建查询某储户某个月每张卡的收入明细的函数 37、CREATE FUNCTION GetIncomeDetails 38、( 39、 @IDNO CHAR(18), 40、 @Month INT, 41、 @Year INT 42、) 43、RETURNS TABLE 44、AS 45、RETURN 46、( 47、 SELECT 48、 t.AccNO, 49、 t.Income, 50、 t.TDate, 51、 t.Place, 52、 t.Abstract 53、 FROM Trecord t 54、 JOIN account a ON t.AccNO &#x3D; a.AccNO 55、 WHERE a.IDNO &#x3D; @IDNO 56、 AND MONTH(t.TDate) &#x3D; @Month 57、 AND YEAR(t.TDate) &#x3D; @Year 58、 AND t.Income IS NOT NULL 59、); 60、GO 61、 62、– 调用函数示例 63、SELECT * 64、FROM GetIncomeDetails(‘123456789012345678’, 5, 2024); 65、 66、– 在储户表上创建触发器，限定只能在每年6月20日和12月20日修改VIP的值 67、CREATE TRIGGER trg_UpdateVIP 68、ON depositor 69、AFTER UPDATE 70、AS 71、BEGIN 72、 DECLARE @CurrentDate DATE &#x3D; CAST(GETDATE() AS DATE); 73、 74、 – 检查当前日期是否为6月20日或12月20日 75、 IF @CurrentDate NOT IN (‘2024-06-20’, ‘2024-12-20’) 76、 BEGIN 77、 RAISERROR (‘只能在每年6月20日和12月20日修改VIP的值。’, 16, 1); 78、 ROLLBACK TRANSACTION; 79、 END 80、END; 81、GO 82、 83、– 触发触发器的示例 84、UPDATE depositor 85、SET VIP &#x3D; ‘是’ 86、WHERE IDNO &#x3D; ‘123456789012345678’; 87、 88、– 在交易表上创建索引 89、CREATE INDEX idx_Trecord_AccNO_TDate 90、ON Trecord (AccNO ASC, TDate ASC); 91、GO 92、 93、– 示例1：查询特定账户的所有交易记录，并按交易时间排序 94、SELECT * 95、FROM Trecord 96、WHERE AccNO &#x3D; ‘12345678901234567890’ 97、ORDER BY TDate; 98、 99、– 示例2：查询某日期范围内的所有交易记录，并按账号和交易时间排序 100、SELECT * 101、FROM Trecord 102、WHERE TDate BETWEEN ‘2024-01-01’ AND ‘2024-12-31’ 103、ORDER BY AccNO, TDate;"},{"title":"浮点数二分算法模板","path":"/2024/11/15/浮点数二分算法模板/","content":"12345678910111213bool check(double x) &#123;/* ... */&#125; // 检查x是否满足某种性质double bsearch_3(double l, double r)&#123; const double eps = 1e-6; // eps 表示精度，取决于题目对精度的要求 while (r - l &gt; eps) &#123; double mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid; &#125; return l;&#125; 例子: 给定一个浮点数 nn，求它的三次方根。 输入格式共一行，包含一个浮点数 nn。 输出格式共一行，包含一个浮点数，表示问题的解。 注意，结果保留 66 位小数。 数据范围−10000≤n≤10000−10000≤n≤10000 输入样例：11000.00 输出样例：110.000000"},{"title":"整数二分算法","path":"/2024/11/15/整数二分算法/","content":"整数二分算法模板 —— 模板题 AcWing 789. 数的范围1234567891011121314151617181920212223242526bool check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：int bsearch_1(int l, int r)&#123; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; // check()判断mid是否满足性质 else l = mid + 1; &#125; return l;&#125;// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：int bsearch_2(int l, int r)&#123; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; &#125; return l;&#125; **例子：**给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。 对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。 如果数组中不存在该元素，则返回 -1 -1。 输入格式第一行包含整数 n 和 q，表示数组长度和询问个数。 第二行包含 n 个整数（均在 1∼100001∼10000 范围内），表示完整数组。 接下来 q 行，每行包含一个整数 k，表示一个询问元素。 输出格式共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。 如果数组中不存在该元素，则返回 -1 -1。 数据范围1≤n≤1000001≤n≤1000001≤q≤100001≤q≤100001≤k≤100001≤k≤10000 输入样例：123456 31 2 2 3 3 4345 输出样例：1233 45 5-1 -1 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std ;const int N =100010;int q[N];int n ,m;int main ()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); int k; int l,r; for (int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;q[i]);while(m--)&#123; scanf(&quot;%d&quot;,&amp;k); l=0; r=n-1; while(l&lt;r)&#123; int mid =(l+r)&gt;&gt;1; if(q[mid]&gt;=k)r=mid; else l =mid+1; &#125; if(q[l]!=k)printf(&quot;-1 -1 &quot;); else &#123;printf(&quot;%d &quot;,l); l=0; r=n-1; while(l&lt;r)&#123; int mid =(r+l+1)&gt;&gt;1; if (q[mid]&lt;=k)l=mid; else r=mid -1; &#125; printf(&quot;%d &quot;,r); &#125; &#125; return 0; &#125;"},{"path":"/2024/11/14/操作系统/","content":"title: 操作系统第一章：计算机系统概述 考纲内容(一)操作系统的基本概念 (二)操作系统的发展历程 (三)程序运行环境 ​\tCPU运行模式：内核模式与用户模式； ​\t中断和异常的处理；系统调用； ​\t程序的链接与装入；程序运行时内存映像与地址空间 (四)操作系统结构 ​\t分层、模块化、宏内核、微内核、外核 (五)操作系统引导 (六)虚拟机 1.1操作系统的基本概念计算机系统自上而下分为4部分：硬件，操作系统，应用程序，用户 什么是OS？ OS是配置在计算机硬件上的第一层系统软件，是对硬件系统的首次扩充；是硬件系统和应用软件间的桥梁；是用户与计算机硬件进行交互的接口；是计算机系统资源的管理者。 OS是一组控制和管理计算机硬件和软件资源、合理地对各类作业进行调度以方便用户使用计算机的程序集合。 注意系统软件和应用软件的区别 操作系统的目标方便性有效性​\t提高系统资源的利用率 ​\t提高系统吞吐量 可扩充性开放性​\t遵循世界标准规范，特别是开放系统互连OS"},{"path":"/2024/11/13/算法归并排序/","content":"title: 归并排序 归并排序算法模板 —— 模板题 AcWing 787. 归并排序 123456789101112131415161718192021void merge_sort(int q[], int l, int r)&#123; if (l &gt;= r) return; int mid = l + r &gt;&gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i &lt;= mid) tmp[k ++ ] = q[i ++ ]; while (j &lt;= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];&#125; 上一个我感觉讲的太啰嗦了，这次讲的简单点 开头依旧是老朋友，定义一个函数 int mid &#x3D; l + r &gt;&gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); 递归老朋友了，还是分成两个区间左边到中间，中间到右边 int k &#x3D; 0, i &#x3D; l, j &#x3D; mid + 1; while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r) if (q[i] &lt;&#x3D; q[j]) tmp[k ++ ] &#x3D; q[i ++ ]; else tmp[k ++ ] &#x3D; q[j ++ ]; 从这里开始有点不同了；i&#x3D;l,j&#x3D;mid+1;j是中间值+1 然后是一个while循环，整个函数i和j相当于指针，用指针是为了不改变原来传入的参数的值，然后i和j的移动方向都是从左向右， i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r 循环的条件，最左边的指针向右移动的过程不超过中间值，中间的指针向右移动的过程不超过最右值； if (q[i] &lt;&#x3D; q[j]) tmp[k ++ ] &#x3D; q[i ++ ]; else tmp[k ++ ] &#x3D; q[j ++ ]; 左边的指针指向的值小于右边指针指向的值，将左边指针指向的值传入数组tmp[k]，不然就是将右边指针指向的数传入 即用定义的另外一个空数组将较小的那个值即q[i ++ ]装入。这样就能将部分数据从小到大排一遍。 while (i &lt;&#x3D; mid) tmp[k ++ ] &#x3D; q[i ++ ]; while (j &lt;&#x3D; r) tmp[k ++ ] &#x3D; q[j ++ ]; 这里检测一边的指针走到尽头后，如果另一边还有剩余就将剩余全部放入新建的tmp[k]数组中。这样所有数据就排序完成 for (i &#x3D; l, j &#x3D; 0; i &lt;&#x3D; r; i ++, j ++ ) q[i] &#x3D; tmp[j]; 最后将tmp[]数组中的数据再重新放回q[]这样就排序完成输出q[] 例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt; using namespace std; const int N =100010; int q[N]; int n; int tmp[N]; void merge_sort(int q[],int l, int r) &#123; if(l&gt;=r)return; int mid=(l+r)&gt;&gt;1; merge_sort(q,l,mid); merge_sort(q,mid+1,r); int k =0,i = l, j = mid + 1; while (i&lt;=mid &amp;&amp; j&lt;=r)&#123; if (q[i]&lt;=q[j])tmp[k]=q[i], k++, i++; else tmp[k]=q[j] ,j++,k++; &#125; while(i&lt;=mid) tmp[k++]=q[i++]; while(j&lt;=r) tmp[k++]=q[j++]; for(int i=l,j=0;i&lt;=r;i++,j++)q[i]=tmp[j]; &#125; int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0; i&lt;n;i++) scanf(&quot;%d&quot;,&amp;q[i]); merge_sort(q,0,n-1); for(int i=0; i&lt;n;i++) printf(&quot;%d &quot;,q[i]); return 0; &#125;"},{"title":"快速排序","path":"/2024/11/13/算法/","content":"学校要求参加一个算法比赛特地来复习一下算法重新分析一下acwing的模板复习自用 1.快速排序算法模板 —— 模板题 AcWing 785. 快速排序 1234567891011121314void quick_sort(int q[], int l, int r)&#123; if (l &gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1]; while (i &lt; j) &#123; do i ++ ; while (q[i] &lt; x); do j -- ; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]); &#125; quick_sort(q, l, j), quick_sort(q, j + 1, r);&#125; 这是个递归函数 void quick_sort(int q[], int l, int r) 意思是创建一个函数，函数里定义一个整数型数组q[],和整数l,r 这里数据全部放在数组里，其中l,r相当于数组左右两端的指针 我们先看后面的代码再看 if (l &gt;&#x3D; r) return; int i &#x3D; l - 1, j &#x3D; r + 1, x &#x3D; q[l + r &gt;&gt; 1]; 该段代码意思是，定义一个变量i&#x3D;l-1;定义一个变量j&#x3D;r+1。x&#x3D;q[l+r&gt;&gt;1];这里的意思是x取数组中间位置的值 l+r&gt;&gt;1二进制位移了一位相当于除以2. 这是比特操作,可以看做是除2，如12的二进制表示是00001100,12&gt;&gt;1将00001100右移一位，变为00000110，即6.又如15的二进制表示是00001111,15&gt;&gt;1将00001111右移一位，变为00000111，即7.另外&lt;&lt;就是左移，相当于乘以2. 补充一下：如果是12 &gt;&gt; 2，就是将00001100右移两位，变为00000011，即3。相当于12&#x2F;2^2 这里为什么要重新设置两端，将两端都移了一位，用l-1和r+1呢？因为这里我用的是do-while循环，先执行的i++，在执行的判断条件，大家也可以改成while循环。 有人说为什么不一开始就把l和r设置好呢，因为函数是被调用的，你输入的数是两端的，要考虑到用户。 首先我们要了解到我们排完序是左边小于右边 while (i &lt; j) { do i ++ ; while (q[i] &lt; x); do j – ; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]); } 然后是一个while循环,当左边指针在右边指针的左边就循环，相当于左右两边的指针不停的往对方的两边移动，在移动的过程中会有交换数据的情况，然后一旦左右指针相遇然后错过，该循环就应该结束 然后while循环里就是do-while循环先将i+1，然后看i指针指向的值是不是小于x即数组中间指针指向的值，然后如果i小于，指针就往下移一位即从左往右，一旦i&gt;&#x3D;x,到下一步do j – ; while (q[j] &gt; x);就将左边即i放在一边不管，先看右边即j，将j-1,然后然后看j指针指向的值是不是大于x即数组中间指针指向的值，然后如果j大于，指针就往下移一位即从右往左。同理如果不满足条件跳出循环，然后判断指针i是不是在指针j的左边，如果是，将左右指针的值交换，（这样部分值就被排序了）一旦i和j相遇然后他们互相越过就跳出循环 quick_sort(q, l, j), quick_sort(q, j + 1, r); 这里就是递归的关键了将左边和右边再分别放入函数，然后左边不停的左右分，右边也不停的左右分，最后变成只有2个数排序 然后让我们来看一开始的代码 if (l &gt;&#x3D; r) return; return是函数直接返回, 也就是结束该函数,要跳出循环用break, if代码段是不能用break跳出的, 在一个函数内任意位置调用return, 直接退出函数 一般来说一开始输入的数据不可能l&gt;&#x3D;r，这里可以当作一开始的过滤错误输入； 这段代码是用于二分到尽头后开始返回，当每个函数里只有两个数，再分就分不下去了，l&gt;&#x3D;r。然后return,返回上一个函数，上一个函数进行到末尾了然后也要继续返回，一直返回到最初，这个时候数组已经排序完了。 大家可以用小一点的数字自己走一遍。 下面是实例： 快速排序 给定你一个长度为 nn 的整数数列。 请你使用快速排序对这个数列按照从小到大进行排序。 并将排好序的数列按顺序输出。 输入格式输入共两行，第一行包含整数 nn。 第二行包含 nn 个整数（所有整数均在 1∼1091∼109 范围内），表示整个数列。 输出格式输出共一行，包含 nn 个整数，表示排好序的数列。 数据范围1≤n≤1000001≤n≤100000 输入样例：1253 1 2 4 5 输出样例：11 2 3 4 5 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;using namespace std;const int N =1e6+10;int a[N];int n;void quick_sort(int l, int r,int a[])&#123; int t =1; if (l&gt;=r) return; int x= a[(r+l)&gt;&gt;1]; int i=l-1; int j=r+1; while(i&lt;j)&#123; do i++;while (a[i]&lt;x); do j--;while (a[j]&gt;x); if(i&lt;j)&#123; t=a[i]; a[i]=a[j]; a[j]=t; &#125;; &#125; quick_sort(l,j,a),quick_sort(j+1,r,a); &#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0 ; i&lt;n;i++) &#123; scanf (&quot;%d&quot;,&amp;a[i]); &#125; quick_sort(0,n-1,a); for(int i=0;i&lt;n;i++) printf(&quot;%d &quot;,a[i]); return 0;&#125;"},{"title":"英语单词生词","path":"/2024/11/12/英语单词生词本1/","content":"英语单词生词本1 remarkable adj 非凡的；奇异的；引人注目的 surgery n 外科手术;（医生或牙医的）;诊所（议员的）接待时间; soundtrack n &#x2F;ˈsaʊnd.træk&#x2F; 电影声迹；（尤指）电影配乐；电影原声音带 trigger &#x2F;ˈtrɪɡ.ər&#x2F; noun （枪的）扳机 （引起某种坏事的）一件事（或情况） verb 引起，引发（坏事）"},{"title":"测试一下Typora","path":"/2024/11/11/测试一下Typora/","content":"测试一下Typora毕竟花了80大洋 然后试试玩玩 斜体 加粗 加粗和斜体 下划线 $$公式块$$ 1代码块 print（&#x27;hello world&#x27;） [!NOTE] 警告框 引用 任务序列"},{"title":"数据作业Chatgpt建表","path":"/2024/11/11/数据作业Chatgpt建表/","content":"建立teaching库 我现在使用SQL Server Management Studio 20进行数据库管理操作。现在我将给你一个数据库的脚本，然后提出一些数据库管理任务，你需要给出对应在这个数据库中的命令。要求：遵循SQL Server Management Studio 20的语法，尽量使用基础命令实现功能，直接了当给出结果，少说没必要的拓展。这是数据库的脚本CREATE DATABASE teaching ON( NAME &#x3D; ‘teaching’,FILENAME &#x3D; ‘E:\\DATA\\teaching.mdf’ ,SIZE &#x3D; 5MB ,MAXSIZE &#x3D; UNLIMITED,FILEGROWTH &#x3D; 10%) LOG ON( NAME &#x3D; ‘teaching_log’,FILENAME &#x3D; ‘E:\\DATA\\teaching_log.ldf’ , SIZE &#x3D; 8MB , MAXSIZE &#x3D; UNLIMITED , FILEGROWTH &#x3D; 1MB )CREATE TABLE student (sno char(9) PRIMARY KEY, sname nvarchar(8) NOT NULL , ssex nchar(1) NOT NULL CHECK (ssexr&#x3D;’男’ or ssex&#x3D;’女’), sbirthday date, en_time date, major nvarchar(10), grade nchar(5) NOT NULL )CREATE TABLE course (cno char(4) PRIMARY KEY, cname nvarchar(20) NOT NULL, classhour tinyint CHECK (classhour&gt;&#x3D;2 and classhour&lt;&#x3D;6), credit tinyint CHECK (credit&gt;&#x3D;1 and credit&lt;&#x3D;5) )CREATE TABLE sc( sno char(10) FOREIGN KEY REFERENCES student(sno), cno char(4) FOREIGN KEY REFERENCES course(cno), score int CHECK (score&gt;&#x3D;0 and score&lt;&#x3D;100), PRIMARY KEY(sno,cno)) 建立bankcard库 1．使用SSMS创建名为“bankcard（银行卡管理）”的数据库，并设置数据库主文件名为bankcard _data，初始大小为10MB，日志文件名为bankcard _log，初始大小为10MB，其它默认。所有的文件都放在目录“F:\\DATA”中。 存放位置也可自行决定。2．在 “bankcard”数据库中完成下列操作。(1)创建“depositor”储户表，表结构如表1：表1 储户表的表结构属性名\t类型\t宽度\t键值\t允许空否\t取值范围\t属性的含义IDNO\tchar\t18\t主键\t否 身份证号Dname\tnvarchar\t10 否 姓名Telephone\tchar\t11 否\t数字字符\t手机号VIP\tnchar\t1 否\t是或否\t贵宾储户 (2)创建“account” 账户表，表结构如表2：表2 账户表的表结构属性名\t类型\t宽度\t键值\t允许空否\t取值范围\t属性的含义AccNO\tchar\t20\t主键\t否\t数字字符\t账号IDNO\tchar\t18\t外键\t否\t参考储户表主键\t身份证号Password\tchar\t6 否\t数字字符\t密码OpenDate\tdate 否\t默认值：当前日期\t开户日期CardType\tnchar\t3 否\t信用卡、借记卡等\t卡类型MoneyType\tnvarchar\t10 否\t人民币、美元等\t币种Balance\tmoney 否 余额ExpiryDate\tdate 否\t〉OpenDate\t有效期(3)创建“Trecord”交易记录表，表结构如表3：表3 交易记录表的表结构属性名\t类型\t宽度\t键值\t允许空否\t取值范围\t属性的含义ID\tint 主键\t否\tIDENTITY(1,1) ，从1开始自动编号\t顺序号TDate\tdate 否\t默认值：当前日期\t交易时间AccNO\tchar\t20\t外键\t否\t数字字符，参考账户表主键\t账号Expense\tmoney 是 支出Income\tmoney 是 收入OppAccNO\tchar\t20\t外键\t是\t数字字符\t对方账号Place\tnvarchar\t30 是 交易地点Abstract\tnvarchar\t20 是\t转账、消费、工资、ATM取款等\t摘要"},{"title":"test","path":"/2024/10/29/test3/","content":"USE teachingGOINSERT into scvalues(‘201501001’,’X003’,NULL),(‘201502005’,’X003’,NULL),(‘201602001’,’C001’,98),(‘201602001’,’C004’,81),(‘201602001’,’X003’,85),(‘201603005’,’C001’,78),(‘201603005’,’C004’,97),(‘201701003’,’C001’,72),(‘201701003’,’E002’,73),(‘201703001’,’C001’,85),(‘201704001’,’E002’,76) Create table teacher(tno int primary key, tname nvarchar(6), prof_title nvarchar(10))gocreate table teacher_salary(tno int primary key foreign key references teacher(tno), tname nvarchar(6), salary int)go insert teacher values(1,’郑浩’,’教授’)insert teacher values(2,’王伟’,’副教授’)insert teacher values(3,’李平’,’讲师’) create table salary_level(prof_title nvarchar(10) primary key , minsalary int, maxsalary int)goinsert salary_level values(‘教授’,7000,8900)insert salary_level values(‘副教授’,5800,7200)insert salary_level values(‘讲师’,4500,5900)insert salary_level values(‘助教’,3900,4900) – 创建触发器，确保教师工资只能涨不能降create trigger trg_salary_increase_onlyon teacher_salaryafter updateasbegin if exists ( select 1 from inserted i join deleted d on i.tno &#x3D; d.tno where i.salary &lt; d.salary ) begin rollback transaction; print ‘工资不能降低，请输入正确的工资变动。’; endend;go – 插入初始工资数据insert into teacher_salary values (1, ‘郑浩’, 7500);insert into teacher_salary values (2, ‘王伟’, 6000);insert into teacher_salary values (3, ‘李平’, 4800);go – 尝试提高工资（会成功）update teacher_salaryset salary &#x3D; 8000where tno &#x3D; 1;go – 尝试降低工资（会触发触发器并回滚）update teacher_salaryset salary &#x3D; 7000where tno &#x3D; 1;go 1– 创建触发器，确保教师工资只能涨不能降CREATE TRIGGER salary_increase_onlyON teacher_salaryFOR UPDATEASDECLARE @tno int, @new_salary int, @old_salary int; – 获取更新前后的数据SELECT @tno &#x3D; i.tno, @new_salary &#x3D; i.salary, @old_salary &#x3D; d.salaryFROM inserted iJOIN deleted d ON i.tno &#x3D; d.tno; – 检查是否有降薪情况IF @new_salary &lt; @old_salaryBEGIN PRINT ‘教师工资不能降低。更新已被取消。’; ROLLBACK;END – 插入初始工资数据insert into teacher_salary values (1, ‘郑浩’, 7500);insert into teacher_salary values (2, ‘王伟’, 6000);insert into teacher_salary values (3, ‘李平’, 4800);go – 尝试更新工资并触发触发器– 提高工资（会成功）update teacher_salaryset salary &#x3D; 8000where tno &#x3D; 1;go – 降低工资（会触发触发器并回滚）update teacher_salaryset salary &#x3D; 7000where tno &#x3D; 1;go 2– 创建学生党费表 st_duesCREATE TABLE st_dues ( sno char(9) PRIMARY KEY FOREIGN KEY REFERENCES student(sno), sname nvarchar(8) NOT NULL, dues money NOT NULL); – 创建触发器，确保只能在每年的6月和12月录入党费CREATE TRIGGER trg_check_dues_monthON st_duesAFTER INSERT, UPDATEASBEGIN DECLARE @currentMonth INT; SELECT @currentMonth &#x3D; MONTH(GETDATE()); IF @currentMonth NOT IN (6, 12) BEGIN ROLLBACK TRANSACTION; RAISERROR (&#39;党费只能在每年的6月或12月交纳&#39;, 16, 1); END END; – 示例插入数据（触发触发器）INSERT INTO st_dues (sno, sname, dues)VALUES (‘123456789’, ‘张三’, 100.00); 3– 删除原有的触发器，如果存在IF EXISTS (SELECT * FROM sys.triggers WHERE name &#x3D; ‘Transactions’)DROP TRIGGER Transactions;GO – 创建新的触发器CREATE TRIGGER TransactionsON TrecordFOR INSERTASBEGIN DECLARE @AccNO CHAR(20); DECLARE @Expense MONEY; DECLARE @Income MONEY; DECLARE @CardType NCHAR(3); DECLARE @NewBalance MONEY; -- 获取插入记录的账号、支出、收入和卡种类 SELECT @AccNO = AccNO, @Expense = Expense, @Income = Income FROM inserted; -- 获取卡种类 SELECT @CardType = CardType, @NewBalance = Balance FROM account WHERE AccNO = @AccNO; -- 检查并更新账户余额 IF @Expense IS NOT NULL BEGIN SET @NewBalance = @NewBalance - @Expense; -- 如果卡类型是借记卡且余额不足，则抛出错误 IF @CardType = N&#39;借记卡&#39; AND @NewBalance &lt; 0 BEGIN RAISERROR (&#39;余额不足，交易失败。&#39;, 16, 1); ROLLBACK TRANSACTION; END ELSE BEGIN UPDATE account SET Balance = @NewBalance WHERE AccNO = @AccNO; END END ELSE BEGIN SET @NewBalance = @NewBalance + @Income; UPDATE account SET Balance = @NewBalance WHERE AccNO = @AccNO; END END;GO – 向交易记录表插入一条带有支出的记录，触发触发器INSERT INTO Trecord (TDate, AccNO, Expense, Income, OppAccNO, Place, Abstract)VALUES (GETDATE(), ‘12345678901234567890’, 500.00, NULL, ‘09876543210987654321’, ‘Supermarket’, ‘消费’); – 向交易记录表插入一条带有收入的记录，触发触发器INSERT INTO Trecord (TDate, AccNO, Expense, Income, OppAccNO, Place, Abstract)VALUES (GETDATE(), ‘12345678901234567890’, NULL, 200.00, ‘09876543210987654321’, ‘Office’, ‘工资’);"},{"title":"传奇ChatGpt驯兽手册","path":"/2024/10/22/test2/","content":"密码学上课助手 Profile现在是大学密码学的课程，请你作为一个经验丰富、技术高深的密码学高级教授，为我讲解一些课题或者疑问。讲解时需要全面完整，思路清晰，可以适当多思考一会，提升内容质量。若是解答小疑问，请简明扼要，尽量简洁高效、快速地回复，避免不必要的拓展，节省时间。在整个聊天中，作出严谨的回答，承认知识盲区（如果有的话）；要体现高级教授的知识特色和教学技巧以便开拓思维、促进理解。接下来我将给出问题，准备好了请说“就绪” 操作系统上课助手 Profile我是一个大三的信息安全学生，正在修读操作系统课程，希望你作为一个知识广博，专业性很强的操作系统老师，为我解答各种疑惑。要求节约时间，阐述简洁，突出实用性。尽量直接且简洁地回答我的问题，避免不必要的拓展。 海选备战助手 Profile背景：我将要参加互联网企业校招的海选，为了让企业招聘人员能看中我，我们需要先准备一下。 前提：我是计算机的学生，具体专业是信息安全，在校期间并没有获得一下能证明自己能力的奖项和证书，因此不能靠履历来获得青睐，只有在校招中通过和招聘官的交流，充分表现出自己的能力，才能获得一个好的结果。 你的身份：我需要你作为一个了解当下形势、富有经验、技术过硬、机灵、随机应变，懂应聘技巧的学长，了解当下的计算机行业的企业招聘实际情况（如果你并不了解，请现在上网查询了解，而不要不懂装懂。如果查询后仍然有不了解的内容，请大方承认它），同时熟悉计算机各方面技术在求职中需要怎样表现（范围包括但不限于：数据处理分析与可视化、数据库运维 、C语言编程，Python编程，熟悉 linux系统， 熟悉网络攻防，网络设备管理，密码学算法编程）。 最终目的是：指导我在应聘中给出能让招聘官青睐的表现。 引导：当我向你提出相关疑问时，给出符合你身份的，最有效贴切的回答；当且仅当我给出 LIKE ”面试官问%学科领域“ 问题时，模拟海选场景，给出如数家珍般的理解与回答。如果我需要补充初始profile，我会以’##Profile’开头补充给你。准备好了说”就绪“。"},{"title":"第一次写一下博客","path":"/2024/10/22/test1/","content":"测试一下各个模块的摆放位置 第一步测试一下标题#标题##标题###标题 标题 --- 第二步试一下段落I really like using Markdown. I think I'll use it to format all of my documents from now on. 第三步试一下换行First line with two spaces after.And the next line. First line with the HTML tag after.And the next line. 第四步试一下强调Loveisbold Italicized text is the cat’s meow. This text is really important. Markdown 引用语法要创建块引用，请在段落前添加一个 &gt; 符号。 Dorothy followed her through many of the beautiful rooms in her castle.渲染效果如下所示： Dorothy followed her through many of the beautiful rooms in her castle. 多个段落的块引用块引用可以包含多个段落。为段落之间的空白行添加一个 &gt; 符号。 Dorothy followed her through many of the beautiful rooms in her castle. The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.渲染效果如下： Dorothy followed her through many of the beautiful rooms in her castle. The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood. 嵌套块引用块引用可以嵌套。在要嵌套的段落前添加一个 &gt;&gt; 符号。 Dorothy followed her through many of the beautiful rooms in her castle. The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.渲染效果如下： Dorothy followed her through many of the beautiful rooms in her castle. The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood. 带有其它元素的块引用块引用可以包含其他 Markdown 格式的元素。并非所有元素都可以使用，你需要进行实验以查看哪些元素有效。 The quarterly results look great! Revenue was off the chart. Profits were higher than ever. Everything is going according to plan.渲染效果如下： The quarterly results look great!Revenue was off the chart.Profits were higher than ever.Everything is going according to plan. 有序列表要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。 First item Second item Third item Fourth item 无序列表要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。 First item Second item Third item Indented item Indented item Fourth item Markdown 代码语法要将单词或短语表示为代码，请将其包裹在反引号 (&#96;) 中。 At the command prompt, type nano. Markdown 分隔线语法要创建分隔线，请在单独一行上使用三个或多个星号 (***)、破折号 (—) 或下划线 (___) ，并且不能包含其他内容。 Try to put a blank line before… …and after a horizontal rule. Markdown 链接语法链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。 超链接Markdown语法代码：[超链接显示名](超链接地址 &quot;超链接title&quot;) 对应的HTML代码：&lt;a href=&quot;超链接地址&quot; title=&quot;超链接title&quot;&gt;超链接显示名&lt;/a&gt; 这是一个链接 Markdown语法。 Markdown 图片语法要添加图像，请使用感叹号 (!), 然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。 Markdown 表格要添加表，请使用三个或多个连字符（—）创建每列的标题，并使用管道（|）分隔每列。您可以选择在表的任一端添加管道。 Syntax Description Header Title Paragraph Text 对齐您可以通过在标题行中的连字符的左侧，右侧或两侧添加冒号（:），将列中的文本对齐到左侧，右侧或中心。 Syntax Description Test Text Header Title Here’s this Paragraph Text And more markdown 删除线您可以通过在单词中心放置一条水平线来删除单词。结果看起来像这样。此功能使您可以指示某些单词是一个错误，要从文档中删除。若要删除单词，请在单词前后使用两个波浪号~~。 世界是平坦的。 我们现在知道世界是圆的。"},{"title":"Hello World","path":"/2024/10/22/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]