[{"title":"数据库A 2","path":"/2024/11/18/数据库A-2/","content":"– 创建视图，查询所有信用卡账户的储户信息CREATE VIEW CreditCardCustomerInfo ASSELECT D.IDNO, D.Dname, D.Telephone, D.VIPFROM depositor DWHERE D.IDNO IN ( SELECT A.IDNO FROM account A WHERE A.CardType &#x3D; ‘信用卡’);GO 创建视图的 SQL 语句：首先，使用子查询来查询所有信用卡账户的储户信息，包括身份证号、姓名、电话和VIP状态。 12345678910sql复制代码-- 创建视图，查询所有信用卡账户的储户信息CREATE VIEW CreditCardCustomerInfo ASSELECT D.IDNO, D.Dname, D.Telephone, D.VIPFROM depositor DWHERE D.IDNO IN ( SELECT A.IDNO FROM account A WHERE A.CardType = &#x27;信用卡&#x27;);GO 分析：此视图 CreditCardCustomerInfo 会返回所有拥有信用卡账户的储户的基本信息（身份证号、姓名、电话、VIP状态）。通过使用子查询，我们能够筛选出所有信用卡账户的储户信息。主查询从 depositor 表中提取相应的储户信息，并通过子查询从 account 表中获取持有信用卡账户的储户的 IDNO。 用户如何使用此视图：此视图的使用场景主要是银行、信用卡公司或其他金融机构需要快速查看所有持有信用卡账户的储户信息。通过此视图，用户可以直接获取这些储户的基本信息，无需每次都编写复杂的查询。 使用示例： 查询所有信用卡储户的基本信息： 如果银行客服或金融机构工作人员需要查看所有信用卡持卡人的基本信息（例如，身份证号、姓名、电话和VIP状态），可以直接使用此视图。 12sql复制代码-- 查询所有信用卡储户的基本信息SELECT * FROM CreditCardCustomerInfo; 查询某个特定储户的信用卡信息： 如果某个客户服务代表需要查询特定身份证号的储户是否持有信用卡，可以使用此视图来检索该储户的基本信息。 12sql复制代码-- 查询身份证号为 &#x27;123456789012345678&#x27; 的储户信息SELECT * FROM CreditCardCustomerInfo WHERE IDNO = &#x27;123456789012345678&#x27;; 查看所有VIP储户的信用卡账户信息： 如果银行想要根据VIP状态筛选持卡人，可以通过查询视图来获取所有VIP信用卡客户的信息。 12sql复制代码-- 查询所有VIP储户的信用卡账户信息SELECT * FROM CreditCardCustomerInfo WHERE VIP = &#x27;是&#x27;; 3– 创建存储过程来修改某账户的余额 12345678910111213141516171819202122CREATE PROCEDURE UpdateAccountBalance @AccNO CHAR(20), -- 输入的账户号 @Amount MONEY -- 要加上的数值，可以为正数（存入）或负数（取出）ASBEGIN -- 检查账户是否存在 IF EXISTS (SELECT 1 FROM account WHERE AccNO = @AccNO) BEGIN -- 更新账户余额 UPDATE account SET Balance = Balance + @Amount WHERE AccNO = @AccNO; PRINT &#x27;账户余额已成功更新。&#x27;; END ELSE BEGIN PRINT &#x27;错误：账户不存在。&#x27;; ENDEND;GO 调用存储过程的语句：12345sql复制代码-- 调用存储过程，将账户号为 &#x27;12345678901234567890&#x27; 的账户余额增加 500.00EXEC UpdateAccountBalance @AccNO = &#x27;12345678901234567890&#x27;, @Amount = 500.00;-- 调用存储过程，将账户号为 &#x27;12345678901234567890&#x27; 的账户余额减少 200.00EXEC UpdateAccountBalance @AccNO = &#x27;12345678901234567890&#x27;, @Amount = -200.00; 4创建函数，查询某储户某个月每张卡的收入明细，然后调用此函数。上交内容包含创建语句和调用语句。（15分） 1234567891011121314151617181920212223242526-- 创建函数，查询某储户某个月每张卡的收入明细CREATE FUNCTION GetIncomeDetailsForDepositor( @IDNO CHAR(18), -- 输入的储户身份证号 @Year INT, -- 输入的年份 @Month INT -- 输入的月份)RETURNS TABLEASRETURN( SELECT T.AccNO, A.CardType, T.TDate, T.Income, T.Place, T.Abstract FROM Trecord T INNER JOIN account A ON T.AccNO = A.AccNO WHERE A.IDNO = @IDNO AND YEAR(T.TDate) = @Year AND MONTH(T.TDate) = @Month AND T.Income IS NOT NULL)GO 调用函数的语句123sql复制代码-- 调用函数并查询指定储户身份证号为 &#x27;123456789012345678&#x27; 在 2024 年 5 月的每张卡的收入明细SELECT * FROM GetIncomeDetailsForDepositor(&#x27;123456789012345678&#x27;, 2024, 5); 5 1234567891011121314151617181920212223-- 创建触发器，限制在储户表上只能在每年6月20日和12月20日修改VIP的值CREATE TRIGGER trg_LimitVIPUpdateON depositorAFTER UPDATEASBEGIN DECLARE @CurrentDate DATE; SET @CurrentDate = CAST(GETDATE() AS DATE); -- 检查是否更新了VIP列，并验证日期 IF UPDATE(VIP) BEGIN IF @CurrentDate NOT IN (&#x27;2024-06-20&#x27;, &#x27;2024-12-20&#x27;) BEGIN ROLLBACK TRANSACTION; RAISERROR(&#x27;VIP字段只能在每年6月20日和12月20日修改。&#x27;, 16, 1); END ENDEND;GO 创建触发器1234567891011121314151617181920sql复制代码-- 创建触发器，限制在储户表上只能在每年6月20日和12月20日修改VIP的值CREATE TRIGGER trg_LimitVIPUpdateON depositorAFTER UPDATEASBEGIN DECLARE @CurrentDate DATE; SET @CurrentDate = CAST(GETDATE() AS DATE); -- 检查是否更新了VIP列，并验证日期 IF UPDATE(VIP) BEGIN IF @CurrentDate NOT IN (&#x27;2024-06-20&#x27;, &#x27;2024-12-20&#x27;) BEGIN ROLLBACK TRANSACTION; RAISERROR(&#x27;VIP字段只能在每年6月20日和12月20日修改。&#x27;, 16, 1); END ENDEND;GO 触发触发器的示例1234sql复制代码-- 示例：尝试在不允许的日期更新VIP字段以触发触发器UPDATE depositorSET VIP = &#x27;是&#x27;WHERE IDNO = &#x27;123456789012345678&#x27;; -- 假设此身份证号存在于表中 6 1234-- 在交易记录表 (Trecord) 上创建普通索引，按账号 (AccNO) 和交易时间 (TDate) 列升序排列CREATE INDEX idx_AccNO_TDateON Trecord (AccNO ASC, TDate ASC);GO 使用此索引的查询示例 查询特定账号的交易记录，按交易时间升序排列 12345sql复制代码-- 查询账号为 &#x27;12345678901234567890&#x27; 的所有交易记录，按交易时间升序排列SELECT *FROM TrecordWHERE AccNO = &#x27;12345678901234567890&#x27;ORDER BY TDate ASC; 此查询利用索引加快了根据 AccNO 筛选并按 TDate 排序的操作。 查询指定时间范围内的所有交易记录，按账号和交易时间升序排列 12345sql复制代码-- 查询从 &#x27;2024-01-01&#x27; 到 &#x27;2024-12-31&#x27; 之间的所有交易记录，并按账号和交易时间升序排列SELECT *FROM TrecordWHERE TDate BETWEEN &#x27;2024-01-01&#x27; AND &#x27;2024-12-31&#x27;ORDER BY AccNO ASC, TDate ASC;"},{"title":"数据库A","path":"/2024/11/18/数据库A/","content":"*第二次平时测验：**A**卷**（**11**月**18**日，**14**：**00**-**15**：**2**0）* *可以直接提交答案，也可以提交**word**文档，注明**A**卷。* 1、创建视图，查询选修学时为4学时、学分为4分的课程的学号、姓名、所选课程号、课程名和成绩。然后，分析此视图用户会如何使用，并举出用户使用此视图的例子。上交内容包含创建语句，分析文字以及所有举例语句。（20分） 2、 – 创建视图，查询选修学时为4学时、学分为4分的课程的学号、姓名、所选课程号、课程名和成绩 CREATE VIEW v_student_course AS SELECT s.sno, s.sname, sc.cno, c.cname, sc.score FROM student s JOIN sc ON s.sno &#x3D; sc.sno JOIN course c ON sc.cno &#x3D; c.cno WHERE c.classhour &#x3D; 4 AND c.credit &#x3D; 4; – 分析此视图用户会如何使用： – 此视图可以用于快速查找满足特定条件的课程及选课学生的信息。教务人员可以利用该视图统计哪些学生在选修4学时且学分为4的课程时的成绩表现。此外，学生可以查询自己的成绩记录来了解选修这些特定课程的成绩。 – 用户使用此视图的例子： – 1. 查询视图中所有记录 SELECT * FROM v_student_course; – 2. 查询某个特定学生在此类课程中的成绩 SELECT * FROM v_student_course WHERE sno &#x3D; ‘202310001’; – 3. 按照成绩排序查看选修这些课程的学生信息 SELECT * FROM v_student_course ORDER BY score DESC; – 4. 查询平均成绩，用于分析学生整体表现 SELECT AVG(score) AS AverageScore FROM v_student_course; 2、创建视图，查询所有信用卡账户的储户信息（身份证号，姓名，电话，VIP)，要求用子查询完成。然后，分析此视图用户会如何使用，并举出用户使用此视图的例子。上交内容包含创建语句，分析文字以及所有举例语句。（20分） – 创建视图，用子查询查询所有信用卡账户的储户信息 CREATE VIEW CreditCardHolders AS SELECT d.IDNO, d.Dname, d.Telephone, d.VIP FROM depositor d WHERE d.IDNO IN ( ​ SELECT a.IDNO ​ FROM account a ​ WHERE a.CardType &#x3D; ‘信用卡’ ); GO – 分析： – 此视图 “CreditCardHolders” 将用于获取所有持有信用卡账户的储户信息，包括身份证号、姓名、电话和VIP状态。 – 用户可以使用该视图来进行快速查询，简化数据获取和报告生成。例如，银行的客户服务部门可以使用此视图来确认信用卡客户的信息， – 或者市场部门可以筛选出信用卡VIP客户以进行精准的营销活动。 – 使用示例： – 1. 查询所有信用卡储户信息 SELECT * FROM CreditCardHolders; – 2. 筛选VIP客户的信用卡信息 SELECT * FROM CreditCardHolders WHERE VIP &#x3D; ‘是’; – 3. 根据电话号码查找特定客户的信息 SELECT * FROM CreditCardHolders WHERE Telephone &#x3D; ‘13812345678’; 3、创建一个修改某账户余额的存储过程，即将某账户的余额加上一个输入的数值，然后调用此存储过程。上交内容包含创建语句和调用语句。（15分） – 创建修改账户余额的存储过程 CREATE PROCEDURE UpdateAccountBalance @AccNO CHAR(20), @Amount MONEY AS BEGIN – 检查账户是否存在 IF EXISTS (SELECT 1 FROM account WHERE AccNO &#x3D; @AccNO) BEGIN ​ – 更新账户余额 ​ UPDATE account ​ SET Balance &#x3D; Balance + @Amount ​ WHERE AccNO &#x3D; @AccNO; ​ PRINT ‘账户余额已成功更新。’; END ELSE BEGIN ​ PRINT ‘错误：未找到指定的账户。’; END END; GO – 调用存储过程示例 DECLARE @AccountNumber CHAR(20) &#x3D; ‘12345678901234567890’; DECLARE @AmountToAdd MONEY &#x3D; 500.00; EXEC UpdateAccountBalance @AccNO &#x3D; @AccountNumber, @Amount &#x3D; @AmountToAdd; 4、创建函数，查询某储户某个月每张卡的收入明细，然后调用此函数。上交内容包含创建语句和调用语句。（15分） – 创建修改账户余额的存储过程 CREATE PROCEDURE UpdateAccountBalance @AccNO CHAR(20), @Amount MONEY AS BEGIN – 检查账户是否存在 IF EXISTS (SELECT 1 FROM account WHERE AccNO &#x3D; @AccNO) BEGIN ​ – 更新账户余额 ​ UPDATE account ​ SET Balance &#x3D; Balance + @Amount ​ WHERE AccNO &#x3D; @AccNO; ​ PRINT ‘账户余额已成功更新。’; END ELSE BEGIN ​ PRINT ‘错误：未找到指定的账户。’; END END; GO – 调用存储过程示例 DECLARE @AccountNumber CHAR(20) &#x3D; ‘12345678901234567890’; DECLARE @AmountToAdd MONEY &#x3D; 500.00; EXEC UpdateAccountBalance @AccNO &#x3D; @AccountNumber, @Amount &#x3D; @AmountToAdd; – 创建查询某储户某个月每张卡的收入明细的函数 CREATE FUNCTION GetIncomeDetails ( @IDNO CHAR(18), @Month INT, @Year INT ) RETURNS TABLE AS RETURN ( SELECT ​ t.AccNO, ​ t.Income, ​ t.TDate, ​ t.Place, ​ t.Abstract FROM Trecord t JOIN account a ON t.AccNO &#x3D; a.AccNO WHERE a.IDNO &#x3D; @IDNO AND MONTH(t.TDate) &#x3D; @Month AND YEAR(t.TDate) &#x3D; @Year AND t.Income IS NOT NULL ); GO – 调用函数示例 SELECT * FROM GetIncomeDetails(‘123456789012345678’, 5, 2024); 5、在储户表上创建触发器，限定只能在每年6月20日和12月20日修改VIP的值，然后触发此触发器。上交内容包含创建语句和一个触发的例子。（15分） – 创建修改账户余额的存储过程 CREATE PROCEDURE UpdateAccountBalance @AccNO CHAR(20), @Amount MONEY AS BEGIN – 检查账户是否存在 IF EXISTS (SELECT 1 FROM account WHERE AccNO &#x3D; @AccNO) BEGIN ​ – 更新账户余额 ​ UPDATE account ​ SET Balance &#x3D; Balance + @Amount ​ WHERE AccNO &#x3D; @AccNO; ​ PRINT ‘账户余额已成功更新。’; END ELSE BEGIN ​ PRINT ‘错误：未找到指定的账户。’; END END; GO – 调用存储过程示例 DECLARE @AccountNumber CHAR(20) &#x3D; ‘12345678901234567890’; DECLARE @AmountToAdd MONEY &#x3D; 500.00; EXEC UpdateAccountBalance @AccNO &#x3D; @AccountNumber, @Amount &#x3D; @AmountToAdd; – 创建查询某储户某个月每张卡的收入明细的函数 CREATE FUNCTION GetIncomeDetails ( @IDNO CHAR(18), @Month INT, @Year INT ) RETURNS TABLE AS RETURN ( SELECT ​ t.AccNO, ​ t.Income, ​ t.TDate, ​ t.Place, ​ t.Abstract FROM Trecord t JOIN account a ON t.AccNO &#x3D; a.AccNO WHERE a.IDNO &#x3D; @IDNO AND MONTH(t.TDate) &#x3D; @Month AND YEAR(t.TDate) &#x3D; @Year AND t.Income IS NOT NULL ); GO – 调用函数示例 SELECT * FROM GetIncomeDetails(‘123456789012345678’, 5, 2024); – 在储户表上创建触发器，限定只能在每年6月20日和12月20日修改VIP的值 CREATE TRIGGER trg_UpdateVIP ON depositor AFTER UPDATE AS BEGIN DECLARE @CurrentDate DATE &#x3D; CAST(GETDATE() AS DATE); – 检查当前日期是否为6月20日或12月20日 IF @CurrentDate NOT IN (‘2024-06-20’, ‘2024-12-20’) BEGIN ​ RAISERROR (‘只能在每年6月20日和12月20日修改VIP的值。’, 16, 1); ​ ROLLBACK TRANSACTION; END END; GO – 触发触发器的示例 UPDATE depositor SET VIP &#x3D; ‘是’ WHERE IDNO &#x3D; ‘123456789012345678’; 6、按交易表的账号和交易时间列升序创建普通索引，然后举两个能利用此索引加快查询速度的例子。上交内容包含创建语句以及两个例子。（15分） 7、– 创建修改账户余额的存储过程 8、CREATE PROCEDURE UpdateAccountBalance 9、 @AccNO CHAR(20), 10、 @Amount MONEY 11、AS 12、BEGIN 13、 – 检查账户是否存在 14、 IF EXISTS (SELECT 1 FROM account WHERE AccNO &#x3D; @AccNO) 15、 BEGIN 16、 – 更新账户余额 17、 UPDATE account 18、 SET Balance &#x3D; Balance + @Amount 19、 WHERE AccNO &#x3D; @AccNO; 20、 21、 PRINT ‘账户余额已成功更新。’; 22、 END 23、 ELSE 24、 BEGIN 25、 PRINT ‘错误：未找到指定的账户。’; 26、 END 27、END; 28、GO 29、 30、– 调用存储过程示例 31、DECLARE @AccountNumber CHAR(20) &#x3D; ‘12345678901234567890’; 32、DECLARE @AmountToAdd MONEY &#x3D; 500.00; 33、 34、EXEC UpdateAccountBalance @AccNO &#x3D; @AccountNumber, @Amount &#x3D; @AmountToAdd; 35、 36、– 创建查询某储户某个月每张卡的收入明细的函数 37、CREATE FUNCTION GetIncomeDetails 38、( 39、 @IDNO CHAR(18), 40、 @Month INT, 41、 @Year INT 42、) 43、RETURNS TABLE 44、AS 45、RETURN 46、( 47、 SELECT 48、 t.AccNO, 49、 t.Income, 50、 t.TDate, 51、 t.Place, 52、 t.Abstract 53、 FROM Trecord t 54、 JOIN account a ON t.AccNO &#x3D; a.AccNO 55、 WHERE a.IDNO &#x3D; @IDNO 56、 AND MONTH(t.TDate) &#x3D; @Month 57、 AND YEAR(t.TDate) &#x3D; @Year 58、 AND t.Income IS NOT NULL 59、); 60、GO 61、 62、– 调用函数示例 63、SELECT * 64、FROM GetIncomeDetails(‘123456789012345678’, 5, 2024); 65、 66、– 在储户表上创建触发器，限定只能在每年6月20日和12月20日修改VIP的值 67、CREATE TRIGGER trg_UpdateVIP 68、ON depositor 69、AFTER UPDATE 70、AS 71、BEGIN 72、 DECLARE @CurrentDate DATE &#x3D; CAST(GETDATE() AS DATE); 73、 74、 – 检查当前日期是否为6月20日或12月20日 75、 IF @CurrentDate NOT IN (‘2024-06-20’, ‘2024-12-20’) 76、 BEGIN 77、 RAISERROR (‘只能在每年6月20日和12月20日修改VIP的值。’, 16, 1); 78、 ROLLBACK TRANSACTION; 79、 END 80、END; 81、GO 82、 83、– 触发触发器的示例 84、UPDATE depositor 85、SET VIP &#x3D; ‘是’ 86、WHERE IDNO &#x3D; ‘123456789012345678’; 87、 88、– 在交易表上创建索引 89、CREATE INDEX idx_Trecord_AccNO_TDate 90、ON Trecord (AccNO ASC, TDate ASC); 91、GO 92、 93、– 示例1：查询特定账户的所有交易记录，并按交易时间排序 94、SELECT * 95、FROM Trecord 96、WHERE AccNO &#x3D; ‘12345678901234567890’ 97、ORDER BY TDate; 98、 99、– 示例2：查询某日期范围内的所有交易记录，并按账号和交易时间排序 100、SELECT * 101、FROM Trecord 102、WHERE TDate BETWEEN ‘2024-01-01’ AND ‘2024-12-31’ 103、ORDER BY AccNO, TDate;"},{"title":"浮点数二分算法模板","path":"/2024/11/15/浮点数二分算法模板/","content":"12345678910111213bool check(double x) &#123;/* ... */&#125; // 检查x是否满足某种性质double bsearch_3(double l, double r)&#123; const double eps = 1e-6; // eps 表示精度，取决于题目对精度的要求 while (r - l &gt; eps) &#123; double mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid; &#125; return l;&#125; 例子: 给定一个浮点数 nn，求它的三次方根。 输入格式共一行，包含一个浮点数 nn。 输出格式共一行，包含一个浮点数，表示问题的解。 注意，结果保留 66 位小数。 数据范围−10000≤n≤10000−10000≤n≤10000 输入样例：11000.00 输出样例：110.000000"},{"title":"整数二分算法","path":"/2024/11/15/整数二分算法/","content":"整数二分算法模板 —— 模板题 AcWing 789. 数的范围1234567891011121314151617181920212223242526bool check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：int bsearch_1(int l, int r)&#123; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; // check()判断mid是否满足性质 else l = mid + 1; &#125; return l;&#125;// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：int bsearch_2(int l, int r)&#123; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; &#125; return l;&#125; **例子：**给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。 对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。 如果数组中不存在该元素，则返回 -1 -1。 输入格式第一行包含整数 n 和 q，表示数组长度和询问个数。 第二行包含 n 个整数（均在 1∼100001∼10000 范围内），表示完整数组。 接下来 q 行，每行包含一个整数 k，表示一个询问元素。 输出格式共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。 如果数组中不存在该元素，则返回 -1 -1。 数据范围1≤n≤1000001≤n≤1000001≤q≤100001≤q≤100001≤k≤100001≤k≤10000 输入样例：123456 31 2 2 3 3 4345 输出样例：1233 45 5-1 -1 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std ;const int N =100010;int q[N];int n ,m;int main ()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); int k; int l,r; for (int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;q[i]);while(m--)&#123; scanf(&quot;%d&quot;,&amp;k); l=0; r=n-1; while(l&lt;r)&#123; int mid =(l+r)&gt;&gt;1; if(q[mid]&gt;=k)r=mid; else l =mid+1; &#125; if(q[l]!=k)printf(&quot;-1 -1 &quot;); else &#123;printf(&quot;%d &quot;,l); l=0; r=n-1; while(l&lt;r)&#123; int mid =(r+l+1)&gt;&gt;1; if (q[mid]&lt;=k)l=mid; else r=mid -1; &#125; printf(&quot;%d &quot;,r); &#125; &#125; return 0; &#125;"},{"path":"/2024/11/14/操作系统/","content":"title: 操作系统第一章：计算机系统概述 考纲内容(一)操作系统的基本概念 (二)操作系统的发展历程 (三)程序运行环境 ​\tCPU运行模式：内核模式与用户模式； ​\t中断和异常的处理；系统调用； ​\t程序的链接与装入；程序运行时内存映像与地址空间 (四)操作系统结构 ​\t分层、模块化、宏内核、微内核、外核 (五)操作系统引导 (六)虚拟机 1.1操作系统的基本概念计算机系统自上而下分为4部分：硬件，操作系统，应用程序，用户 什么是OS？ OS是配置在计算机硬件上的第一层系统软件，是对硬件系统的首次扩充；是硬件系统和应用软件间的桥梁；是用户与计算机硬件进行交互的接口；是计算机系统资源的管理者。 OS是一组控制和管理计算机硬件和软件资源、合理地对各类作业进行调度以方便用户使用计算机的程序集合。 注意系统软件和应用软件的区别 操作系统的目标方便性有效性​\t提高系统资源的利用率 ​\t提高系统吞吐量 可扩充性开放性​\t遵循世界标准规范，特别是开放系统互连OS"},{"path":"/2024/11/13/算法归并排序/","content":"title: 归并排序 归并排序算法模板 —— 模板题 AcWing 787. 归并排序 123456789101112131415161718192021void merge_sort(int q[], int l, int r)&#123; if (l &gt;= r) return; int mid = l + r &gt;&gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i &lt;= mid) tmp[k ++ ] = q[i ++ ]; while (j &lt;= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];&#125; 上一个我感觉讲的太啰嗦了，这次讲的简单点 开头依旧是老朋友，定义一个函数 int mid &#x3D; l + r &gt;&gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); 递归老朋友了，还是分成两个区间左边到中间，中间到右边 int k &#x3D; 0, i &#x3D; l, j &#x3D; mid + 1; while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r) if (q[i] &lt;&#x3D; q[j]) tmp[k ++ ] &#x3D; q[i ++ ]; else tmp[k ++ ] &#x3D; q[j ++ ]; 从这里开始有点不同了；i&#x3D;l,j&#x3D;mid+1;j是中间值+1 然后是一个while循环，整个函数i和j相当于指针，用指针是为了不改变原来传入的参数的值，然后i和j的移动方向都是从左向右， i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r 循环的条件，最左边的指针向右移动的过程不超过中间值，中间的指针向右移动的过程不超过最右值； if (q[i] &lt;&#x3D; q[j]) tmp[k ++ ] &#x3D; q[i ++ ]; else tmp[k ++ ] &#x3D; q[j ++ ]; 左边的指针指向的值小于右边指针指向的值，将左边指针指向的值传入数组tmp[k]，不然就是将右边指针指向的数传入 即用定义的另外一个空数组将较小的那个值即q[i ++ ]装入。这样就能将部分数据从小到大排一遍。 while (i &lt;&#x3D; mid) tmp[k ++ ] &#x3D; q[i ++ ]; while (j &lt;&#x3D; r) tmp[k ++ ] &#x3D; q[j ++ ]; 这里检测一边的指针走到尽头后，如果另一边还有剩余就将剩余全部放入新建的tmp[k]数组中。这样所有数据就排序完成 for (i &#x3D; l, j &#x3D; 0; i &lt;&#x3D; r; i ++, j ++ ) q[i] &#x3D; tmp[j]; 最后将tmp[]数组中的数据再重新放回q[]这样就排序完成输出q[] 例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt; using namespace std; const int N =100010; int q[N]; int n; int tmp[N]; void merge_sort(int q[],int l, int r) &#123; if(l&gt;=r)return; int mid=(l+r)&gt;&gt;1; merge_sort(q,l,mid); merge_sort(q,mid+1,r); int k =0,i = l, j = mid + 1; while (i&lt;=mid &amp;&amp; j&lt;=r)&#123; if (q[i]&lt;=q[j])tmp[k]=q[i], k++, i++; else tmp[k]=q[j] ,j++,k++; &#125; while(i&lt;=mid) tmp[k++]=q[i++]; while(j&lt;=r) tmp[k++]=q[j++]; for(int i=l,j=0;i&lt;=r;i++,j++)q[i]=tmp[j]; &#125; int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0; i&lt;n;i++) scanf(&quot;%d&quot;,&amp;q[i]); merge_sort(q,0,n-1); for(int i=0; i&lt;n;i++) printf(&quot;%d &quot;,q[i]); return 0; &#125;"},{"title":"快速排序","path":"/2024/11/13/算法/","content":"学校要求参加一个算法比赛特地来复习一下算法重新分析一下acwing的模板复习自用 1.快速排序算法模板 —— 模板题 AcWing 785. 快速排序 1234567891011121314void quick_sort(int q[], int l, int r)&#123; if (l &gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1]; while (i &lt; j) &#123; do i ++ ; while (q[i] &lt; x); do j -- ; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]); &#125; quick_sort(q, l, j), quick_sort(q, j + 1, r);&#125; 这是个递归函数 void quick_sort(int q[], int l, int r) 意思是创建一个函数，函数里定义一个整数型数组q[],和整数l,r 这里数据全部放在数组里，其中l,r相当于数组左右两端的指针 我们先看后面的代码再看 if (l &gt;&#x3D; r) return; int i &#x3D; l - 1, j &#x3D; r + 1, x &#x3D; q[l + r &gt;&gt; 1]; 该段代码意思是，定义一个变量i&#x3D;l-1;定义一个变量j&#x3D;r+1。x&#x3D;q[l+r&gt;&gt;1];这里的意思是x取数组中间位置的值 l+r&gt;&gt;1二进制位移了一位相当于除以2. 这是比特操作,可以看做是除2，如12的二进制表示是00001100,12&gt;&gt;1将00001100右移一位，变为00000110，即6.又如15的二进制表示是00001111,15&gt;&gt;1将00001111右移一位，变为00000111，即7.另外&lt;&lt;就是左移，相当于乘以2. 补充一下：如果是12 &gt;&gt; 2，就是将00001100右移两位，变为00000011，即3。相当于12&#x2F;2^2 这里为什么要重新设置两端，将两端都移了一位，用l-1和r+1呢？因为这里我用的是do-while循环，先执行的i++，在执行的判断条件，大家也可以改成while循环。 有人说为什么不一开始就把l和r设置好呢，因为函数是被调用的，你输入的数是两端的，要考虑到用户。 首先我们要了解到我们排完序是左边小于右边 while (i &lt; j) { do i ++ ; while (q[i] &lt; x); do j – ; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]); } 然后是一个while循环,当左边指针在右边指针的左边就循环，相当于左右两边的指针不停的往对方的两边移动，在移动的过程中会有交换数据的情况，然后一旦左右指针相遇然后错过，该循环就应该结束 然后while循环里就是do-while循环先将i+1，然后看i指针指向的值是不是小于x即数组中间指针指向的值，然后如果i小于，指针就往下移一位即从左往右，一旦i&gt;&#x3D;x,到下一步do j – ; while (q[j] &gt; x);就将左边即i放在一边不管，先看右边即j，将j-1,然后然后看j指针指向的值是不是大于x即数组中间指针指向的值，然后如果j大于，指针就往下移一位即从右往左。同理如果不满足条件跳出循环，然后判断指针i是不是在指针j的左边，如果是，将左右指针的值交换，（这样部分值就被排序了）一旦i和j相遇然后他们互相越过就跳出循环 quick_sort(q, l, j), quick_sort(q, j + 1, r); 这里就是递归的关键了将左边和右边再分别放入函数，然后左边不停的左右分，右边也不停的左右分，最后变成只有2个数排序 然后让我们来看一开始的代码 if (l &gt;&#x3D; r) return; return是函数直接返回, 也就是结束该函数,要跳出循环用break, if代码段是不能用break跳出的, 在一个函数内任意位置调用return, 直接退出函数 一般来说一开始输入的数据不可能l&gt;&#x3D;r，这里可以当作一开始的过滤错误输入； 这段代码是用于二分到尽头后开始返回，当每个函数里只有两个数，再分就分不下去了，l&gt;&#x3D;r。然后return,返回上一个函数，上一个函数进行到末尾了然后也要继续返回，一直返回到最初，这个时候数组已经排序完了。 大家可以用小一点的数字自己走一遍。 下面是实例： 快速排序 给定你一个长度为 nn 的整数数列。 请你使用快速排序对这个数列按照从小到大进行排序。 并将排好序的数列按顺序输出。 输入格式输入共两行，第一行包含整数 nn。 第二行包含 nn 个整数（所有整数均在 1∼1091∼109 范围内），表示整个数列。 输出格式输出共一行，包含 nn 个整数，表示排好序的数列。 数据范围1≤n≤1000001≤n≤100000 输入样例：1253 1 2 4 5 输出样例：11 2 3 4 5 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;using namespace std;const int N =1e6+10;int a[N];int n;void quick_sort(int l, int r,int a[])&#123; int t =1; if (l&gt;=r) return; int x= a[(r+l)&gt;&gt;1]; int i=l-1; int j=r+1; while(i&lt;j)&#123; do i++;while (a[i]&lt;x); do j--;while (a[j]&gt;x); if(i&lt;j)&#123; t=a[i]; a[i]=a[j]; a[j]=t; &#125;; &#125; quick_sort(l,j,a),quick_sort(j+1,r,a); &#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0 ; i&lt;n;i++) &#123; scanf (&quot;%d&quot;,&amp;a[i]); &#125; quick_sort(0,n-1,a); for(int i=0;i&lt;n;i++) printf(&quot;%d &quot;,a[i]); return 0;&#125;"},{"title":"英语单词生词","path":"/2024/11/12/英语单词生词本1/","content":"英语单词生词本1 remarkable adj 非凡的；奇异的；引人注目的 surgery n 外科手术;（医生或牙医的）;诊所（议员的）接待时间; soundtrack n &#x2F;ˈsaʊnd.træk&#x2F; 电影声迹；（尤指）电影配乐；电影原声音带 trigger &#x2F;ˈtrɪɡ.ər&#x2F; noun （枪的）扳机 （引起某种坏事的）一件事（或情况） verb 引起，引发（坏事）"},{"title":"测试一下Typora","path":"/2024/11/11/测试一下Typora/","content":"测试一下Typora毕竟花了80大洋 然后试试玩玩 斜体 加粗 加粗和斜体 下划线 $$公式块$$ 1代码块 print（&#x27;hello world&#x27;） [!NOTE] 警告框 引用 任务序列"},{"title":"数据作业Chatgpt建表","path":"/2024/11/11/数据作业Chatgpt建表/","content":"建立teaching库 我现在使用SQL Server Management Studio 20进行数据库管理操作。现在我将给你一个数据库的脚本，然后提出一些数据库管理任务，你需要给出对应在这个数据库中的命令。要求：遵循SQL Server Management Studio 20的语法，尽量使用基础命令实现功能，直接了当给出结果，少说没必要的拓展。这是数据库的脚本CREATE DATABASE teaching ON( NAME &#x3D; ‘teaching’,FILENAME &#x3D; ‘E:\\DATA\\teaching.mdf’ ,SIZE &#x3D; 5MB ,MAXSIZE &#x3D; UNLIMITED,FILEGROWTH &#x3D; 10%) LOG ON( NAME &#x3D; ‘teaching_log’,FILENAME &#x3D; ‘E:\\DATA\\teaching_log.ldf’ , SIZE &#x3D; 8MB , MAXSIZE &#x3D; UNLIMITED , FILEGROWTH &#x3D; 1MB )CREATE TABLE student (sno char(9) PRIMARY KEY, sname nvarchar(8) NOT NULL , ssex nchar(1) NOT NULL CHECK (ssexr&#x3D;’男’ or ssex&#x3D;’女’), sbirthday date, en_time date, major nvarchar(10), grade nchar(5) NOT NULL )CREATE TABLE course (cno char(4) PRIMARY KEY, cname nvarchar(20) NOT NULL, classhour tinyint CHECK (classhour&gt;&#x3D;2 and classhour&lt;&#x3D;6), credit tinyint CHECK (credit&gt;&#x3D;1 and credit&lt;&#x3D;5) )CREATE TABLE sc( sno char(10) FOREIGN KEY REFERENCES student(sno), cno char(4) FOREIGN KEY REFERENCES course(cno), score int CHECK (score&gt;&#x3D;0 and score&lt;&#x3D;100), PRIMARY KEY(sno,cno)) 建立bankcard库 1．使用SSMS创建名为“bankcard（银行卡管理）”的数据库，并设置数据库主文件名为bankcard _data，初始大小为10MB，日志文件名为bankcard _log，初始大小为10MB，其它默认。所有的文件都放在目录“F:\\DATA”中。 存放位置也可自行决定。2．在 “bankcard”数据库中完成下列操作。(1)创建“depositor”储户表，表结构如表1：表1 储户表的表结构属性名\t类型\t宽度\t键值\t允许空否\t取值范围\t属性的含义IDNO\tchar\t18\t主键\t否 身份证号Dname\tnvarchar\t10 否 姓名Telephone\tchar\t11 否\t数字字符\t手机号VIP\tnchar\t1 否\t是或否\t贵宾储户 (2)创建“account” 账户表，表结构如表2：表2 账户表的表结构属性名\t类型\t宽度\t键值\t允许空否\t取值范围\t属性的含义AccNO\tchar\t20\t主键\t否\t数字字符\t账号IDNO\tchar\t18\t外键\t否\t参考储户表主键\t身份证号Password\tchar\t6 否\t数字字符\t密码OpenDate\tdate 否\t默认值：当前日期\t开户日期CardType\tnchar\t3 否\t信用卡、借记卡等\t卡类型MoneyType\tnvarchar\t10 否\t人民币、美元等\t币种Balance\tmoney 否 余额ExpiryDate\tdate 否\t〉OpenDate\t有效期(3)创建“Trecord”交易记录表，表结构如表3：表3 交易记录表的表结构属性名\t类型\t宽度\t键值\t允许空否\t取值范围\t属性的含义ID\tint 主键\t否\tIDENTITY(1,1) ，从1开始自动编号\t顺序号TDate\tdate 否\t默认值：当前日期\t交易时间AccNO\tchar\t20\t外键\t否\t数字字符，参考账户表主键\t账号Expense\tmoney 是 支出Income\tmoney 是 收入OppAccNO\tchar\t20\t外键\t是\t数字字符\t对方账号Place\tnvarchar\t30 是 交易地点Abstract\tnvarchar\t20 是\t转账、消费、工资、ATM取款等\t摘要"},{"title":"test","path":"/2024/10/29/test3/","content":"USE teachingGOINSERT into scvalues(‘201501001’,’X003’,NULL),(‘201502005’,’X003’,NULL),(‘201602001’,’C001’,98),(‘201602001’,’C004’,81),(‘201602001’,’X003’,85),(‘201603005’,’C001’,78),(‘201603005’,’C004’,97),(‘201701003’,’C001’,72),(‘201701003’,’E002’,73),(‘201703001’,’C001’,85),(‘201704001’,’E002’,76) Create table teacher(tno int primary key, tname nvarchar(6), prof_title nvarchar(10))gocreate table teacher_salary(tno int primary key foreign key references teacher(tno), tname nvarchar(6), salary int)go insert teacher values(1,’郑浩’,’教授’)insert teacher values(2,’王伟’,’副教授’)insert teacher values(3,’李平’,’讲师’) create table salary_level(prof_title nvarchar(10) primary key , minsalary int, maxsalary int)goinsert salary_level values(‘教授’,7000,8900)insert salary_level values(‘副教授’,5800,7200)insert salary_level values(‘讲师’,4500,5900)insert salary_level values(‘助教’,3900,4900) – 创建触发器，确保教师工资只能涨不能降create trigger trg_salary_increase_onlyon teacher_salaryafter updateasbegin if exists ( select 1 from inserted i join deleted d on i.tno &#x3D; d.tno where i.salary &lt; d.salary ) begin rollback transaction; print ‘工资不能降低，请输入正确的工资变动。’; endend;go – 插入初始工资数据insert into teacher_salary values (1, ‘郑浩’, 7500);insert into teacher_salary values (2, ‘王伟’, 6000);insert into teacher_salary values (3, ‘李平’, 4800);go – 尝试提高工资（会成功）update teacher_salaryset salary &#x3D; 8000where tno &#x3D; 1;go – 尝试降低工资（会触发触发器并回滚）update teacher_salaryset salary &#x3D; 7000where tno &#x3D; 1;go 1– 创建触发器，确保教师工资只能涨不能降CREATE TRIGGER salary_increase_onlyON teacher_salaryFOR UPDATEASDECLARE @tno int, @new_salary int, @old_salary int; – 获取更新前后的数据SELECT @tno &#x3D; i.tno, @new_salary &#x3D; i.salary, @old_salary &#x3D; d.salaryFROM inserted iJOIN deleted d ON i.tno &#x3D; d.tno; – 检查是否有降薪情况IF @new_salary &lt; @old_salaryBEGIN PRINT ‘教师工资不能降低。更新已被取消。’; ROLLBACK;END – 插入初始工资数据insert into teacher_salary values (1, ‘郑浩’, 7500);insert into teacher_salary values (2, ‘王伟’, 6000);insert into teacher_salary values (3, ‘李平’, 4800);go – 尝试更新工资并触发触发器– 提高工资（会成功）update teacher_salaryset salary &#x3D; 8000where tno &#x3D; 1;go – 降低工资（会触发触发器并回滚）update teacher_salaryset salary &#x3D; 7000where tno &#x3D; 1;go 2– 创建学生党费表 st_duesCREATE TABLE st_dues ( sno char(9) PRIMARY KEY FOREIGN KEY REFERENCES student(sno), sname nvarchar(8) NOT NULL, dues money NOT NULL); – 创建触发器，确保只能在每年的6月和12月录入党费CREATE TRIGGER trg_check_dues_monthON st_duesAFTER INSERT, UPDATEASBEGIN DECLARE @currentMonth INT; SELECT @currentMonth &#x3D; MONTH(GETDATE()); IF @currentMonth NOT IN (6, 12) BEGIN ROLLBACK TRANSACTION; RAISERROR (&#39;党费只能在每年的6月或12月交纳&#39;, 16, 1); END END; – 示例插入数据（触发触发器）INSERT INTO st_dues (sno, sname, dues)VALUES (‘123456789’, ‘张三’, 100.00); 3– 删除原有的触发器，如果存在IF EXISTS (SELECT * FROM sys.triggers WHERE name &#x3D; ‘Transactions’)DROP TRIGGER Transactions;GO – 创建新的触发器CREATE TRIGGER TransactionsON TrecordFOR INSERTASBEGIN DECLARE @AccNO CHAR(20); DECLARE @Expense MONEY; DECLARE @Income MONEY; DECLARE @CardType NCHAR(3); DECLARE @NewBalance MONEY; -- 获取插入记录的账号、支出、收入和卡种类 SELECT @AccNO = AccNO, @Expense = Expense, @Income = Income FROM inserted; -- 获取卡种类 SELECT @CardType = CardType, @NewBalance = Balance FROM account WHERE AccNO = @AccNO; -- 检查并更新账户余额 IF @Expense IS NOT NULL BEGIN SET @NewBalance = @NewBalance - @Expense; -- 如果卡类型是借记卡且余额不足，则抛出错误 IF @CardType = N&#39;借记卡&#39; AND @NewBalance &lt; 0 BEGIN RAISERROR (&#39;余额不足，交易失败。&#39;, 16, 1); ROLLBACK TRANSACTION; END ELSE BEGIN UPDATE account SET Balance = @NewBalance WHERE AccNO = @AccNO; END END ELSE BEGIN SET @NewBalance = @NewBalance + @Income; UPDATE account SET Balance = @NewBalance WHERE AccNO = @AccNO; END END;GO – 向交易记录表插入一条带有支出的记录，触发触发器INSERT INTO Trecord (TDate, AccNO, Expense, Income, OppAccNO, Place, Abstract)VALUES (GETDATE(), ‘12345678901234567890’, 500.00, NULL, ‘09876543210987654321’, ‘Supermarket’, ‘消费’); – 向交易记录表插入一条带有收入的记录，触发触发器INSERT INTO Trecord (TDate, AccNO, Expense, Income, OppAccNO, Place, Abstract)VALUES (GETDATE(), ‘12345678901234567890’, NULL, 200.00, ‘09876543210987654321’, ‘Office’, ‘工资’);"},{"title":"传奇ChatGpt驯兽手册","path":"/2024/10/22/test2/","content":"密码学上课助手 Profile现在是大学密码学的课程，请你作为一个经验丰富、技术高深的密码学高级教授，为我讲解一些课题或者疑问。讲解时需要全面完整，思路清晰，可以适当多思考一会，提升内容质量。若是解答小疑问，请简明扼要，尽量简洁高效、快速地回复，避免不必要的拓展，节省时间。在整个聊天中，作出严谨的回答，承认知识盲区（如果有的话）；要体现高级教授的知识特色和教学技巧以便开拓思维、促进理解。接下来我将给出问题，准备好了请说“就绪” 操作系统上课助手 Profile我是一个大三的信息安全学生，正在修读操作系统课程，希望你作为一个知识广博，专业性很强的操作系统老师，为我解答各种疑惑。要求节约时间，阐述简洁，突出实用性。尽量直接且简洁地回答我的问题，避免不必要的拓展。 海选备战助手 Profile背景：我将要参加互联网企业校招的海选，为了让企业招聘人员能看中我，我们需要先准备一下。 前提：我是计算机的学生，具体专业是信息安全，在校期间并没有获得一下能证明自己能力的奖项和证书，因此不能靠履历来获得青睐，只有在校招中通过和招聘官的交流，充分表现出自己的能力，才能获得一个好的结果。 你的身份：我需要你作为一个了解当下形势、富有经验、技术过硬、机灵、随机应变，懂应聘技巧的学长，了解当下的计算机行业的企业招聘实际情况（如果你并不了解，请现在上网查询了解，而不要不懂装懂。如果查询后仍然有不了解的内容，请大方承认它），同时熟悉计算机各方面技术在求职中需要怎样表现（范围包括但不限于：数据处理分析与可视化、数据库运维 、C语言编程，Python编程，熟悉 linux系统， 熟悉网络攻防，网络设备管理，密码学算法编程）。 最终目的是：指导我在应聘中给出能让招聘官青睐的表现。 引导：当我向你提出相关疑问时，给出符合你身份的，最有效贴切的回答；当且仅当我给出 LIKE ”面试官问%学科领域“ 问题时，模拟海选场景，给出如数家珍般的理解与回答。如果我需要补充初始profile，我会以’##Profile’开头补充给你。准备好了说”就绪“。"},{"title":"第一次写一下博客","path":"/2024/10/22/test1/","content":"测试一下各个模块的摆放位置 第一步测试一下标题#标题##标题###标题 标题 --- 第二步试一下段落I really like using Markdown. I think I'll use it to format all of my documents from now on. 第三步试一下换行First line with two spaces after.And the next line. First line with the HTML tag after.And the next line. 第四步试一下强调Loveisbold Italicized text is the cat’s meow. This text is really important. Markdown 引用语法要创建块引用，请在段落前添加一个 &gt; 符号。 Dorothy followed her through many of the beautiful rooms in her castle.渲染效果如下所示： Dorothy followed her through many of the beautiful rooms in her castle. 多个段落的块引用块引用可以包含多个段落。为段落之间的空白行添加一个 &gt; 符号。 Dorothy followed her through many of the beautiful rooms in her castle. The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.渲染效果如下： Dorothy followed her through many of the beautiful rooms in her castle. The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood. 嵌套块引用块引用可以嵌套。在要嵌套的段落前添加一个 &gt;&gt; 符号。 Dorothy followed her through many of the beautiful rooms in her castle. The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.渲染效果如下： Dorothy followed her through many of the beautiful rooms in her castle. The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood. 带有其它元素的块引用块引用可以包含其他 Markdown 格式的元素。并非所有元素都可以使用，你需要进行实验以查看哪些元素有效。 The quarterly results look great! Revenue was off the chart. Profits were higher than ever. Everything is going according to plan.渲染效果如下： The quarterly results look great!Revenue was off the chart.Profits were higher than ever.Everything is going according to plan. 有序列表要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。 First item Second item Third item Fourth item 无序列表要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。 First item Second item Third item Indented item Indented item Fourth item Markdown 代码语法要将单词或短语表示为代码，请将其包裹在反引号 (&#96;) 中。 At the command prompt, type nano. Markdown 分隔线语法要创建分隔线，请在单独一行上使用三个或多个星号 (***)、破折号 (—) 或下划线 (___) ，并且不能包含其他内容。 Try to put a blank line before… …and after a horizontal rule. Markdown 链接语法链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。 超链接Markdown语法代码：[超链接显示名](超链接地址 &quot;超链接title&quot;) 对应的HTML代码：&lt;a href=&quot;超链接地址&quot; title=&quot;超链接title&quot;&gt;超链接显示名&lt;/a&gt; 这是一个链接 Markdown语法。 Markdown 图片语法要添加图像，请使用感叹号 (!), 然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。 Markdown 表格要添加表，请使用三个或多个连字符（—）创建每列的标题，并使用管道（|）分隔每列。您可以选择在表的任一端添加管道。 Syntax Description Header Title Paragraph Text 对齐您可以通过在标题行中的连字符的左侧，右侧或两侧添加冒号（:），将列中的文本对齐到左侧，右侧或中心。 Syntax Description Test Text Header Title Here’s this Paragraph Text And more markdown 删除线您可以通过在单词中心放置一条水平线来删除单词。结果看起来像这样。此功能使您可以指示某些单词是一个错误，要从文档中删除。若要删除单词，请在单词前后使用两个波浪号~~。 世界是平坦的。 我们现在知道世界是圆的。"},{"title":"Hello World","path":"/2024/10/22/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]